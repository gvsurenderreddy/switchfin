diff -Pur u-boot-2010.06-2010R1-RC2/board/pr1/config.mk u-boot-2010.06-2010R1-RC2-pr1/board/pr1/config.mk
--- u-boot-2010.06-2010R1-RC2/board/pr1/config.mk	1970-01-01 02:00:00.000000000 +0200
+++ u-boot-2010.06-2010R1-RC2-pr1/board/pr1/config.mk	2011-10-27 20:14:54.000000000 +0300
@@ -0,0 +1,35 @@
+#
+# Copyright (c) 2005-2008 Analog Device Inc.
+#
+# (C) Copyright 2001
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+# This is not actually used for Blackfin boards so do not change it
+#TEXT_BASE = do-not-use-me
+
+CFLAGS_lib += -O2
+CFLAGS_lib/lzma += -O2
+
+# Set some default LDR flags based on boot mode.
+LDR_FLAGS-BFIN_BOOT_PARA := --bits 16 --dma 8
+LDR_FLAGS-BFIN_BOOT_UART := --port g --gpio 6
+LDR_FLAGS += $(LDR_FLAGS-$(CONFIG_BFIN_BOOT_MODE))
diff -Pur u-boot-2010.06-2010R1-RC2/board/pr1/Makefile u-boot-2010.06-2010R1-RC2-pr1/board/pr1/Makefile
--- u-boot-2010.06-2010R1-RC2/board/pr1/Makefile	1970-01-01 02:00:00.000000000 +0200
+++ u-boot-2010.06-2010R1-RC2-pr1/board/pr1/Makefile	2011-10-27 20:14:54.000000000 +0300
@@ -0,0 +1,55 @@
+#
+# U-boot - Makefile
+#
+# Copyright (c) 2005-2007 Analog Device Inc.
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS-y	:= $(BOARD).o
+COBJS-$(CONFIG_POST)       += post.o post-memory.o
+
+SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -Pur u-boot-2010.06-2010R1-RC2/board/pr1/post.c u-boot-2010.06-2010R1-RC2-pr1/board/pr1/post.c
--- u-boot-2010.06-2010R1-RC2/board/pr1/post.c	1970-01-01 02:00:00.000000000 +0200
+++ u-boot-2010.06-2010R1-RC2-pr1/board/pr1/post.c	2011-10-27 20:14:54.000000000 +0300
@@ -0,0 +1,244 @@
+/*
+ * BF537-STAMP POST code
+ *
+ * Enter bugs at http://blackfin.uclinux.org/
+ *
+ * Copyright (c) 2005-2009 Analog Devices Inc.
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#include <common.h>
+#include <config.h>
+#include <command.h>
+#include <asm/blackfin.h>
+
+#define POST_WORD_ADDR 0xFF903FFC
+
+/* Using sw10-PF5 as the hotkey */
+int post_hotkeys_pressed(void)
+{
+	int delay = 3;
+	int i;
+	unsigned short value;
+
+	*pPORTF_FER &= ~PF5;
+	*pPORTFIO_DIR &= ~PF5;
+	*pPORTFIO_INEN |= PF5;
+
+	printf("########Press SW10 to enter Memory POST########: %2d ", delay);
+	while (delay--) {
+		for (i = 0; i < 100; i++) {
+			value = *pPORTFIO & PF5;
+			if (value != 0) {
+				break;
+			}
+			udelay(10000);
+		}
+		printf("\b\b\b%2d ", delay);
+	}
+	printf("\b\b\b 0");
+	printf("\n");
+	if (value == 0)
+		return 0;
+	else {
+		printf("Hotkey has been pressed, Enter POST . . . . . .\n");
+		return 1;
+	}
+}
+
+void post_word_store(ulong a)
+{
+	volatile ulong *save_addr = (volatile ulong *)POST_WORD_ADDR;
+	*save_addr = a;
+}
+
+ulong post_word_load(void)
+{
+	volatile ulong *save_addr = (volatile ulong *)POST_WORD_ADDR;
+	return *save_addr;
+}
+
+int uart_post_test(int flags)
+{
+	return 0;
+}
+
+#define BLOCK_SIZE 0x10000
+#define VERIFY_ADDR 0x2000000
+extern int erase_block_flash(int);
+extern int write_data(long lStart, long lCount, uchar * pnData);
+int flash_post_test(int flags)
+{
+	unsigned short *pbuf, *temp;
+	int offset, n, i;
+	int value = 0;
+	int result = 0;
+	printf("\n");
+	pbuf = (unsigned short *)VERIFY_ADDR;
+	temp = pbuf;
+	for (n = FLASH_START_POST_BLOCK; n < FLASH_END_POST_BLOCK; n++) {
+		offset = (n - 7) * BLOCK_SIZE;
+		printf("--------Erase   block:%2d..", n);
+		erase_block_flash(n);
+		printf("OK\r");
+		printf("--------Program block:%2d...", n);
+		write_data(CONFIG_SYS_FLASH_BASE + offset, BLOCK_SIZE, pbuf);
+		printf("OK\r");
+		printf("--------Verify  block:%2d...", n);
+		for (i = 0; i < BLOCK_SIZE; i += 2) {
+			if (*(unsigned short *)(CONFIG_SYS_FLASH_BASE + offset + i) !=
+			    *temp++) {
+				value = 1;
+				result = 1;
+			}
+		}
+		if (value)
+			printf("failed\n");
+		else
+			printf("OK		%3d%%\r",
+			       (int)(
+				     (n + 1 -
+				      FLASH_START_POST_BLOCK) *
+				     100 / (FLASH_END_POST_BLOCK -
+					    FLASH_START_POST_BLOCK)));
+
+		temp = pbuf;
+		value = 0;
+	}
+	printf("\n");
+	if (result)
+		return -1;
+	else
+		return 0;
+}
+
+/****************************************************
+ * LED1 ---- PF6	LED2 ---- PF7		    *
+ * LED3 ---- PF8	LED4 ---- PF9		    *
+ * LED5 ---- PF10	LED6 ---- PF11		    *
+ ****************************************************/
+int led_post_test(int flags)
+{
+	*pPORTF_FER &= ~(PF6 | PF7 | PF8 | PF9 | PF10 | PF11);
+	*pPORTFIO_DIR |= PF6 | PF7 | PF8 | PF9 | PF10 | PF11;
+	*pPORTFIO_INEN &= ~(PF6 | PF7 | PF8 | PF9 | PF10 | PF11);
+	*pPORTFIO &= ~(PF6 | PF7 | PF8 | PF9 | PF10 | PF11);
+	udelay(1000000);
+	printf("LED1 on");
+	*pPORTFIO |= PF6;
+	udelay(1000000);
+	printf("\b\b\b\b\b\b\b");
+	printf("LED2 on");
+	*pPORTFIO |= PF7;
+	udelay(1000000);
+	printf("\b\b\b\b\b\b\b");
+	printf("LED3 on");
+	*pPORTFIO |= PF8;
+	udelay(1000000);
+	printf("\b\b\b\b\b\b\b");
+	printf("LED4 on");
+	*pPORTFIO |= PF9;
+	udelay(1000000);
+	printf("\b\b\b\b\b\b\b");
+	printf("LED5 on");
+	*pPORTFIO |= PF10;
+	udelay(1000000);
+	printf("\b\b\b\b\b\b\b");
+	printf("lED6 on");
+	*pPORTFIO |= PF11;
+	printf("\b\b\b\b\b\b\b ");
+	return 0;
+}
+
+/************************************************
+ *  SW10 ---- PF5	SW11 ---- PF4		*
+ *  SW12 ---- PF3	SW13 ---- PF2		*
+ ************************************************/
+int button_post_test(int flags)
+{
+	int i, delay = 5;
+	unsigned short value = 0;
+	int result = 0;
+
+	*pPORTF_FER &= ~(PF5 | PF4 | PF3 | PF2);
+	*pPORTFIO_DIR &= ~(PF5 | PF4 | PF3 | PF2);
+	*pPORTFIO_INEN |= (PF5 | PF4 | PF3 | PF2);
+
+	printf("\n--------Press SW10: %2d ", delay);
+	while (delay--) {
+		for (i = 0; i < 100; i++) {
+			value = *pPORTFIO & PF5;
+			if (value != 0) {
+				break;
+			}
+			udelay(10000);
+		}
+		printf("\b\b\b%2d ", delay);
+	}
+	if (value != 0)
+		printf("\b\bOK");
+	else {
+		result = -1;
+		printf("\b\bfailed");
+	}
+
+	delay = 5;
+	printf("\n--------Press SW11: %2d ", delay);
+	while (delay--) {
+		for (i = 0; i < 100; i++) {
+			value = *pPORTFIO & PF4;
+			if (value != 0) {
+				break;
+			}
+			udelay(10000);
+		}
+		printf("\b\b\b%2d ", delay);
+	}
+	if (value != 0)
+		printf("\b\bOK");
+	else {
+		result = -1;
+		printf("\b\bfailed");
+	}
+
+	delay = 5;
+	printf("\n--------Press SW12: %2d ", delay);
+	while (delay--) {
+		for (i = 0; i < 100; i++) {
+			value = *pPORTFIO & PF3;
+			if (value != 0) {
+				break;
+			}
+			udelay(10000);
+		}
+		printf("\b\b\b%2d ", delay);
+	}
+	if (value != 0)
+		printf("\b\bOK");
+	else {
+		result = -1;
+		printf("\b\bfailed");
+	}
+
+	delay = 5;
+	printf("\n--------Press SW13: %2d ", delay);
+	while (delay--) {
+		for (i = 0; i < 100; i++) {
+			value = *pPORTFIO & PF2;
+			if (value != 0) {
+				break;
+			}
+			udelay(10000);
+		}
+		printf("\b\b\b%2d ", delay);
+	}
+	if (value != 0)
+		printf("\b\bOK");
+	else {
+		result = -1;
+		printf("\b\bfailed");
+	}
+	printf("\n");
+	return result;
+}
diff -Pur u-boot-2010.06-2010R1-RC2/board/pr1/post-memory.c u-boot-2010.06-2010R1-RC2-pr1/board/pr1/post-memory.c
--- u-boot-2010.06-2010R1-RC2/board/pr1/post-memory.c	1970-01-01 02:00:00.000000000 +0200
+++ u-boot-2010.06-2010R1-RC2-pr1/board/pr1/post-memory.c	2011-10-27 20:14:54.000000000 +0300
@@ -0,0 +1,318 @@
+#include <common.h>
+#include <asm/io.h>
+
+#include <post.h>
+#include <watchdog.h>
+
+#if CONFIG_POST & CONFIG_SYS_POST_MEMORY
+#define CLKIN 25000000
+#define PATTERN1 0x5A5A5A5A
+#define PATTERN2 0xAAAAAAAA
+
+#define CCLK_NUM	4
+#define SCLK_NUM	3
+
+void post_out_buff(char *buff);
+int post_key_pressed(void);
+void post_init_pll(int mult, int div);
+int post_init_sdram(int sclk);
+void post_init_uart(int sclk);
+
+const int pll[CCLK_NUM][SCLK_NUM][2] = {
+	{ {20, 4}, {20, 5}, {20, 10} },	/* CCLK = 500M */
+	{ {16, 4}, {16, 5}, {16, 8} },	/* CCLK = 400M */
+	{ {8, 2}, {8, 4}, {8, 5} },	/* CCLK = 200M */
+	{ {4, 1}, {4, 2}, {4, 4} }	/* CCLK = 100M */
+};
+const char *const log[CCLK_NUM][SCLK_NUM] = {
+	{"CCLK-500MHz SCLK-125MHz:    Writing...\0",
+	 "CCLK-500MHz SCLK-100MHz:    Writing...\0",
+	 "CCLK-500MHz SCLK- 50MHz:    Writing...\0",},
+	{"CCLK-400MHz SCLK-100MHz:    Writing...\0",
+	 "CCLK-400MHz SCLK- 80MHz:    Writing...\0",
+	 "CCLK-400MHz SCLK- 50MHz:    Writing...\0",},
+	{"CCLK-200MHz SCLK-100MHz:    Writing...\0",
+	 "CCLK-200MHz SCLK- 50MHz:    Writing...\0",
+	 "CCLK-200MHz SCLK- 40MHz:    Writing...\0",},
+	{"CCLK-100MHz SCLK-100MHz:    Writing...\0",
+	 "CCLK-100MHz SCLK- 50MHz:    Writing...\0",
+	 "CCLK-100MHz SCLK- 25MHz:    Writing...\0",},
+};
+
+int memory_post_test(int flags)
+{
+	int addr;
+	int m, n;
+	int sclk, sclk_temp;
+	int ret = 1;
+
+	sclk_temp = CLKIN / 1000000;
+	sclk_temp = sclk_temp * CONFIG_VCO_MULT;
+	for (sclk = 0; sclk_temp > 0; sclk++)
+		sclk_temp -= CONFIG_SCLK_DIV;
+	sclk = sclk * 1000000;
+	post_init_uart(sclk);
+	if (post_key_pressed() == 0)
+		return 0;
+
+	for (m = 0; m < CCLK_NUM; m++) {
+		for (n = 0; n < SCLK_NUM; n++) {
+			/* Calculate the sclk */
+			sclk_temp = CLKIN / 1000000;
+			sclk_temp = sclk_temp * pll[m][n][0];
+			for (sclk = 0; sclk_temp > 0; sclk++)
+				sclk_temp -= pll[m][n][1];
+			sclk = sclk * 1000000;
+
+			post_init_pll(pll[m][n][0], pll[m][n][1]);
+			post_init_sdram(sclk);
+			post_init_uart(sclk);
+			post_out_buff("\n\r\0");
+			post_out_buff(log[m][n]);
+			for (addr = 0x0; addr < CONFIG_SYS_MAX_RAM_SIZE; addr += 4)
+				*(unsigned long *)addr = PATTERN1;
+			post_out_buff("Reading...\0");
+			for (addr = 0x0; addr < CONFIG_SYS_MAX_RAM_SIZE; addr += 4) {
+				if ((*(unsigned long *)addr) != PATTERN1) {
+					post_out_buff("Error\n\r\0");
+					ret = 0;
+				}
+			}
+			post_out_buff("OK\n\r\0");
+		}
+	}
+	if (ret)
+		post_out_buff("memory POST passed\n\r\0");
+	else
+		post_out_buff("memory POST failed\n\r\0");
+
+	post_out_buff("\n\r\n\r\0");
+	return 1;
+}
+
+void post_init_uart(int sclk)
+{
+	int divisor;
+
+	for (divisor = 0; sclk > 0; divisor++)
+		sclk -= 57600 * 16;
+
+	*pPORTF_FER = 0x000F;
+	*pPORTH_FER = 0xFFFF;
+
+	*pUART_GCTL = 0x00;
+	*pUART_LCR = 0x83;
+	SSYNC();
+	*pUART_DLL = (divisor & 0xFF);
+	SSYNC();
+	*pUART_DLH = ((divisor >> 8) & 0xFF);
+	SSYNC();
+	*pUART_LCR = 0x03;
+	SSYNC();
+	*pUART_GCTL = 0x01;
+	SSYNC();
+}
+
+void post_out_buff(char *buff)
+{
+
+	int i = 0;
+	for (i = 0; i < 0x80000; i++)
+		;
+	i = 0;
+	while ((buff[i] != '\0') && (i != 100)) {
+		while (!(*pUART_LSR & 0x20)) ;
+		*pUART_THR = buff[i];
+		SSYNC();
+		i++;
+	}
+	for (i = 0; i < 0x80000; i++)
+		;
+}
+
+/* Using sw10-PF5 as the hotkey */
+#define KEY_LOOP 0x80000
+#define KEY_DELAY 0x80
+int post_key_pressed(void)
+{
+	int i, n;
+	unsigned short value;
+
+	*pPORTF_FER &= ~PF5;
+	*pPORTFIO_DIR &= ~PF5;
+	*pPORTFIO_INEN |= PF5;
+	SSYNC();
+
+	post_out_buff("########Press SW10 to enter Memory POST########: 3\0");
+	for (i = 0; i < KEY_LOOP; i++) {
+		value = *pPORTFIO & PF5;
+		if (*pUART0_RBR == 0x0D) {
+			value = 0;
+			goto key_pressed;
+		}
+		if (value != 0)
+			goto key_pressed;
+		for (n = 0; n < KEY_DELAY; n++)
+			asm("nop");
+	}
+	post_out_buff("\b2\0");
+
+	for (i = 0; i < KEY_LOOP; i++) {
+		value = *pPORTFIO & PF5;
+		if (*pUART0_RBR == 0x0D) {
+			value = 0;
+			goto key_pressed;
+		}
+		if (value != 0)
+			goto key_pressed;
+		for (n = 0; n < KEY_DELAY; n++)
+			asm("nop");
+	}
+	post_out_buff("\b1\0");
+
+	for (i = 0; i < KEY_LOOP; i++) {
+		value = *pPORTFIO & PF5;
+		if (*pUART0_RBR == 0x0D) {
+			value = 0;
+			goto key_pressed;
+		}
+		if (value != 0)
+			goto key_pressed;
+		for (n = 0; n < KEY_DELAY; n++)
+			asm("nop");
+	}
+      key_pressed:
+	post_out_buff("\b0");
+	post_out_buff("\n\r\0");
+	if (value == 0)
+		return 0;
+	post_out_buff("Hotkey has been pressed, Enter POST . . . . . .\n\r\0");
+	return 1;
+}
+
+void post_init_pll(int mult, int div)
+{
+
+	*pSIC_IWR = 0x01;
+	*pPLL_CTL = (mult << 9);
+	*pPLL_DIV = div;
+	asm("CLI R2;");
+	asm("IDLE;");
+	asm("STI R2;");
+	while (!(*pPLL_STAT & 0x20)) ;
+}
+
+int post_init_sdram(int sclk)
+{
+	int SDRAM_tRP, SDRAM_tRP_num, SDRAM_tRAS, SDRAM_tRAS_num, SDRAM_tRCD,
+	    SDRAM_tWR;
+	int SDRAM_Tref, SDRAM_NRA, SDRAM_CL, SDRAM_SIZE, SDRAM_WIDTH,
+	    mem_SDGCTL, mem_SDBCTL, mem_SDRRC;
+
+	if ((sclk > 119402985)) {
+		SDRAM_tRP = TRP_2;
+		SDRAM_tRP_num = 2;
+		SDRAM_tRAS = TRAS_7;
+		SDRAM_tRAS_num = 7;
+		SDRAM_tRCD = TRCD_2;
+		SDRAM_tWR = TWR_2;
+	} else if ((sclk > 104477612) && (sclk <= 119402985)) {
+		SDRAM_tRP = TRP_2;
+		SDRAM_tRP_num = 2;
+		SDRAM_tRAS = TRAS_6;
+		SDRAM_tRAS_num = 6;
+		SDRAM_tRCD = TRCD_2;
+		SDRAM_tWR = TWR_2;
+	} else if ((sclk > 89552239) && (sclk <= 104477612)) {
+		SDRAM_tRP = TRP_2;
+		SDRAM_tRP_num = 2;
+		SDRAM_tRAS = TRAS_5;
+		SDRAM_tRAS_num = 5;
+		SDRAM_tRCD = TRCD_2;
+		SDRAM_tWR = TWR_2;
+	} else if ((sclk > 74626866) && (sclk <= 89552239)) {
+		SDRAM_tRP = TRP_2;
+		SDRAM_tRP_num = 2;
+		SDRAM_tRAS = TRAS_4;
+		SDRAM_tRAS_num = 4;
+		SDRAM_tRCD = TRCD_2;
+		SDRAM_tWR = TWR_2;
+	} else if ((sclk > 66666667) && (sclk <= 74626866)) {
+		SDRAM_tRP = TRP_2;
+		SDRAM_tRP_num = 2;
+		SDRAM_tRAS = TRAS_3;
+		SDRAM_tRAS_num = 3;
+		SDRAM_tRCD = TRCD_2;
+		SDRAM_tWR = TWR_2;
+	} else if ((sclk > 59701493) && (sclk <= 66666667)) {
+		SDRAM_tRP = TRP_1;
+		SDRAM_tRP_num = 1;
+		SDRAM_tRAS = TRAS_4;
+		SDRAM_tRAS_num = 4;
+		SDRAM_tRCD = TRCD_1;
+		SDRAM_tWR = TWR_2;
+	} else if ((sclk > 44776119) && (sclk <= 59701493)) {
+		SDRAM_tRP = TRP_1;
+		SDRAM_tRP_num = 1;
+		SDRAM_tRAS = TRAS_3;
+		SDRAM_tRAS_num = 3;
+		SDRAM_tRCD = TRCD_1;
+		SDRAM_tWR = TWR_2;
+	} else if ((sclk > 29850746) && (sclk <= 44776119)) {
+		SDRAM_tRP = TRP_1;
+		SDRAM_tRP_num = 1;
+		SDRAM_tRAS = TRAS_2;
+		SDRAM_tRAS_num = 2;
+		SDRAM_tRCD = TRCD_1;
+		SDRAM_tWR = TWR_2;
+	} else if (sclk <= 29850746) {
+		SDRAM_tRP = TRP_1;
+		SDRAM_tRP_num = 1;
+		SDRAM_tRAS = TRAS_1;
+		SDRAM_tRAS_num = 1;
+		SDRAM_tRCD = TRCD_1;
+		SDRAM_tWR = TWR_2;
+	} else {
+		SDRAM_tRP = TRP_1;
+		SDRAM_tRP_num = 1;
+		SDRAM_tRAS = TRAS_1;
+		SDRAM_tRAS_num = 1;
+		SDRAM_tRCD = TRCD_1;
+		SDRAM_tWR = TWR_2;
+	}
+	/*SDRAM INFORMATION: */
+	SDRAM_Tref = 64;	/* Refresh period in milliseconds */
+	SDRAM_NRA = 4096;	/* Number of row addresses in SDRAM */
+	SDRAM_CL = CL_3;	/* 2 */
+
+	SDRAM_SIZE = EBSZ_64;
+	SDRAM_WIDTH = EBCAW_10;
+
+	mem_SDBCTL = SDRAM_WIDTH | SDRAM_SIZE | EBE;
+
+	/* Equation from section 17 (p17-46) of BF533 HRM */
+	mem_SDRRC =
+	    (((CONFIG_SCLK_HZ / 1000) * SDRAM_Tref) / SDRAM_NRA) -
+	    (SDRAM_tRAS_num + SDRAM_tRP_num);
+
+	/* Enable SCLK Out */
+	mem_SDGCTL =
+	    (SCTLE | SDRAM_CL | SDRAM_tRAS | SDRAM_tRP | SDRAM_tRCD | SDRAM_tWR
+	     | PSS);
+
+	SSYNC();
+
+	*pEBIU_SDGCTL |= 0x1000000;
+	/* Set the SDRAM Refresh Rate control register based on SSCLK value */
+	*pEBIU_SDRRC = mem_SDRRC;
+
+	/* SDRAM Memory Bank Control Register */
+	*pEBIU_SDBCTL = mem_SDBCTL;
+
+	/* SDRAM Memory Global Control Register */
+	*pEBIU_SDGCTL = mem_SDGCTL;
+	SSYNC();
+	return mem_SDRRC;
+}
+
+#endif				/* CONFIG_POST & CONFIG_SYS_POST_MEMORY */
diff -Pur u-boot-2010.06-2010R1-RC2/board/pr1/pr1.c u-boot-2010.06-2010R1-RC2-pr1/board/pr1/pr1.c
--- u-boot-2010.06-2010R1-RC2/board/pr1/pr1.c	1970-01-01 02:00:00.000000000 +0200
+++ u-boot-2010.06-2010R1-RC2-pr1/board/pr1/pr1.c	2011-10-27 20:14:54.000000000 +0300
@@ -0,0 +1,82 @@
+/*
+ * U-boot - main board file
+ *
+ * Copyright (c) 2005-2008 Analog Devices Inc.
+ *
+ * (C) Copyright 2000-2004
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+ * MA 02110-1301 USA
+ */
+
+#include <common.h>
+#include <config.h>
+#include <command.h>
+#include <asm/blackfin.h>
+#include <asm/net.h>
+#include <net.h>
+#include <asm/mach-common/bits/bootrom.h>
+#include <netdev.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+int checkboard(void)
+{
+	printf("Board: Switchvoice PR1 Appliance\n");
+	printf("       Support: http://www.switchvoice.com\n");
+	return 0;
+}
+
+void board_reset(void)
+{
+	/* workaround for weak pull ups on ssel */
+	if (CONFIG_BFIN_BOOT_MODE == BFIN_BOOT_SPI_MASTER)
+		bfin_reset_boot_spi_cs(GPIO_PF10);
+}
+
+#ifdef CONFIG_BFIN_MAC
+static void board_init_enetaddr(uchar *mac_addr)
+{
+	bool valid_mac = false;
+
+	if (!valid_mac) {
+		puts("Warning: Generating 'random' MAC address\n");
+		bfin_gen_rand_mac(mac_addr);
+	}
+
+	eth_setenv_enetaddr("ethaddr", mac_addr);
+}
+
+int board_eth_init(bd_t *bis)
+{
+	return bfin_EMAC_initialize(bis);
+}
+#endif
+
+/* miscellaneous platform dependent initialisations */
+int misc_init_r(void)
+{
+#ifdef CONFIG_BFIN_MAC
+	uchar enetaddr[6];
+	if (!eth_getenv_enetaddr("ethaddr", enetaddr))
+		board_init_enetaddr(enetaddr);
+#endif
+
+	return 0;
+}
diff -Pur u-boot-2010.06-2010R1-RC2/include/configs/bfin_adi_common.h u-boot-2010.06-2010R1-RC2-pr1/include/configs/bfin_adi_common.h
--- u-boot-2010.06-2010R1-RC2/include/configs/bfin_adi_common.h	2010-09-29 23:24:16.000000000 +0300
+++ u-boot-2010.06-2010R1-RC2-pr1/include/configs/bfin_adi_common.h	2011-10-27 20:15:56.000000000 +0300
@@ -151,7 +151,7 @@
 # define NAND_ENV_SETTINGS \
 	"nandargs=set bootargs " CONFIG_BOOTARGS "\0" \
 	"nandboot=" \
-		"nand read $(loadaddr) 0x20000 0x100000;" \
+		"nand read $(loadaddr) 0 0x900000;" \
 		"run nandargs;" \
 		"bootm" \
 		"\0"
@@ -243,10 +243,10 @@
  * Network Settings
  */
 #ifdef CONFIG_CMD_NET
-# define CONFIG_IPADDR		192.168.0.15
+# define CONFIG_IPADDR		192.168.1.100
 # define CONFIG_NETMASK		255.255.255.0
-# define CONFIG_GATEWAYIP	192.168.0.1
-# define CONFIG_SERVERIP	192.168.0.2
+# define CONFIG_GATEWAYIP	192.168.1.1
+# define CONFIG_SERVERIP	192.168.1.2
 # define CONFIG_ROOTPATH	/romfs
 # ifdef CONFIG_CMD_DHCP
 #  ifndef CONFIG_SYS_AUTOLOAD
diff -Pur u-boot-2010.06-2010R1-RC2/include/configs/pr1.h u-boot-2010.06-2010R1-RC2-pr1/include/configs/pr1.h
--- u-boot-2010.06-2010R1-RC2/include/configs/pr1.h	1970-01-01 02:00:00.000000000 +0200
+++ u-boot-2010.06-2010R1-RC2-pr1/include/configs/pr1.h	2011-10-27 21:01:06.000000000 +0300
@@ -0,0 +1,275 @@
+/*
+ * U-boot - Configuration file for BF537 STAMP board
+ */
+
+#ifndef __CONFIG_PR1_H__
+#define __CONFIG_Pr1_H__
+
+#include <asm/config-pre.h>
+
+
+
+/*
+ * Debuging
+ *
+
+define CONFIG_DEBUG_EARLY_SERIAL 1
+//define DEBUG 1
+//define CONFIG_DEBUG_DUMP_SYMS 1
+*/
+
+
+/*
+ * TFTP block size
+ */
+#define CONFIG_TFTP_BLOCKSIZE   4096
+
+
+/*
+ * u-boot prompt
+ */
+#define CONFIG_SYS_PROMPT       "pr1>"
+
+/*
+ * 2 sec countdown before the autoboot
+ */
+#define CONFIG_BOOTDELAY	2
+
+/*
+ * defines the auto boot countdown
+ */
+
+
+/*
+ * define bootcmd
+ */
+#define CONFIG_BOOTCOMMAND  "run nandboot"
+
+
+/*
+ * Define the console baudrate
+ */
+#define CONFIG_BAUDRATE          115200
+
+/*
+ * Processor Settings
+ */
+#define CONFIG_BFIN_CPU             bf537-0.3
+#define CONFIG_BFIN_BOOT_MODE       BFIN_BOOT_SPI_MASTER
+
+
+/*
+ * Clock Settings
+ *	CCLK = (CLKIN * VCO_MULT) / CCLK_DIV
+ *	SCLK = (CLKIN * VCO_MULT) / SCLK_DIV
+ */
+/* CONFIG_CLKIN_HZ is any value in Hz					*/
+#define CONFIG_CLKIN_HZ			25000000
+/* CLKIN_HALF controls the DF bit in PLL_CTL      0 = CLKIN		*/
+/*                                                1 = CLKIN / 2		*/
+#define CONFIG_CLKIN_HALF		0
+/* PLL_BYPASS controls the BYPASS bit in PLL_CTL  0 = do not bypass	*/
+/*                                                1 = bypass PLL	*/
+#define CONFIG_PLL_BYPASS		0
+/* VCO_MULT controls the MSEL (multiplier) bits in PLL_CTL		*/
+/* Values can range from 0-63 (where 0 means 64)			*/
+#define CONFIG_VCO_MULT			24
+/* CCLK_DIV controls the core clock divider				*/
+/* Values can be 1, 2, 4, or 8 ONLY					*/
+#define CONFIG_CCLK_DIV			1
+/* SCLK_DIV controls the system clock divider				*/
+/* Values can range from 1-15						*/
+#define CONFIG_SCLK_DIV			5
+
+
+/*
+ * Memory Settings ========================================
+ */
+#define CONFIG_MEM_ADD_WDTH	11 
+#define CONFIG_MEM_SIZE		128
+
+#define CONFIG_EBIU_SDRRC_VAL	0x306 	   /*0x0306*/
+#define CONFIG_EBIU_SDGCTL_VAL	0x8091998d /*0x91114d*/
+
+#define CONFIG_EBIU_AMGCTL_VAL	0xFF
+#define CONFIG_EBIU_AMBCTL0_VAL	0x7BB07BB0
+#define CONFIG_EBIU_AMBCTL1_VAL	0xFFC27BB0
+
+#define CONFIG_SYS_MONITOR_LEN		(512 * 1024)
+#define CONFIG_SYS_MALLOC_LEN		(384 * 1024)
+/*
+ * up to 128 MB System memory
+ */
+#define CONFIG_SYS_MAX_RAM_SIZE 0x8000000 
+/*
+ * up to 64 MB uImage size
+ */
+#define CONFIG_SYS_BOOTM_LEN    0x4000000
+/*
+ * Initial Memory map for Linux
+ */
+#define CONFIG_SYS_BOOTMAPSZ    (8 << 20) 
+
+/*
+ * Sets the uboot variable loadaddr
+ */
+#define CONFIG_LOADADDR		0x2000000
+
+
+/*
+ * Network Settings
+ */
+#ifndef __ADSPBF534__
+#define ADI_CMDS_NETWORK	1
+#define CONFIG_BFIN_MAC
+#define CONFIG_NETCONSOLE	1
+#define CONFIG_NET_MULTI	1
+#endif
+#define CONFIG_HOSTNAME		pr1
+/* Uncomment next line to use fixed MAC address */
+/* #define CONFIG_ETHADDR	02:80:ad:20:31:e8 */
+
+
+/*
+ * Flash Settings
+ */
+#define CONFIG_ENV_OVERWRITE    1
+#define CONFIG_SYS_NO_FLASH             /* we have only NAND */
+
+/*
+ * SPI Settings
+ */
+#define CONFIG_BFIN_SPI
+#define CONFIG_ENV_SPI_MAX_HZ	30000000
+#define CONFIG_SF_DEFAULT_SPEED	30000000
+#define CONFIG_SPI_FLASH
+#define CONFIG_SPI_FLASH_ATMEL
+#define CONFIG_SPI_FLASH_SPANSION
+#define CONFIG_SPI_FLASH_STMICRO
+#define CONFIG_SPI_FLASH_WINBOND
+
+
+/*
+ * Env Storage Settings
+ */
+#if (CONFIG_BFIN_BOOT_MODE == BFIN_BOOT_SPI_MASTER)
+#define CONFIG_ENV_IS_IN_SPI_FLASH
+#define CONFIG_PREBOOT          "echo starting from spi flash"
+#define CONFIG_ENV_OFFSET	0x30000
+#define CONFIG_ENV_SIZE		0x10000
+#define CONFIG_ENV_SECT_SIZE	0x10000
+#else
+#define CONFIG_ENV_IS_IN_FLASH
+#define CONFIG_ENV_OFFSET	0x4000
+#define CONFIG_ENV_ADDR		(CONFIG_SYS_FLASH_BASE + CONFIG_ENV_OFFSET)
+#define CONFIG_ENV_SIZE		0x2000
+#define CONFIG_ENV_SECT_SIZE	0x2000
+#endif
+
+/*
+#if (CONFIG_BFIN_BOOT_MODE == BFIN_BOOT_BYPASS)
+#define ENV_IS_EMBEDDED
+#else
+#define CONFIG_ENV_IS_EMBEDDED_IN_LDR
+#endif
+#ifdef ENV_IS_EMBEDDED
+*/
+/* WARNING - the following is hand-optimized to fit within
+ * the sector before the environment sector. If it throws
+ * an error during compilation remove an object here to get
+ * it linked after the configuration sector.
+ */
+/*
+# define LDS_BOARD_TEXT \
+	arch/blackfin/cpu/traps.o		(.text .text.*); \
+	arch/blackfin/cpu/interrupt.o	(.text .text.*); \
+	arch/blackfin/cpu/serial.o		(.text .text.*); \
+	common/dlmalloc.o		(.text .text.*); \
+	lib/crc32.o		(.text .text.*); \
+	. = DEFINED(env_offset) ? env_offset : .; \
+	common/env_embedded.o		(.text .text.*);
+#endif
+*/
+
+/*
+ * I2C Settings
+ */
+#define CONFIG_BFIN_TWI_I2C	1
+#define CONFIG_HARD_I2C		1
+
+
+/*
+ * SPI_MMC Settings
+ */
+#define CONFIG_MMC
+#define CONFIG_SPI_MMC
+
+
+/*
+ * NAND Settings
+ */
+
+#define CONFIG_NAND_PLAT
+#define CONFIG_SYS_NAND_BASE		0x20000000
+#define CONFIG_SYS_MAX_NAND_DEVICE	1
+
+#define BFIN_NAND_CLE(chip) ((unsigned long)(chip)->IO_ADDR_W | (1 << 2))
+#define BFIN_NAND_ALE(chip) ((unsigned long)(chip)->IO_ADDR_W | (1 << 1))
+#define BFIN_NAND_WRITE(addr, cmd) \
+	do { \
+		bfin_write8(addr, cmd); \
+		SSYNC(); \
+	} while (0)
+
+#define NAND_PLAT_WRITE_CMD(chip, cmd) BFIN_NAND_WRITE(BFIN_NAND_CLE(chip), cmd)
+#define NAND_PLAT_WRITE_ADR(chip, cmd) BFIN_NAND_WRITE(BFIN_NAND_ALE(chip), cmd)
+#define NAND_PLAT_GPIO_DEV_READY       GPIO_PF9
+
+
+/*
+ * CF-CARD IDE-HDD Support
+ */
+
+/*
+ * Add CF flash card support in TRUE-IDE Mode (CF-IDE-NAND Card)
+ * Strange address mapping Blackfin A13 connects to CF_A0
+ */
+
+/* #define CONFIG_BFIN_TRUE_IDE */
+
+/*
+ * Add CF flash card support in Common Memory Mode (CF-IDE-NAND Card)
+ * This should be the preferred mode
+ */
+
+
+/*
+ * Misc Settings
+ */
+#define CONFIG_MISC_INIT_R
+#define CONFIG_RTC_BFIN
+#define CONFIG_UART_CONSOLE	0
+
+/* Define if want to do post memory test */
+#undef CONFIG_POST
+#ifdef CONFIG_POST
+#define FLASH_START_POST_BLOCK	11	/* Should > = 11 */
+#define FLASH_END_POST_BLOCK	71	/* Should < = 71 */
+#endif
+
+/* These are for board tests */
+#if 0
+#define CONFIG_BOOTCOMMAND       "bootldr 0x203f0100"
+#define CONFIG_AUTOBOOT_KEYED
+#define CONFIG_AUTOBOOT_PROMPT \
+	"autoboot in %d seconds: press space to stop\n", bootdelay
+#define CONFIG_AUTOBOOT_STOP_STR " "
+#endif
+
+
+/*
+ * Pull in common ADI header for remaining command/environment setup
+ */
+#include <configs/bfin_adi_common.h>
+
+#endif
diff -Pur u-boot-2010.06-2010R1-RC2/Makefile u-boot-2010.06-2010R1-RC2-pr1/Makefile
--- u-boot-2010.06-2010R1-RC2/Makefile	2010-09-16 09:56:14.000000000 +0300
+++ u-boot-2010.06-2010R1-RC2-pr1/Makefile	2011-10-27 20:16:14.000000000 +0300
@@ -3533,7 +3533,7 @@
 	tcm-bf518 tcm-bf537
 
 # Misc third party boards
-BFIN_BOARDS += bf537-minotaur bf537-srv1 bf561-acvilon blackstamp ip04
+BFIN_BOARDS += bf537-minotaur bf537-srv1 bf561-acvilon blackstamp ip04 pr1
 
 # I-SYST Micromodule
 BFIN_BOARDS += ibf-dsp561
