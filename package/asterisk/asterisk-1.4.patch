diff -ur asterisk/apps/app_dial.c asterisk.patched/apps/app_dial.c
--- asterisk/apps/app_dial.c	2010-11-24 18:48:39.000000000 +0200
+++ asterisk.patched/apps/app_dial.c	2011-02-04 11:41:59.000000000 +0200
@@ -214,7 +214,11 @@
 "           of features.conf.\n"
 "    W    - Allow the calling party to enable recording of the call by sending\n"
 "           the DTMF sequence defined in the automon setting in the featuremap section\n"
-"           of features.conf.\n";
+"           of features.conf.\n"
+"    x    - Allow the called party to enable recording of the call by sending\n"
+"           the DTMF sequence defined for one-touch automixmonitor in features.conf\n"
+"    X    - Allow the calling party to enable recording of the call by sending\n"
+"           the DTMF sequence defined for one-touch automixmonitor in features.conf\n";
 
 /* RetryDial App by Anthony Minessale II <anthmct@yahoo.com> Jan/2005 */
 static char *rapp = "RetryDial";
@@ -261,6 +265,9 @@
 	OPT_CALLEE_PARK =	(1 << 25),
 	OPT_CALLER_PARK =	(1 << 26),
 	OPT_IGNORE_FORWARDING = (1 << 27),
+	OPT_CALLEE_MIXMONITOR = (1 << 28),
+	OPT_CALLER_MIXMONITOR = (1 << 29),
+   
 } dial_exec_option_flags;
 
 #define DIAL_STILLGOING			(1 << 30)
@@ -310,11 +317,14 @@
 	AST_APP_OPTION('T', OPT_CALLER_TRANSFER),
 	AST_APP_OPTION('w', OPT_CALLEE_MONITOR),
 	AST_APP_OPTION('W', OPT_CALLER_MONITOR),
+	AST_APP_OPTION('x', OPT_CALLEE_MIXMONITOR),
+	AST_APP_OPTION('X', OPT_CALLER_MIXMONITOR),
 });
 
 #define CAN_EARLY_BRIDGE(flags,chan,peer) (!ast_test_flag(flags, OPT_CALLEE_HANGUP | \
 	OPT_CALLER_HANGUP | OPT_CALLEE_TRANSFER | OPT_CALLER_TRANSFER | \
 	OPT_CALLEE_MONITOR | OPT_CALLER_MONITOR | OPT_CALLEE_PARK |  \
+        OPT_CALLER_MIXMONITOR | OPT_CALLEE_MIXMONITOR | \
 	OPT_CALLER_PARK | OPT_ANNOUNCE | OPT_CALLEE_MACRO) && \
 	!chan->audiohooks && !peer->audiohooks)
 
@@ -498,6 +508,7 @@
 						       OPT_CALLEE_TRANSFER | OPT_CALLER_TRANSFER |
 						       OPT_CALLEE_HANGUP | OPT_CALLER_HANGUP |
 						       OPT_CALLEE_MONITOR | OPT_CALLER_MONITOR |
+						       OPT_CALLEE_MIXMONITOR | OPT_CALLER_MIXMONITOR |
 						       OPT_CALLEE_PARK | OPT_CALLER_PARK |
 						       DIAL_NOFORWARDHTML);
 					ast_copy_string(c->dialcontext, "", sizeof(c->dialcontext));
@@ -629,6 +640,7 @@
 							       OPT_CALLEE_HANGUP | OPT_CALLER_HANGUP |
 							       OPT_CALLEE_MONITOR | OPT_CALLER_MONITOR |
 							       OPT_CALLEE_PARK | OPT_CALLER_PARK |
+							       OPT_CALLEE_MIXMONITOR | OPT_CALLER_MIXMONITOR |
 							       DIAL_NOFORWARDHTML);
 						ast_copy_string(c->dialcontext, "", sizeof(c->dialcontext));
 						ast_copy_string(c->exten, "", sizeof(c->exten));
@@ -1236,6 +1248,7 @@
 				       OPT_CALLEE_HANGUP | OPT_CALLER_HANGUP |
 				       OPT_CALLEE_MONITOR | OPT_CALLER_MONITOR |
 				       OPT_CALLEE_PARK | OPT_CALLER_PARK |
+				       OPT_CALLEE_MIXMONITOR | OPT_CALLER_MIXMONITOR |
 				       OPT_RINGBACK | OPT_MUSICBACK | OPT_FORCECLID);
 			ast_set2_flag(tmp, args.url, DIAL_NOFORWARDHTML);	
 		}
@@ -1842,6 +1855,10 @@
 				ast_set_flag(&(config.features_callee), AST_FEATURE_AUTOMON);
 			if (ast_test_flag(peerflags, OPT_CALLER_MONITOR)) 
 				ast_set_flag(&(config.features_caller), AST_FEATURE_AUTOMON);
+			if (ast_test_flag(peerflags, OPT_CALLEE_MIXMONITOR))
+				ast_set_flag(&(config.features_callee), AST_FEATURE_AUTOMIXMON);
+			if (ast_test_flag(peerflags, OPT_CALLER_MIXMONITOR)) 
+				ast_set_flag(&(config.features_caller), AST_FEATURE_AUTOMIXMON);
 			if (ast_test_flag(peerflags, OPT_CALLEE_PARK))
 				ast_set_flag(&(config.features_callee), AST_FEATURE_PARKCALL);
 			if (ast_test_flag(peerflags, OPT_CALLER_PARK))
diff -ur asterisk/apps/app_directory.c asterisk.patched/apps/app_directory.c
--- asterisk/apps/app_directory.c	2010-05-18 21:54:58.000000000 +0300
+++ asterisk.patched/apps/app_directory.c	2011-02-04 11:42:20.000000000 +0200
@@ -179,7 +179,7 @@
 					break;
 				}
 				if (fd > -1)
-					fdm = mmap(NULL, fdlen, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+					fdm = mmap(NULL, fdlen, PROT_READ | PROT_WRITE, MAP_PRIVATE , fd, 0);
 			}
 			if (fdm != MAP_FAILED) {
 				memset(fdm, 0, fdlen);
diff -ur asterisk/apps/app_voicemail.c asterisk.patched/apps/app_voicemail.c
--- asterisk/apps/app_voicemail.c	2010-12-01 02:23:19.000000000 +0200
+++ asterisk.patched/apps/app_voicemail.c	2011-02-04 11:43:08.000000000 +0200
@@ -2496,7 +2496,7 @@
 					}
 					/* Read out in small chunks */
 					for (offset = 0; offset < colsize2; offset += CHUNKSIZE) {
-						if ((fdm = mmap(NULL, CHUNKSIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, offset)) == MAP_FAILED) {
+						if ((fdm = mmap(NULL, CHUNKSIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, offset)) == MAP_FAILED) {
 							ast_log(LOG_WARNING, "Could not mmap the output file: %s (%d)\n", strerror(errno), errno);
 							SQLFreeHandle(SQL_HANDLE_STMT, stmt);
 							ast_odbc_release_obj(obj);
@@ -2814,7 +2814,7 @@
 		fdlen = lseek(fd, 0, SEEK_END);
 		lseek(fd, 0, SEEK_SET);
 		printf("Length is %zd\n", fdlen);
-		fdm = mmap(NULL, fdlen, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+		fdm = mmap(NULL, fdlen, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);
 		if (fdm == MAP_FAILED) {
 			ast_log(LOG_WARNING, "Memory map failed!\n");
 			ast_odbc_release_obj(obj);
diff -ur asterisk/channels/chan_dahdi.c asterisk.patched/channels/chan_dahdi.c
--- asterisk/channels/chan_dahdi.c	2010-11-25 00:41:07.000000000 +0200
+++ asterisk.patched/channels/chan_dahdi.c	2011-02-04 11:49:51.000000000 +0200
@@ -116,6 +116,8 @@
 };
 static struct ast_jb_conf global_jbconf;
 
+extern unsigned int cycles(void);
+
 #ifndef DAHDI_TONEDETECT
 /* Work around older code with no tone detect */
 #define DAHDI_EVENT_DTMFDOWN 0
@@ -895,6 +897,10 @@
 	int polarity;
 	/*! \brief DSP feature flags: DSP_FEATURE_xxx */
 	int dsp_features;
+	/*! \brief DR: stats for DSP execution */
+	int dsp_cycles_last;     
+	int dsp_cycles_worst;
+	int dsp_cycles_average;
 	/*! \brief DTMF digit in progress.  0 when no digit in progress. */
 	char begindigit;
 } *iflist = NULL, *ifend = NULL;
@@ -5361,6 +5367,7 @@
 	int index;
 	void *readbuf;
 	struct ast_frame *f;
+	int before;
 
 	while (ast_mutex_trylock(&p->lock)) {
 		DEADLOCK_AVOIDANCE(&ast->lock);
@@ -5618,7 +5625,16 @@
 	}
 	if (p->dsp && (!p->ignoredtmf || p->callwaitcas || p->busydetect  || p->callprogress) && !index) {
 		/* Perform busy detection. etc on the dahdi line */
+		/* DR: measure some execution stats around this as it is a
+		computationally intensive part of the real time code */
+		before = cycles();
 		f = ast_dsp_process(ast, p->dsp, &p->subs[index].f);
+		p->dsp_cycles_last = cycles() - before;
+		if (p->dsp_cycles_last > p->dsp_cycles_worst) {
+			p->dsp_cycles_worst = p->dsp_cycles_last;
+		}
+		p->dsp_cycles_average = (int)(0.1*(float)p->dsp_cycles_last +
+					      0.9*(float)p->dsp_cycles_average);
 		if (f) {
 			if ((f->frametype == AST_FRAME_CONTROL) && (f->subclass == AST_CONTROL_BUSY)) {
 				if ((ast->_state == AST_STATE_UP) && !p->outgoing) {
@@ -9581,6 +9597,9 @@
 								pri->pvts[x]->owner->_softhangup |= AST_SOFTHANGUP_DEV;
 							ast_mutex_unlock(&pri->pvts[x]->lock);
 						}
+						pri->pvts[x]->dsp_cycles_last = 0;
+						pri->pvts[x]->dsp_cycles_worst = 0;
+						pri->pvts[x]->dsp_cycles_average = 0;				
 				}
 				break;
 			case PRI_EVENT_KEYPAD_DIGIT:
@@ -10974,6 +10993,7 @@
 	return RESULT_SUCCESS;
 }
 
+extern int dsp_sample;
 static int dahdi_show_channels(int fd, int argc, char **argv)
 {
 #define FORMAT "%7s %-10.10s %-15.15s %-10.10s %-20.20s\n"
@@ -11114,6 +11134,8 @@
 			ast_cli(fd, "Fax Handled: %s\n", tmp->faxhandled ? "yes" : "no");
 			ast_cli(fd, "Pulse phone: %s\n", tmp->pulsedial ? "yes" : "no");
 			ast_cli(fd, "Echo Cancellation: %d taps%s, currently %s\n", tmp->echocancel, tmp->echocanbridged ? "" : " unless TDM bridged", tmp->echocanon ? "ON" : "OFF");
+			ast_cli(fd, "DSP cycles last: %d worst: %d average: %d sample: %d\n",
+				tmp->dsp_cycles_last, tmp->dsp_cycles_worst, tmp->dsp_cycles_average, dsp_sample);			
 			if (tmp->master)
 				ast_cli(fd, "Master Channel: %d\n", tmp->master->channel);
 			for (x = 0; x < MAX_SLAVES; x++) {
diff -ur asterisk/channels/misdn/isdn_lib.c asterisk.patched/channels/misdn/isdn_lib.c
--- asterisk/channels/misdn/isdn_lib.c	2009-10-02 02:18:28.000000000 +0300
+++ asterisk.patched/channels/misdn/isdn_lib.c	2011-02-04 11:45:22.000000000 +0200
@@ -293,7 +293,13 @@
 	}
 }
 
+#define ISDN_LIB_DO_NOT_FLIP_BITS
+#ifdef ISDN_LIB_DO_NOT_FLIP_BITS
 
+#define init_flip_bits(x) 	do { /* NOP */ } while(0)
+#define flip_buf_bits(a,b) 	do { /* NOP */ } while(0)
+
+#else
 static char flip_table[256];
 
 static void init_flip_bits(void)
@@ -320,7 +326,7 @@
 	
 	return start;
 }
-
+#endif /* #ifdef ISDN_LIB_DO_NOT_FLIP_BITS */
 
 
 
@@ -1035,7 +1041,7 @@
 		li.st = bc->b_stid; /*  given idx */
 
 
-#define MISDN_DSP
+#undef MISDN_DSP
 #ifndef MISDN_DSP
 		bc->nodsp=1;
 #endif
@@ -4542,7 +4548,7 @@
 	int ec_arr[2];
 
 	if (bc->ec_enable) {
-		cb_log(3, stack?stack->port:0,"Sending Control ECHOCAN_ON taps:%d\n",bc->ec_deftaps);
+		cb_log(3, stack?stack->port:0,"Sending Control HW_ECHOCAN_ON taps:%d\n",bc->ec_deftaps);
 	
 		switch (bc->ec_deftaps) {
 		case 4:
@@ -4564,7 +4570,7 @@
 		ec_arr[0]=bc->ec_deftaps;
 		ec_arr[1]=0;
 		
-		manager_ph_control_block(bc,  ECHOCAN_ON,  ec_arr, sizeof(ec_arr));
+		manager_ph_control_block(bc,  HW_ECHOCAN_ON,  ec_arr, sizeof(ec_arr));
 	}
 #endif
 	}
@@ -4587,8 +4593,8 @@
 	manager_ph_control_block(bc, PIPELINE_CFG, "", 0);
 #else
 	if ( ! bc->ec_enable) {
-		cb_log(3, stack?stack->port:0, "Sending Control ECHOCAN_OFF\n");
-		manager_ph_control(bc,  ECHOCAN_OFF, 0);
+		cb_log(3, stack?stack->port:0, "Sending Control HW_ECHOCAN_OFF\n");
+		manager_ph_control(bc,  HW_ECHOCAN_OFF, 0);
 	}
 #endif
 }
diff -ur asterisk/codecs/Makefile asterisk.patched/codecs/Makefile
--- asterisk/codecs/Makefile	2009-07-21 16:04:44.000000000 +0300
+++ asterisk.patched/codecs/Makefile	2011-02-04 11:58:54.000000000 +0200
@@ -45,6 +45,7 @@
 	$(MAKE) -C gsm clean
 	$(MAKE) -C lpc10 clean
 	$(MAKE) -C ilbc clean
+	$(MAKE) -C g722 clean
 
 gsm/lib/libgsm.a:
 	@mkdir -p gsm/lib
@@ -59,3 +60,13 @@
 	@$(MAKE) -C ilbc all _ASTCFLAGS="$(filter-out -Wmissing-prototypes -Wmissing-declarations,$(_ASTCFLAGS)) $(AST_NO_STRICT_OVERFLOW)"
 
 $(if $(filter codec_ilbc,$(EMBEDDED_MODS)),modules.link,codec_ilbc.so): $(LIBILBC)
+
+LIBG722:=g722/libg722.a
+$(LIBG722):
+	@$(MAKE) -C g722 all
+
+$(if $(filter codec_g722,$(EMBEDDED_MODS)),modules.link,codec_g722.so): $(LIBG722)
+
+$(if $(filter codec_g729,$(EMBEDDED_MODS)),modules.link,codec_g729.so):
+	$(CC) -o codec_g729.so -shared $(ASTLDFLAGS)  codec_g729.o $(ASTTOPDIR)/../uClinux-dist/lib/libbfgdots/g729/src.fdpic/partial_local.o
+
diff -ur asterisk/configure asterisk.patched/configure
--- asterisk/configure	2010-10-07 23:56:04.000000000 +0300
+++ asterisk.patched/configure	2011-02-04 12:18:26.000000000 +0200
@@ -10843,7 +10843,7 @@
 fi
 if test "x$ac_cv_func_fork_works" = xcross; then
   case $host in
-    *-*-amigaos* | *-*-msdosdjgpp* | *-*-uclinux* )
+    *-*-amigaos* | *-*-msdosdjgpp* | *-*-uclinux* | *-*-linux-uclibc* | bfin-*-* )
       # Override, as these systems have only a dummy fork() stub
       ac_cv_func_fork_works=no
       ;;
@@ -15457,14 +15457,15 @@
    fi
 fi
 
-   ac_fn_c_check_header_mongrel "$LINENO" "linux/mISDNdsp.h" "ac_cv_header_linux_mISDNdsp_h" "$ac_includes_default"
-if test "x$ac_cv_header_linux_mISDNdsp_h" = x""yes; then :
-
-cat >>confdefs.h <<_ACEOF
-#define MISDN_1_2 1
-_ACEOF
-
-fi
+# DPN: disabled pipeline mode in chan_misdn
+#   ac_fn_c_check_header_mongrel "$LINENO" "linux/mISDNdsp.h" "ac_cv_header_linux_mISDNdsp_h" "$ac_includes_default"
+#if test "x$ac_cv_header_linux_mISDNdsp_h" = x""yes; then :
+#
+#cat >>confdefs.h <<_ACEOF
+##define MISDN_1_2 1
+#_ACEOF
+#
+#fi
 
 
 fi
diff -ur asterisk/include/asterisk/audiohook.h asterisk.patched/include/asterisk/audiohook.h
--- asterisk/include/asterisk/audiohook.h	2010-07-27 23:33:40.000000000 +0300
+++ asterisk.patched/include/asterisk/audiohook.h	2011-02-04 12:01:44.000000000 +0200
@@ -212,6 +212,28 @@
  */
 void ast_audiohook_trigger_wait(struct ast_audiohook *audiohook);
 
+/*!
+  \brief Find out how many audiohooks from  a certain source exist on a given channel, regardless of status.
+  \param chan The channel on which to find the spies 
+  \param source The audiohook's source
+  \param type The type of audiohook 
+  \return Return the number of audiohooks which are from the source specified
+
+  Note: Function performs nlocking.
+*/
+int ast_channel_audiohook_count_by_source(struct ast_channel *chan, const char *source, enum ast_audiohook_type type);
+
+/*!
+  \brief Find out how many spies of a certain type exist on a given channel, and are in state running.
+  \param chan The channel on which to find the spies
+  \param source The source of the audiohook
+  \param type The type of spy to look for
+  \return Return the number of running audiohooks which are from the source specified
+
+  Note: Function performs no locking.
+*/
+int ast_channel_audiohook_count_by_source_running(struct ast_channel *chan, const char *source, enum ast_audiohook_type type);
+     
 /*! \brief Lock an audiohook
  * \param ah Audiohook structure
  */
diff -ur asterisk/include/asterisk/channel.h asterisk.patched/include/asterisk/channel.h
--- asterisk/include/asterisk/channel.h	2010-11-22 20:46:26.000000000 +0200
+++ asterisk.patched/include/asterisk/channel.h	2011-02-04 12:01:57.000000000 +0200
@@ -551,6 +551,7 @@
 	AST_FEATURE_PARKCALL =     (1 << 5),
 	AST_FEATURE_NO_H_EXTEN =   (1 << 6),
 	AST_FEATURE_WARNING_ACTIVE = (1 << 7),
+	AST_FEATURE_AUTOMIXMON =     (1 << 8),
 };
 
 struct ast_bridge_config {
diff -ur asterisk/main/audiohook.c asterisk.patched/main/audiohook.c
--- asterisk/main/audiohook.c	2010-07-27 23:33:40.000000000 +0300
+++ asterisk.patched/main/audiohook.c	2011-02-04 12:02:52.000000000 +0200
@@ -770,3 +770,83 @@
 	
 	return;
 }
+
+/* Count number of channel audiohooks by type, regardless of type */
+int ast_channel_audiohook_count_by_source(struct ast_channel *chan, const char *source, enum ast_audiohook_type type)
+{
+	int count = 0;
+	struct ast_audiohook *ah = NULL;
+
+	if (!chan->audiohooks)
+		return -1;
+
+	switch (type) {
+		case AST_AUDIOHOOK_TYPE_SPY:
+			AST_LIST_TRAVERSE_SAFE_BEGIN(&chan->audiohooks->spy_list, ah, list) {
+				if (!strcmp(ah->source, source)) {
+					count++;
+				}
+			}
+			AST_LIST_TRAVERSE_SAFE_END;
+			break;
+		case AST_AUDIOHOOK_TYPE_WHISPER:
+			AST_LIST_TRAVERSE_SAFE_BEGIN(&chan->audiohooks->whisper_list, ah, list) {
+				if (!strcmp(ah->source, source)) {
+					count++;
+				}
+			}
+			AST_LIST_TRAVERSE_SAFE_END;
+			break;
+		case AST_AUDIOHOOK_TYPE_MANIPULATE:
+			AST_LIST_TRAVERSE_SAFE_BEGIN(&chan->audiohooks->manipulate_list, ah, list) {
+				if (!strcmp(ah->source, source)) {
+					count++;
+				}
+			}
+			AST_LIST_TRAVERSE_SAFE_END;
+			break;
+		default:
+			ast_log(LOG_DEBUG, "Invalid audiohook type supplied, (%d)\n", type);
+			return -1;
+	}
+
+	return count;
+}
+
+/* Count number of channel audiohooks by type that are running */
+int ast_channel_audiohook_count_by_source_running(struct ast_channel *chan, const char *source, enum ast_audiohook_type type)
+{
+	int count = 0;
+	struct ast_audiohook *ah = NULL;
+	if (!chan->audiohooks)
+		return -1;
+
+	switch (type) {
+		case AST_AUDIOHOOK_TYPE_SPY:
+			AST_LIST_TRAVERSE_SAFE_BEGIN(&chan->audiohooks->spy_list, ah, list) {
+				if ((!strcmp(ah->source, source)) && (ah->status == AST_AUDIOHOOK_STATUS_RUNNING))
+					count++;
+			}
+			AST_LIST_TRAVERSE_SAFE_END;
+			break;
+		case AST_AUDIOHOOK_TYPE_WHISPER:
+			AST_LIST_TRAVERSE_SAFE_BEGIN(&chan->audiohooks->whisper_list, ah, list) {
+				if ((!strcmp(ah->source, source)) && (ah->status == AST_AUDIOHOOK_STATUS_RUNNING))
+					count++;
+			}
+			AST_LIST_TRAVERSE_SAFE_END;
+			break;
+		case AST_AUDIOHOOK_TYPE_MANIPULATE:
+			AST_LIST_TRAVERSE_SAFE_BEGIN(&chan->audiohooks->manipulate_list, ah, list) {
+				if ((!strcmp(ah->source, source)) && (ah->status == AST_AUDIOHOOK_STATUS_RUNNING))
+					count++;
+			}
+			AST_LIST_TRAVERSE_SAFE_END;
+			break;
+		default:
+			ast_log(LOG_DEBUG, "Invalid audiohook type supplied, (%d)\n", type);
+			return -1;
+	}
+	return count;
+}
+
diff -ur asterisk/main/callerid.c asterisk.patched/main/callerid.c
--- asterisk/main/callerid.c	2010-05-21 02:23:21.000000000 +0300
+++ asterisk.patched/main/callerid.c	2011-02-04 12:04:55.000000000 +0200
@@ -45,7 +45,17 @@
 #include "asterisk/options.h"
 #include "asterisk/utils.h"
 
+#ifdef USE_SPANDSP_CALLERID
+#define SPANDSP_EXPOSE_INTERNAL_STRUCTURES
+#include <spandsp.h>
+#endif
+
 struct callerid_state {
+#ifdef USE_SPANDSP_CALLERID
+	adsi_rx_state_t adsi;
+	char adsi_output[256];
+	int  adsi_len;
+#endif
 	fsk_data fskd;
 	char rawdata[256];
 	short oldstuff[160];
@@ -61,6 +71,7 @@
 
 	int skipflag; 
 	unsigned short crc;
+	FILE* fpdebug;
 };
 
 
@@ -77,6 +88,29 @@
 
 #define AST_CALLERID_UNKNOWN	"<unknown>"
 
+#ifdef USE_SPANDSP_CALLERID
+void cid_put_msg_func_t(void *user_data, const uint8_t *msg, int len)
+{
+	/*given the nature of calling adsi_rx for each sample, we'll always
+	* only have one byte at a time here */
+	struct callerid_state *cid = (struct callerid_state *)user_data;
+	cid->adsi_len = len;
+	memcpy(cid->adsi_output,msg,len > sizeof(cid->adsi_output) ? sizeof(cid->adsi_output) : len);
+}
+
+int fsk_serie_spandsp(struct callerid_state *cid, short *buffer, int *len)
+{
+
+	cid->adsi_len = 0;
+	adsi_rx(&cid->adsi,buffer,*len);
+	*len = 0;
+	if (cid->adsi_len >= 0) {
+		return 1;
+	}
+	return 0;
+}
+#endif
+
 static inline void gen_tones(unsigned char *buf, int len, int codec, float ddr1, float ddi1, float ddr2, float ddi2, float *cr1, float *ci1, float *cr2, float *ci2)
 {
 	int x;
@@ -134,6 +168,12 @@
 	struct callerid_state *cid;
 
 	if ((cid = ast_calloc(1, sizeof(*cid)))) {
+#ifdef USE_SPANDSP_CALLERID
+		adsi_rx_init(&cid->adsi,
+				(cid_signalling == 2) ? ADSI_STANDARD_CLIP : ADSI_STANDARD_CLASS,
+				cid_put_msg_func_t,
+				cid);
+#endif
 		cid->fskd.spb = 7.0;          	/* 1200 baud */
 		/* cid->fskd.hdlc = 0; */     	/* Async */
 		cid->fskd.nbit = 8;           	/* 8 bits */
@@ -559,7 +599,11 @@
 		buf[x+cid->oldlen/2] = AST_XLAW(ubuf[x]);
 	while(mylen >= 160) {
 		olen = mylen;
+#ifdef USE_SPANDSP_CALLERID
+		res = fsk_serie_spandsp(cid, buf, &mylen);
+#else
 		res = fsk_serie(&cid->fskd, buf, &mylen, &b);
+#endif
 		if (mylen < 0) {
 			ast_log(LOG_ERROR, "No start bit found in fsk data.\n");
 			free(obuf);
@@ -572,6 +616,13 @@
 			return -1;
 		}
 		if (res == 1) {
+#ifdef USE_SPANDSP_CALLERID
+			int index;
+			cid->sawflag = 2;
+			for (index = 0;index < cid->adsi_len;index++)
+			{
+				b = cid->adsi_output[index] & 0x00ff;
+#endif
 			/* Ignore invalid bytes */
 			if (b > 0xff)
 				continue;
@@ -606,6 +657,7 @@
 				if (!cid->len) {
 					cid->rawdata[cid->pos] = '\0';
 					cid->sawflag = 5;
+#ifndef USE_SPANDSP_CALLERID				
 				}
 				break;
 			case 5: /* Check checksum */
@@ -615,7 +667,7 @@
 					cid->sawflag = 0;
 					break;
 				}
-		
+#endif
 				cid->number[0] = '\0';
 				cid->name[0] = '\0';
 				/* If we get this far we're fine.  */
@@ -692,10 +744,16 @@
 				}
 				free(obuf);
 				return 1;
+#ifdef USE_SPANDSP_CALLERID
+                               }
+#endif
 				break;
 			default:
 				ast_log(LOG_ERROR, "Dunno what to do with a digit in sawflag %d\n", cid->sawflag);
 			}
+#ifdef USE_SPANDSP_CALLERID
+		} /*for*/
+#endif
 		}
 	}
 	if (mylen) {
diff -ur asterisk/main/dsp.c asterisk.patched/main/dsp.c
--- asterisk/main/dsp.c	2010-05-19 09:32:27.000000000 +0300
+++ asterisk.patched/main/dsp.c	2011-02-04 12:09:56.000000000 +0200
@@ -60,6 +60,27 @@
 #include "asterisk/alaw.h"
 #include "asterisk/utils.h"
 
+unsigned int cycles(void);
+
+#ifdef __BLACKFIN__
+unsigned int cycles() {
+  int ret;
+
+   __asm__ __volatile__
+   (
+   "%0 = CYCLES;\n\t"
+   : "=&d" (ret)
+   :
+   : "R1"
+   );
+
+   return ret;
+}
+#else
+unsigned int cycles() {}
+#endif
+int dsp_sample;
+
 /*! Number of goertzels for progress detect */
 enum gsamp_size {
 	GSAMP_SIZE_NA = 183,			/*!< North America - 350, 440, 480, 620, 950, 1400, 1800 Hz */
@@ -132,7 +153,7 @@
 /*! All THRESH_XXX values are in GSAMP_SIZE chunks (us = 22ms) */
 enum gsamp_thresh {
 	THRESH_RING = 8,        	/*!< Need at least 150ms ring to accept */
-	THRESH_TALK = 2,        	/*!< Talk detection does not work continuously */
+	THRESH_TALK = 4,        	/*!< Talk detection does not work continuously */
 	THRESH_BUSY = 4,        	/*!< Need at least 80ms to accept */
 	THRESH_CONGESTION = 4,  	/*!< Need at least 80ms to accept */
 	THRESH_HANGUP = 60,     	/*!< Need at least 1300ms to accept hangup */
@@ -194,6 +215,9 @@
 	float v2;
 	float v3;
 	float fac;
+	int16_t v2_fix;
+	int16_t v3_fix;
+	int16_t fac_fix;
 #ifndef OLD_DSP_ROUTINES
 	int samples;
 #endif	
@@ -293,14 +317,28 @@
 static char bell_mf_positions[] = "1247C-358A--69*---0B----#";
 #endif
 
+#define AMP_SCALE 8
+#define FAC_SCALE 14
+
+extern int dsp_sample;
+
 static inline void goertzel_sample(goertzel_state_t *s, short sample)
 {
+#ifdef __FIXED_PT__
+	int16_t v1_fix;
+	int     mpy;
+	v1_fix = s->v2_fix;
+	s->v2_fix = s->v3_fix;
+	mpy = (int16_t)( ((int)s->fac_fix * (int)s->v2_fix) >> FAC_SCALE );
+	s->v3_fix = mpy - v1_fix + (sample>>AMP_SCALE);
+#else
 	float v1;
 	float fsamp  = sample;
 	
 	v1 = s->v2;
 	s->v2 = s->v3;
 	s->v3 = s->fac * s->v2 - v1 + fsamp;
+#endif
 }
 
 static inline void goertzel_update(goertzel_state_t *s, short *samps, int count)
@@ -314,13 +352,19 @@
 
 static inline float goertzel_result(goertzel_state_t *s)
 {
+#ifdef __FIXED_PT__
+	s->v2 = (float)s->v2_fix * (1<<AMP_SCALE);
+	s->v3 = (float)s->v3_fix * (1<<AMP_SCALE);
+#endif
 	return s->v3 * s->v3 + s->v2 * s->v2 - s->v2 * s->v3 * s->fac;
 }
 
 static inline void goertzel_init(goertzel_state_t *s, float freq, int samples)
 {
 	s->v2 = s->v3 = 0.0;
+	s->v2_fix = s->v3_fix = 0;
 	s->fac = 2.0 * cos(2.0 * M_PI * (freq / 8000.0));
+	s->fac_fix = (int16_t)(s->fac*(1<<FAC_SCALE) + 0.5);
 #ifndef OLD_DSP_ROUTINES
 	s->samples = samples;
 #endif
@@ -329,6 +373,7 @@
 static inline void goertzel_reset(goertzel_state_t *s)
 {
 	s->v2 = s->v3 = 0.0;
+	s->v2_fix = s->v3_fix = 0;
 }
 
 struct ast_dsp {
@@ -436,15 +481,14 @@
 	float fax_energy_2nd;
 #endif	
 #endif /* FAX_DETECT */
-	float famp;
-	float v1;
 	int i;
 	int j;
 	int sample;
 	int best_row;
 	int best_col;
 	int hit;
-	int limit;
+	int limit,before;
+	before = cycles();
 
 	hit = 0;
 	for (sample = 0;  sample < samples;  sample = limit) {
@@ -456,12 +500,25 @@
 #if defined(USE_3DNOW)
 		_dtmf_goertzel_update (s->row_out, amp + sample, limit - sample);
 		_dtmf_goertzel_update (s->col_out, amp + sample, limit - sample);
+#elif defined(__FIXED_PT__)
+	for(j=0; j<4; j++) {
+		goertzel_update(&s->row_out[j], amp + sample, limit - sample);
+		goertzel_update(&s->col_out[j], amp + sample, limit - sample);
+	}
+	{
+		int acc;
+
+		acc = 0;
+		for (j = sample;  j < limit;  j++) {
+			acc += (amp[j] >> AMP_SCALE)*(amp[j] >> AMP_SCALE);
+		}
+		s->energy += (float)acc * ((float)(1<<AMP_SCALE)) * ((float)(1<<AMP_SCALE));
+	}
 #ifdef OLD_DSP_ROUTINES
 		_dtmf_goertzel_update (s->row_out2nd, amp + sample, limit2 - sample);
 		_dtmf_goertzel_update (s->col_out2nd, amp + sample, limit2 - sample);
 #endif		
 		/* XXX Need to fax detect for 3dnow too XXX */
-		#warning "Fax Support Broken"
 #else
 		/* The following unrolled loop takes only 35% (rough estimate) of the 
 		   time of a rolled loop on the machine on which it was developed */
@@ -1032,7 +1089,7 @@
 	/* Amplify ignored stuff */
 	i2 *= TONE_THRESH;
 	i1 *= TONE_THRESH;
-	e *= TONE_THRESH;
+	e *= TONE_THRESH/2;
 	/* Check first tone */
 	if ((p1 < i1) || (p1 < i2) || (p1 < e))
 		return 0;
@@ -1082,10 +1139,17 @@
 			pass = dsp->gsamp_size - dsp->gsamps;
 		}
 		for (x = 0; x < pass; x++) {
+			int acc = 0;
 			for (y = 0; y < dsp->freqcount; y++) {
 				goertzel_sample(&dsp->freqs[y], s[x]);
+#ifdef __FIXED_PT__
+				acc += (s[x] >> AMP_SCALE)* (s[x] >> AMP_SCALE);
+			}
+			dsp->genergy += (float)acc * ((float)(1<<AMP_SCALE)) * ((float)(1<<AMP_SCALE));
+#else
 			}
 			dsp->genergy += s[x] * s[x];
+#endif		
 		}
 		s += pass;
 		dsp->gsamps += pass;
@@ -1496,6 +1560,8 @@
 		dsp->display_inband_dtmf_warning = 0;
 		return af;
 	}
+#define TMP_DR
+#ifdef TMP_DR
 	silence = __ast_dsp_silence(dsp, shortdata, len, NULL);
 	if ((dsp->features & DSP_FEATURE_SILENCE_SUPPRESS) && silence) {
 		memset(&dsp->f, 0, sizeof(dsp->f));
@@ -1628,6 +1694,7 @@
 			}
 		}
 	}
+#endif
 	FIX_INF(af);
 	return af;
 }
diff -ur asterisk/main/frame.c asterisk.patched/main/frame.c
--- asterisk/main/frame.c	2010-06-11 21:23:05.000000000 +0300
+++ asterisk.patched/main/frame.c	2011-02-04 12:11:03.000000000 +0200
@@ -110,7 +110,7 @@
 	{ 1, AST_FORMAT_SLINEAR, "slin", "16 bit Signed Linear PCM", 160, 10, 70, 10, 20, AST_SMOOTHER_FLAG_BE },	/*!< 7 */
 	{ 1, AST_FORMAT_LPC10, "lpc10", "LPC10", 7, 20, 20, 20, 20 },		/*!<  8: codec_lpc10.c */ 
 	{ 1, AST_FORMAT_G729A, "g729", "G.729A", 10, 10, 230, 10, 20, AST_SMOOTHER_FLAG_G729 },	/*!<  9: Binary commercial distribution */
-	{ 1, AST_FORMAT_SPEEX, "speex", "SpeeX", 10, 10, 60, 10, 20 },		/*!< 10: codec_speex.c */
+	{ 1, AST_FORMAT_SPEEX, "speex", "SpeeX", 38, 20, 300, 20, 20 },         /*!< 10: codec_speex.c */
 	{ 1, AST_FORMAT_ILBC, "ilbc", "iLBC", 50, 30, 30, 30, 30 },		/*!< 11: codec_ilbc.c */ /* inc=30ms - workaround */
 	{ 1, AST_FORMAT_G726_AAL2, "g726aal2", "G.726 AAL2", 40, 10, 300, 10, 20 },	/*!<  12: codec_g726.c */
 	{ 1, AST_FORMAT_G722, "g722", "G722"},					/*!< 13 */
@@ -1492,7 +1492,9 @@
 	int samples=0;
 	switch(f->subclass) {
 	case AST_FORMAT_SPEEX:
-		samples = speex_samples(f->data, f->datalen);
+		/* DR: hard coded for quality=8 mode.
+			300 bits (38 bytes) converted to 160 samples */
+		samples = 160 * (f->datalen / 38);
 		break;
 	case AST_FORMAT_G723_1:
                 samples = g723_samples(f->data, f->datalen);
diff -ur asterisk/main/loader.c asterisk.patched/main/loader.c
--- asterisk/main/loader.c	2010-07-09 21:23:23.000000000 +0300
+++ asterisk.patched/main/loader.c	2011-02-04 12:12:24.000000000 +0200
@@ -660,6 +660,13 @@
 		ast_verbose("The previous reload command didn't finish yet\n");
 		return -1;	/* reload already in progress */
 	}
+
+        if (ast_lastreloadtime && time(NULL) - ast_lastreloadtime < 5) {
+        	ast_verbose("The previous reload was less than 5 seconds ago.\n");
+        	ast_mutex_unlock(&reloadlock);
+        	return -1;
+        }
+
 	ast_lastreloadtime = time(NULL);
 
 	/* Call "predefined" reload here first */
diff -ur asterisk/main/manager.c asterisk.patched/main/manager.c
--- asterisk/main/manager.c	2010-10-02 11:50:05.000000000 +0300
+++ asterisk.patched/main/manager.c	2011-02-04 12:13:02.000000000 +0200
@@ -1186,7 +1186,7 @@
 		astman_send_error(s, m, "Filename not specified");
 		return 0;
 	}
-	if (!(cfg = ast_config_load_with_comments(fn))) {
+	if (!(cfg = ast_config_load(fn))) {
 		astman_send_error(s, m, "Config file not found");
 		return 0;
 	}
@@ -1296,7 +1296,7 @@
 		astman_send_error(s, m, "Filename not specified");
 		return 0;
 	}
-	if (!(cfg = ast_config_load_with_comments(sfn))) {
+	if (!(cfg = ast_config_load(sfn))) {
 		astman_send_error(s, m, "Config file not found");
 		return 0;
 	}
diff -ur asterisk/pbx/Makefile asterisk.patched/pbx/Makefile
--- asterisk/pbx/Makefile	2010-05-11 22:55:42.000000000 +0300
+++ asterisk.patched/pbx/Makefile	2011-02-04 12:13:36.000000000 +0200
@@ -73,3 +73,6 @@
 $(if $(filter pbx_dundi,$(EMBEDDED_MODS)),modules.link,pbx_dundi.so): dundi-parser.o
 
 pbx_gtkconsole.o: _ASTCFLAGS+=-Wno-strict-prototypes
+
+pbx_lua.so:
+	$(CC) -o pbx_lua.so -shared  $(ASTLDFLAGS) pbx_lua.o $(wildcard $(ASTTOPDIR)/../uClinux-dist/user/lua/lua-5.1.4/src/*[!lua].o)
diff -ur asterisk/res/res_agi.c asterisk.patched/res/res_agi.c
--- asterisk/res/res_agi.c	2010-11-19 21:32:04.000000000 +0200
+++ asterisk.patched/res/res_agi.c	2011-02-04 12:13:56.000000000 +0200
@@ -308,7 +308,7 @@
 	/* Block SIGHUP during the fork - prevents a race */
 	sigfillset(&signal_set);
 	pthread_sigmask(SIG_BLOCK, &signal_set, &old_set);
-	pid = fork();
+	pid = vfork();
 	if (pid < 0) {
 		ast_log(LOG_WARNING, "Failed to fork(): %s\n", strerror(errno));
 		pthread_sigmask(SIG_SETMASK, &old_set, NULL);
diff -ur asterisk/res/res_features.c asterisk.patched/res/res_features.c
--- asterisk/res/res_features.c	2010-11-04 23:28:12.000000000 +0200
+++ asterisk.patched/res/res_features.c	2011-02-04 12:15:23.000000000 +0200
@@ -64,6 +64,7 @@
 #include "asterisk/adsi.h"
 #include "asterisk/devicestate.h"
 #include "asterisk/monitor.h"
+#include "asterisk/audiohook.h"
 #include "asterisk/global_datastores.h"
 
 #define DEFAULT_PARK_TIME 45000
@@ -107,6 +108,7 @@
 static int parkedcallreparking;                            /*!< Who can PARKCALL after picking up a parked call */
 static int parkedcallhangup;                               /*!< Who can DISCONNECT after picking up a parked call */
 static int parkedcallrecording;                            /*!< Who can AUTOMON after picking up a parked call */
+static int parkedcallmixrecording;                         /*!< Who can AUTOMIXMON after picking up a parked call */
 
 static char courtesytone[256];                             /*!< Courtesy tone */
 static int parkedplay = 0;                                 /*!< Who to play the courtesy tone to */
@@ -152,6 +154,12 @@
 static struct ast_app *monitor_app = NULL;
 static int monitor_ok = 1;
 
+static struct ast_app *mixmonitor_app = NULL;
+static int mixmonitor_ok = 1;
+
+static struct ast_app *stopmixmonitor_app = NULL;
+static int stopmixmonitor_ok = 1;
+
 struct parkeduser {
 	struct ast_channel *chan;                   /*!< Parking channel */
 	struct timeval start;                       /*!< Time the parking started */
@@ -757,6 +765,122 @@
 	return -1;
 }
 
+static int builtin_automixmonitor(struct ast_channel *chan, struct ast_channel *peer, struct ast_bridge_config *config, char *code, int sense, void *data)
+{
+	char *caller_chan_id = NULL, *callee_chan_id = NULL, *args = NULL, *touch_filename = NULL, *outtime = NULL;
+	int x = 0;
+	size_t len;
+	time_t t;
+	struct ast_channel *caller_chan, *callee_chan;
+	const char *mixmonitor_spy_type = "MixMonitor";
+	int count = 0;
+
+	if (!mixmonitor_ok) {
+		ast_log(LOG_ERROR,"Cannot record the call. The mixmonitor application is disabled.\n");
+		return -1;
+	}
+
+	if (!(mixmonitor_app = pbx_findapp("MixMonitor"))) {
+		mixmonitor_ok = 0;
+		ast_log(LOG_ERROR,"Cannot record the call. The mixmonitor application is disabled.\n");
+		return -1;
+	}
+
+	set_peers(&caller_chan, &callee_chan, peer, chan, sense);
+
+	if (!ast_strlen_zero(courtesytone)) {
+		if (ast_autoservice_start(callee_chan))
+			return -1;
+		if (ast_stream_and_wait(caller_chan, courtesytone, caller_chan->language, "")) {
+			ast_log(LOG_WARNING, "Failed to play courtesy tone!\n");
+			ast_autoservice_stop(callee_chan);
+			return -1;
+		}
+		if (ast_autoservice_stop(callee_chan))
+			return -1;
+	}
+
+	ast_channel_lock(callee_chan);
+	count = ast_channel_audiohook_count_by_source(callee_chan, mixmonitor_spy_type, AST_AUDIOHOOK_TYPE_SPY);
+	ast_channel_unlock(callee_chan);
+
+	// This means a mixmonitor is attached to the channel, running or not is unknown.
+	if (count > 0) {
+		
+		if (option_verbose > 3)
+			ast_verbose(VERBOSE_PREFIX_3 "User hit '%s' to stop recording call.\n", code);
+
+		//Make sure they are running
+		ast_channel_lock(callee_chan);
+		count = ast_channel_audiohook_count_by_source_running(callee_chan, mixmonitor_spy_type, AST_AUDIOHOOK_TYPE_SPY);
+		ast_channel_unlock(callee_chan);
+		if (count > 0) {
+			if (!stopmixmonitor_ok) {
+				ast_log(LOG_ERROR,"Cannot stop recording the call. The stopmixmonitor application is disabled.\n");
+				return -1;
+			}
+			if (!(stopmixmonitor_app = pbx_findapp("StopMixMonitor"))) {
+				stopmixmonitor_ok = 0;
+				ast_log(LOG_ERROR,"Cannot stop recording the call. The stopmixmonitor application is disabled.\n");
+				return -1;
+			} else {
+				pbx_exec(callee_chan, stopmixmonitor_app, "");
+				return FEATURE_RETURN_SUCCESS;
+			}
+		}
+		
+		ast_log(LOG_WARNING,"Stopped MixMonitors are attached to the channel.\n");	
+	}			
+
+	if (caller_chan && callee_chan) {
+		const char *touch_format = pbx_builtin_getvar_helper(caller_chan, "TOUCH_MIXMONITOR_FORMAT");
+		const char *touch_monitor = pbx_builtin_getvar_helper(caller_chan, "TOUCH_MIXMONITOR");
+
+		if (!touch_format)
+			touch_format = pbx_builtin_getvar_helper(callee_chan, "TOUCH_MIXMONITOR_FORMAT");
+
+		if (!touch_monitor)
+			touch_monitor = pbx_builtin_getvar_helper(callee_chan, "TOUCH_MIXMONITOR");
+
+		if (touch_monitor) {
+			len = strlen(touch_monitor) + 50;
+			args = alloca(len);
+			touch_filename = alloca(len);
+			snprintf(touch_filename, len, "%s", touch_monitor); 
+			snprintf(args, len, "%s.%s", touch_filename, (touch_format) ? touch_format : "wav");
+		} else {
+			t = time(NULL);
+			outtime = alloca(100);
+			caller_chan_id = ast_strdupa(S_OR(caller_chan->cid.cid_num, caller_chan->name));
+			callee_chan_id = ast_strdupa(S_OR(callee_chan->cid.cid_num, callee_chan->name));
+			strftime(outtime, 100, "%Y%m%d-%H%M%S", localtime(&t));
+			len = strlen(caller_chan_id) + strlen(callee_chan_id) + strlen(outtime) + 50;
+			args = alloca(len);
+			touch_filename = alloca(len);
+			snprintf(touch_filename, len, "%s-%s-%s", caller_chan_id, callee_chan_id, outtime);
+			snprintf(args, len, "%s.%s", touch_filename, S_OR(touch_format, "wav"));
+		}
+
+		for( x = 0; x < strlen(args); x++) {
+			if (args[x] == '/')
+				args[x] = '-';
+		}
+
+		if (option_verbose > 3)
+			ast_verbose(VERBOSE_PREFIX_3 "User hit '%s' to record call. filename: %s\n", code, touch_filename);
+
+		pbx_exec(callee_chan, mixmonitor_app, args);
+		pbx_builtin_setvar_helper(callee_chan, "TOUCH_MIXMONITOR_OUTPUT", touch_filename);
+		pbx_builtin_setvar_helper(caller_chan, "TOUCH_MIXMONITOR_OUTPUT", touch_filename);
+		return FEATURE_RETURN_SUCCESS;
+	
+	}
+
+	ast_log(LOG_NOTICE,"Cannot record the call. One or both channels have gone away.\n");
+	return -1;
+
+}
+
 static int builtin_disconnect(struct ast_channel *chan, struct ast_channel *peer, struct ast_bridge_config *config, char *code, int sense, void *data)
 {
 	if (option_verbose > 3)
@@ -1133,6 +1257,7 @@
 	{ AST_FEATURE_AUTOMON, "One Touch Monitor", "automon", "", "", builtin_automonitor, AST_FEATURE_FLAG_NEEDSDTMF, "" },
 	{ AST_FEATURE_DISCONNECT, "Disconnect Call", "disconnect", "*", "*", builtin_disconnect, AST_FEATURE_FLAG_NEEDSDTMF, "" },
 	{ AST_FEATURE_PARKCALL, "Park Call", "parkcall", "", "", builtin_parkcall, AST_FEATURE_FLAG_NEEDSDTMF, "" },
+	{ AST_FEATURE_AUTOMIXMON, "One Touch MixMonitor", "automixmon", "", "", builtin_automixmonitor, AST_FEATURE_FLAG_NEEDSDTMF, "" },
 };
 
 
@@ -2716,6 +2841,12 @@
 		if ((parkedcallrecording == AST_FEATURE_FLAG_BYCALLER) || (parkedcallrecording == AST_FEATURE_FLAG_BYBOTH)) {
 			ast_set_flag(&(config.features_caller), AST_FEATURE_AUTOMON);
 		}
+		if ((parkedcallmixrecording == AST_FEATURE_FLAG_BYCALLEE) || (parkedcallmixrecording == AST_FEATURE_FLAG_BYBOTH)) {
+			ast_set_flag(&(config.features_callee), AST_FEATURE_AUTOMIXMON);
+		}
+		if ((parkedcallmixrecording == AST_FEATURE_FLAG_BYCALLER) || (parkedcallmixrecording == AST_FEATURE_FLAG_BYBOTH)) {
+			ast_set_flag(&(config.features_caller), AST_FEATURE_AUTOMIXMON);
+		}
 		res = ast_bridge_call(chan, peer, &config);
 
 		pbx_builtin_setvar_helper(chan, "PARKEDCHANNEL", peer->name);
@@ -3010,6 +3141,7 @@
 	parkedcallreparking = 0;
 	parkedcallhangup = 0;
 	parkedcallrecording = 0;
+	parkedcallmixrecording = 0;
 
 	transferdigittimeout = DEFAULT_TRANSFER_DIGIT_TIMEOUT;
 	featuredigittimeout = DEFAULT_FEATURE_DIGIT_TIMEOUT;
@@ -3078,6 +3210,15 @@
 				parkedcallrecording = AST_FEATURE_FLAG_BYCALLEE;
 			else if (!strcasecmp(var->value, "both"))
 				parkedcallrecording = AST_FEATURE_FLAG_BYBOTH;
+		} else if (!strcasecmp(var->name, "parkedcallmixrecording")) {
+			if (!strcasecmp(var->value, "no"))
+				parkedcallmixrecording = 0;
+			else if (!strcasecmp(var->value, "caller"))
+				parkedcallmixrecording = AST_FEATURE_FLAG_BYCALLER;
+			else if (!strcasecmp(var->value, "callee"))
+				parkedcallmixrecording = AST_FEATURE_FLAG_BYCALLEE;
+			else if (!strcasecmp(var->value, "both"))
+				parkedcallmixrecording = AST_FEATURE_FLAG_BYBOTH;
 		} else if (!strcasecmp(var->name, "adsipark")) {
 			adsipark = ast_true(var->value);
 		} else if (!strcasecmp(var->name, "transferdigittimeout")) {
diff -ur asterisk/utils/Makefile asterisk.patched/utils/Makefile
--- asterisk/utils/Makefile	2010-03-25 22:41:15.000000000 +0200
+++ asterisk.patched/utils/Makefile	2011-02-04 12:16:17.000000000 +0200
@@ -26,7 +26,7 @@
 #     changes are made to ast_expr2.y or ast_expr2.fl (or the corresponding .c files),
 #     as a regression test. Others (mere mortals?) need not bother, but they are
 #     more than welcome to play! The regression test itself is in expr2.testinput.
-ALL_UTILS:=astman smsq stereorize streamplayer aelparse muted
+ALL_UTILS:=astman smsq stereorize streamplayer aelparse
 UTILS:=$(ALL_UTILS)
 
 include $(ASTTOPDIR)/Makefile.rules
--- asterisk/configure	2011-02-04 12:18:26.000000000 +0200
+++ asterisk.patched/configure	2011-02-04 13:25:27.000000000 +0200
@@ -12274,153 +12274,6 @@
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if we can increase the maximum select-able file descriptor" >&5
-$as_echo_n "checking if we can increase the maximum select-able file descriptor... " >&6; }
-if test "$cross_compiling" = yes; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: cross-compile" >&5
-$as_echo "cross-compile" >&6; }
-
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-#include <stdio.h>
-#include <sys/select.h>
-#include <sys/time.h>
-#include <sys/resource.h>
-#include <string.h>
-#include <errno.h>
-#include <stdlib.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <unistd.h>
-
-int
-main ()
-{
-
-	struct rlimit rlim = { FD_SETSIZE * 2, FD_SETSIZE * 2 };
-	int fd0, fd1;
-	struct timeval tv = { 0, };
-	struct ast_fdset { long fds_bits[1024]; } fds = { { 0, } };
-	if (setrlimit(RLIMIT_NOFILE, &rlim)) { exit(1); }
-	if ((fd0 = open("/dev/null", O_RDONLY)) < 0) { exit(1); }
-	if (dup2(fd0, (fd1 = FD_SETSIZE + 1)) < 0) { exit(1); }
-	FD_SET(fd0, (fd_set *) &fds);
-	FD_SET(fd1, (fd_set *) &fds);
-	if (select(FD_SETSIZE + 2, (fd_set *) &fds, NULL, NULL, &tv) < 0) { exit(1); }
-	exit(0)
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_run "$LINENO"; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-
-$as_echo "#define HAVE_VARIABLE_FDSET 1" >>confdefs.h
-
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
-  conftest.$ac_objext conftest.beam conftest.$ac_ext
-fi
-
-
-ac_cv_have_variable_fdset=0
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if we can increase the maximum select-able file descriptor" >&5
-$as_echo_n "checking if we can increase the maximum select-able file descriptor... " >&6; }
-if test "$cross_compiling" = yes; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: cross-compile" >&5
-$as_echo "cross-compile" >&6; }
-
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-#include <stdio.h>
-#include <sys/select.h>
-#include <sys/time.h>
-#include <sys/resource.h>
-#include <string.h>
-#include <errno.h>
-#include <stdlib.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <unistd.h>
-
-int
-main ()
-{
-
-	struct rlimit rlim = { FD_SETSIZE + 2, FD_SETSIZE + 2 };
-	int fd[2];
-	struct timeval tv = { 0, };
-	struct ast_fdset { long fds_bits[1024]; } fds = { { 0, } };
-	if (setrlimit(RLIMIT_NOFILE, &rlim)) { exit(1); }
-	if ((fd0 = open("/dev/null", O_RDONLY)) < 0) { exit(1); }
-	if (dup2(fd0, (fd1 = FD_SETSIZE + 1)) < 0) { exit(1); }
-	FD_SET(fd[0], (fd_set *) &fds);
-	FD_SET(fd[1], (fd_set *) &fds);
-	if (select(FD_SETSIZE + 2, (fd_set *) &fds, NULL, NULL, &tv) < 0) { exit(1); }
-	exit(0)
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_run "$LINENO"; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
-$as_echo "yes" >&6; }
-	ac_cv_have_variable_fdset=1
-
-$as_echo "#define HAVE_VARIABLE_FDSET 1" >>confdefs.h
-
-else
-  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
-$as_echo "no" >&6; }
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
-  conftest.$ac_objext conftest.beam conftest.$ac_ext
-fi
-
-
-if test "${ac_cv_have_variable_fdset}x" = "0x"; then
-	if test "$cross_compiling" = yes; then :
-  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error "cannot run test program while cross compiling
-See \`config.log' for more details." "$LINENO" 5; }
-else
-  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-#include <unistd.h>
-#include <sys/types.h>
-#include <stdlib.h>
-
-int
-main ()
-{
-if (getuid() != 0) { exit(1); }
-  ;
-  return 0;
-}
-_ACEOF
-if ac_fn_c_try_run "$LINENO"; then :
-
-$as_echo "#define CONFIGURE_RAN_AS_ROOT 1" >>confdefs.h
-
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
-  conftest.$ac_objext conftest.beam conftest.$ac_ext
-fi
-
-fi
-
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for compiler 'attribute pure' support" >&5
 $as_echo_n "checking for compiler 'attribute pure' support... " >&6; }
