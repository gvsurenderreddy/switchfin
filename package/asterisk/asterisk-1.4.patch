diff -Naur asterisk-1.4.42_original/apps/app_dial.c asterisk-1.4.42_switchfin/apps/app_dial.c
--- asterisk-1.4.42_original/apps/app_dial.c	2011-05-18 16:56:08.000000000 -0300
+++ asterisk-1.4.42_switchfin/apps/app_dial.c	2011-09-06 09:51:42.000000000 -0300
@@ -214,7 +214,11 @@
 "           of features.conf.\n"
 "    W    - Allow the calling party to enable recording of the call by sending\n"
 "           the DTMF sequence defined in the automon setting in the featuremap section\n"
-"           of features.conf.\n";
+"           of features.conf.\n"
+"    x    - Allow the called party to enable recording of the call by sending\n"
+"           the DTMF sequence defined for one-touch automixmonitor in features.conf\n"
+"    X    - Allow the calling party to enable recording of the call by sending\n"
+"           the DTMF sequence defined for one-touch automixmonitor in features.conf\n";
 
 /* RetryDial App by Anthony Minessale II <anthmct@yahoo.com> Jan/2005 */
 static char *rapp = "RetryDial";
@@ -261,6 +265,8 @@
 	OPT_CALLEE_PARK =	(1 << 25),
 	OPT_CALLER_PARK =	(1 << 26),
 	OPT_IGNORE_FORWARDING = (1 << 27),
+	OPT_CALLEE_MIXMONITOR = (1 << 28),
+	OPT_CALLER_MIXMONITOR = (1 << 29),
 } dial_exec_option_flags;
 
 #define DIAL_STILLGOING			(1 << 30)
@@ -310,11 +316,14 @@
 	AST_APP_OPTION('T', OPT_CALLER_TRANSFER),
 	AST_APP_OPTION('w', OPT_CALLEE_MONITOR),
 	AST_APP_OPTION('W', OPT_CALLER_MONITOR),
+	AST_APP_OPTION('x', OPT_CALLEE_MIXMONITOR),
+	AST_APP_OPTION('X', OPT_CALLER_MIXMONITOR),
 });
 
 #define CAN_EARLY_BRIDGE(flags,chan,peer) (!ast_test_flag(flags, OPT_CALLEE_HANGUP | \
 	OPT_CALLER_HANGUP | OPT_CALLEE_TRANSFER | OPT_CALLER_TRANSFER | \
 	OPT_CALLEE_MONITOR | OPT_CALLER_MONITOR | OPT_CALLEE_PARK |  \
+        OPT_CALLER_MIXMONITOR | OPT_CALLEE_MIXMONITOR | \
 	OPT_CALLER_PARK | OPT_ANNOUNCE | OPT_CALLEE_MACRO) && \
 	!chan->audiohooks && !peer->audiohooks)
 
@@ -498,6 +507,7 @@
 						       OPT_CALLEE_TRANSFER | OPT_CALLER_TRANSFER |
 						       OPT_CALLEE_HANGUP | OPT_CALLER_HANGUP |
 						       OPT_CALLEE_MONITOR | OPT_CALLER_MONITOR |
+						       OPT_CALLEE_MIXMONITOR | OPT_CALLER_MIXMONITOR |
 						       OPT_CALLEE_PARK | OPT_CALLER_PARK |
 						       DIAL_NOFORWARDHTML);
 					ast_copy_string(c->dialcontext, "", sizeof(c->dialcontext));
@@ -629,6 +639,7 @@
 							       OPT_CALLEE_HANGUP | OPT_CALLER_HANGUP |
 							       OPT_CALLEE_MONITOR | OPT_CALLER_MONITOR |
 							       OPT_CALLEE_PARK | OPT_CALLER_PARK |
+							       OPT_CALLEE_MIXMONITOR | OPT_CALLER_MIXMONITOR |
 							       DIAL_NOFORWARDHTML);
 						ast_copy_string(c->dialcontext, "", sizeof(c->dialcontext));
 						ast_copy_string(c->exten, "", sizeof(c->exten));
@@ -1236,6 +1247,7 @@
 				       OPT_CALLEE_HANGUP | OPT_CALLER_HANGUP |
 				       OPT_CALLEE_MONITOR | OPT_CALLER_MONITOR |
 				       OPT_CALLEE_PARK | OPT_CALLER_PARK |
+				       OPT_CALLEE_MIXMONITOR | OPT_CALLER_MIXMONITOR |
 				       OPT_RINGBACK | OPT_MUSICBACK | OPT_FORCECLID);
 			ast_set2_flag(tmp, args.url, DIAL_NOFORWARDHTML);	
 		}
@@ -1845,6 +1857,10 @@
 				ast_set_flag(&(config.features_callee), AST_FEATURE_AUTOMON);
 			if (ast_test_flag(peerflags, OPT_CALLER_MONITOR)) 
 				ast_set_flag(&(config.features_caller), AST_FEATURE_AUTOMON);
+			if (ast_test_flag(peerflags, OPT_CALLEE_MIXMONITOR))
+				ast_set_flag(&(config.features_callee), AST_FEATURE_AUTOMIXMON);
+			if (ast_test_flag(peerflags, OPT_CALLER_MIXMONITOR)) 
+				ast_set_flag(&(config.features_caller), AST_FEATURE_AUTOMIXMON);
 			if (ast_test_flag(peerflags, OPT_CALLEE_PARK))
 				ast_set_flag(&(config.features_callee), AST_FEATURE_PARKCALL);
 			if (ast_test_flag(peerflags, OPT_CALLER_PARK))
@@ -1852,6 +1868,7 @@
 			if (ast_test_flag(peerflags, OPT_GO_ON))
 				ast_set_flag(&(config.features_caller), AST_FEATURE_NO_H_EXTEN);
 
+
 			config.timelimit = timelimit;
 			config.play_warning = play_warning;
 			config.warning_freq = warning_freq;
diff -Naur asterisk-1.4.42_original/apps/app_directory.c asterisk-1.4.42_switchfin/apps/app_directory.c
--- asterisk-1.4.42_original/apps/app_directory.c	2010-05-18 15:54:58.000000000 -0300
+++ asterisk-1.4.42_switchfin/apps/app_directory.c	2011-09-05 13:37:51.000000000 -0300
@@ -179,7 +179,7 @@
 					break;
 				}
 				if (fd > -1)
-					fdm = mmap(NULL, fdlen, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+					fdm = mmap(NULL, fdlen, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);
 			}
 			if (fdm != MAP_FAILED) {
 				memset(fdm, 0, fdlen);
diff -Naur asterisk-1.4.42_original/apps/app_voicemail.c asterisk-1.4.42_switchfin/apps/app_voicemail.c
--- asterisk-1.4.42_original/apps/app_voicemail.c	2011-05-04 13:08:50.000000000 -0300
+++ asterisk-1.4.42_switchfin/apps/app_voicemail.c	2011-09-05 13:41:36.000000000 -0300
@@ -2497,7 +2497,7 @@
 					}
 					/* Read out in small chunks */
 					for (offset = 0; offset < colsize2; offset += CHUNKSIZE) {
-						if ((fdm = mmap(NULL, CHUNKSIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, offset)) == MAP_FAILED) {
+						if ((fdm = mmap(NULL, CHUNKSIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, offset)) == MAP_FAILED) {
 							ast_log(LOG_WARNING, "Could not mmap the output file: %s (%d)\n", strerror(errno), errno);
 							SQLFreeHandle(SQL_HANDLE_STMT, stmt);
 							ast_odbc_release_obj(obj);
@@ -2863,7 +2863,7 @@
 		fdlen = lseek(fd, 0, SEEK_END);
 		lseek(fd, 0, SEEK_SET);
 		printf("Length is %zd\n", fdlen);
-		fdm = mmap(NULL, fdlen, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+		fdm = mmap(NULL, fdlen, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);
 		if (fdm == MAP_FAILED) {
 			ast_log(LOG_WARNING, "Memory map failed!\n");
 			ast_odbc_release_obj(obj);
diff -Naur asterisk-1.4.42_original/channels/chan_dahdi.c asterisk-1.4.42_switchfin/channels/chan_dahdi.c
--- asterisk-1.4.42_original/channels/chan_dahdi.c	2011-04-11 12:27:52.000000000 -0300
+++ asterisk-1.4.42_switchfin/channels/chan_dahdi.c	2011-09-05 14:10:22.000000000 -0300
@@ -116,6 +116,8 @@
 };
 static struct ast_jb_conf global_jbconf;
 
+extern unsigned int cycles(void);
+
 #ifndef DAHDI_TONEDETECT
 /* Work around older code with no tone detect */
 #define DAHDI_EVENT_DTMFDOWN 0
@@ -931,6 +933,10 @@
 	int polarity;
 	/*! \brief DSP feature flags: DSP_FEATURE_xxx */
 	int dsp_features;
+	/*! \brief DR: stats for DSP execution */
+	int dsp_cycles_last;     
+	int dsp_cycles_worst;
+	int dsp_cycles_average;
 	/*! \brief DTMF digit in progress.  0 when no digit in progress. */
 	char begindigit;
 } *iflist = NULL, *ifend = NULL;
@@ -5427,6 +5433,7 @@
 	int index;
 	void *readbuf;
 	struct ast_frame *f;
+	int before;
 
 	/*
 	 * For analog channels, we must do deadlock avoidance because
@@ -5697,7 +5704,17 @@
 	}
 	if (p->dsp && (!p->ignoredtmf || p->callwaitcas || p->busydetect  || p->callprogress) && !index) {
 		/* Perform busy detection. etc on the dahdi line */
+		/* DR: measure some execution stats around this as it is a
+		computationally intensive part of the real time code */
+		before = cycles();
 		f = ast_dsp_process(ast, p->dsp, &p->subs[index].f);
+
+		p->dsp_cycles_last = cycles() - before;
+		if (p->dsp_cycles_last > p->dsp_cycles_worst) {
+			p->dsp_cycles_worst = p->dsp_cycles_last;
+		}
+		p->dsp_cycles_average = (int)(0.1*(float)p->dsp_cycles_last +
+ 				        0.9*(float)p->dsp_cycles_average);
 		if (f) {
 			if ((f->frametype == AST_FRAME_CONTROL) && (f->subclass == AST_CONTROL_BUSY)) {
 				if ((ast->_state == AST_STATE_UP) && !p->outgoing) {
@@ -10152,6 +10169,9 @@
 								pri->pvts[x]->owner->_softhangup |= AST_SOFTHANGUP_DEV;
 							ast_mutex_unlock(&pri->pvts[x]->lock);
 						}
+						pri->pvts[x]->dsp_cycles_last = 0;
+						pri->pvts[x]->dsp_cycles_worst = 0;
+						pri->pvts[x]->dsp_cycles_average = 0;	
 				}
 				break;
 			case PRI_EVENT_KEYPAD_DIGIT:
@@ -11675,6 +11695,7 @@
 	return RESULT_SUCCESS;
 }
 
+extern int dsp_sample;
 static int dahdi_show_channels(int fd, int argc, char **argv)
 {
 #define FORMAT "%7s %-10.10s %-15.15s %-10.10s %-20.20s\n"
@@ -11815,6 +11836,9 @@
 			ast_cli(fd, "Fax Handled: %s\n", tmp->faxhandled ? "yes" : "no");
 			ast_cli(fd, "Pulse phone: %s\n", tmp->pulsedial ? "yes" : "no");
 			ast_cli(fd, "Echo Cancellation: %d taps%s, currently %s\n", tmp->echocancel, tmp->echocanbridged ? "" : " unless TDM bridged", tmp->echocanon ? "ON" : "OFF");
+			ast_cli(fd, "DSP cycles last: %d worst: %d average: %d sample: %d\n",
+				tmp->dsp_cycles_last, tmp->dsp_cycles_worst, tmp->dsp_cycles_average, dsp_sample);			
+
 			if (tmp->master)
 				ast_cli(fd, "Master Channel: %d\n", tmp->master->channel);
 			for (x = 0; x < MAX_SLAVES; x++) {
diff -Naur asterisk-1.4.42_original/channels/chan_sip.c asterisk-1.4.42_switchfin/channels/chan_sip.c
--- asterisk-1.4.42_original/channels/chan_sip.c	2011-06-28 17:03:19.000000000 -0300
+++ asterisk-1.4.42_switchfin/channels/chan_sip.c	2011-09-05 16:45:05.000000000 -0300
@@ -1617,6 +1617,7 @@
 static void build_callid_registry(struct sip_registry *reg, struct in_addr ourip, const char *fromdomain);
 static void make_our_tag(char *tagbuf, size_t len);
 static int add_header(struct sip_request *req, const char *var, const char *value);
+static int add_header_contentLength(struct sip_request *req, int len);
 static int add_content(struct sip_request *req, const char *line);
 static int finalize_content(struct sip_request *req);
 static int add_text(struct sip_request *req, const char *text);
@@ -6428,6 +6429,15 @@
 	return 0;	
 }
 
+ /*! \brief Add 'Content-Length' header to SIP message */
+static int add_header_contentLength(struct sip_request *req, int len)
+{
+	char clen[10];
+
+	snprintf(clen, sizeof(clen), "%d", len);
+	return add_header(req, "Content-Length", clen);
+}
+
 /*! \brief Add 'Content-Length' header to SIP message */
 static int finalize_content(struct sip_request *req)
 {
@@ -7053,6 +7063,7 @@
 	struct sip_request resp;
 	respprep(&resp, p, msg, req);
 	add_header(&resp, "Accept", "application/sdp");
+	add_header_contentLength(&resp, 0);  //Penev: Zero the Content-Length !
 	return send_response(p, &resp, reliable, 0);
 }
 
diff -Naur asterisk-1.4.42_original/channels/misdn/isdn_lib.c asterisk-1.4.42_switchfin/channels/misdn/isdn_lib.c
--- asterisk-1.4.42_original/channels/misdn/isdn_lib.c	2009-10-01 20:18:28.000000000 -0300
+++ asterisk-1.4.42_switchfin/channels/misdn/isdn_lib.c	2011-09-05 14:21:55.000000000 -0300
@@ -293,6 +293,13 @@
 	}
 }
 
+#define ISDN_LIB_DO_NOT_FLIP_BITS
+#ifdef ISDN_LIB_DO_NOT_FLIP_BITS
+ 
+#define init_flip_bits(x) 	do { /* NOP */ } while(0)
+#define flip_buf_bits(a,b) 	do { /* NOP */ } while(0)
+
+#else
 
 static char flip_table[256];
 
@@ -320,7 +327,7 @@
 	
 	return start;
 }
-
+#endif /* #ifdef ISDN_LIB_DO_NOT_FLIP_BITS */
 
 
 
@@ -1035,7 +1042,7 @@
 		li.st = bc->b_stid; /*  given idx */
 
 
-#define MISDN_DSP
+#undef MISDN_DSP
 #ifndef MISDN_DSP
 		bc->nodsp=1;
 #endif
@@ -4535,7 +4542,7 @@
 
 #ifdef MISDN_1_2
 	if (*bc->pipeline) {
-		cb_log(3, stack?stack->port:0,"Sending Control PIPELINE_CFG %s\n",bc->pipeline);
+		cb_log(3, stack?stack->port:0,"Sending Control HW_ECHOCAN_ON taps:%d\n",bc->ec_deftaps);		
 		manager_ph_control_block(bc, PIPELINE_CFG, bc->pipeline, strlen(bc->pipeline) + 1);
  	}
 #else
@@ -4564,7 +4571,7 @@
 		ec_arr[0]=bc->ec_deftaps;
 		ec_arr[1]=0;
 		
-		manager_ph_control_block(bc,  ECHOCAN_ON,  ec_arr, sizeof(ec_arr));
+		manager_ph_control_block(bc,  HW_ECHOCAN_ON,  ec_arr, sizeof(ec_arr));
 	}
 #endif
 	}
@@ -4587,8 +4594,8 @@
 	manager_ph_control_block(bc, PIPELINE_CFG, "", 0);
 #else
 	if ( ! bc->ec_enable) {
-		cb_log(3, stack?stack->port:0, "Sending Control ECHOCAN_OFF\n");
-		manager_ph_control(bc,  ECHOCAN_OFF, 0);
+		cb_log(3, stack?stack->port:0, "Sending Control HW_ECHOCAN_OFF\n");
+		manager_ph_control(bc,  HW_ECHOCAN_OFF, 0);
 	}
 #endif
 }
diff -Naur asterisk-1.4.42_original/codecs/Makefile asterisk-1.4.42_switchfin/codecs/Makefile
--- asterisk-1.4.42_original/codecs/Makefile	2009-07-21 10:04:44.000000000 -0300
+++ asterisk-1.4.42_switchfin/codecs/Makefile	2011-09-05 14:26:26.000000000 -0300
@@ -45,6 +45,7 @@
 	$(MAKE) -C gsm clean
 	$(MAKE) -C lpc10 clean
 	$(MAKE) -C ilbc clean
+	$(MAKE) -C g722 clean
 
 gsm/lib/libgsm.a:
 	@mkdir -p gsm/lib
@@ -59,3 +60,13 @@
 	@$(MAKE) -C ilbc all _ASTCFLAGS="$(filter-out -Wmissing-prototypes -Wmissing-declarations,$(_ASTCFLAGS)) $(AST_NO_STRICT_OVERFLOW)"
 
 $(if $(filter codec_ilbc,$(EMBEDDED_MODS)),modules.link,codec_ilbc.so): $(LIBILBC)
+
+LIBG722:=g722/libg722.a
+$(LIBG722):
+	@$(MAKE) -C g722 all
+
+$(if $(filter codec_g722,$(EMBEDDED_MODS)),modules.link,codec_g722.so): $(LIBG722)
+
+$(if $(filter codec_g729,$(EMBEDDED_MODS)),modules.link,codec_g729.so):
+	$(CC) -o codec_g729.so -shared $(ASTLDFLAGS)  codec_g729.o $(ASTTOPDIR)/../blackfin-linux-dist/lib/libbfgdots/g729/src.fdpic/partial_local.o
+
diff -Naur asterisk-1.4.42_original/configure asterisk-1.4.42_switchfin/configure
--- asterisk-1.4.42_original/configure	2011-05-02 15:25:07.000000000 -0300
+++ asterisk-1.4.42_switchfin/configure	2011-09-05 14:33:06.000000000 -0300
@@ -10941,8 +10941,8 @@
 fi
 if test "x$ac_cv_func_fork_works" = xcross; then
   case $host in
-    *-*-amigaos* | *-*-msdosdjgpp* | *-*-uclinux* )
-      # Override, as these systems have only a dummy fork() stub
+    *-*-amigaos* | *-*-msdosdjgpp* | *-*-uclinux* | *-*-linux-uclibc* | bfin-*-* )
+     # Override, as these systems have only a dummy fork() stub
       ac_cv_func_fork_works=no
       ;;
     *)
diff -Naur asterisk-1.4.42_original/include/asterisk/audiohook.h asterisk-1.4.42_switchfin/include/asterisk/audiohook.h
--- asterisk-1.4.42_original/include/asterisk/audiohook.h	2010-07-27 17:33:40.000000000 -0300
+++ asterisk-1.4.42_switchfin/include/asterisk/audiohook.h	2011-09-05 14:36:51.000000000 -0300
@@ -212,6 +212,28 @@
  */
 void ast_audiohook_trigger_wait(struct ast_audiohook *audiohook);
 
+/*!
+  \brief Find out how many audiohooks from  a certain source exist on a given channel, regardless of status.
+  \param chan The channel on which to find the spies 
+  \param source The audiohook's source
+  \param type The type of audiohook 
+  \return Return the number of audiohooks which are from the source specified
+
+  Note: Function performs nlocking.
+*/
+int ast_channel_audiohook_count_by_source(struct ast_channel *chan, const char *source, enum ast_audiohook_type type);
+
+/*!
+  \brief Find out how many spies of a certain type exist on a given channel, and are in state running.
+  \param chan The channel on which to find the spies
+  \param source The source of the audiohook
+  \param type The type of spy to look for
+  \return Return the number of running audiohooks which are from the source specified
+
+  Note: Function performs no locking.
+*/
+int ast_channel_audiohook_count_by_source_running(struct ast_channel *chan, const char *source, enum ast_audiohook_type type);
+    
 /*! \brief Lock an audiohook
  * \param ah Audiohook structure
  */
diff -Naur asterisk-1.4.42_original/include/asterisk/channel.h asterisk-1.4.42_switchfin/include/asterisk/channel.h
--- asterisk-1.4.42_original/include/asterisk/channel.h	2011-01-24 18:32:21.000000000 -0200
+++ asterisk-1.4.42_switchfin/include/asterisk/channel.h	2011-09-05 14:38:44.000000000 -0300
@@ -551,6 +551,7 @@
 	AST_FEATURE_PARKCALL =     (1 << 5),
 	AST_FEATURE_NO_H_EXTEN =   (1 << 6),
 	AST_FEATURE_WARNING_ACTIVE = (1 << 7),
+	AST_FEATURE_AUTOMIXMON =     (1 << 8),
 };
 
 struct ast_bridge_config {
diff -Naur asterisk-1.4.42_original/main/audiohook.c asterisk-1.4.42_switchfin/main/audiohook.c
--- asterisk-1.4.42_original/main/audiohook.c	2010-07-27 17:33:40.000000000 -0300
+++ asterisk-1.4.42_switchfin/main/audiohook.c	2011-09-05 14:42:37.000000000 -0300
@@ -770,3 +770,84 @@
 	
 	return;
 }
+
+
+/* Count number of channel audiohooks by type, regardless of type */
+int ast_channel_audiohook_count_by_source(struct ast_channel *chan, const char *source, enum ast_audiohook_type type)
+{
+	int count = 0;
+	struct ast_audiohook *ah = NULL;
+
+	if (!chan->audiohooks)
+		return -1;
+
+	switch (type) {
+		case AST_AUDIOHOOK_TYPE_SPY:
+			AST_LIST_TRAVERSE_SAFE_BEGIN(&chan->audiohooks->spy_list, ah, list) {
+				if (!strcmp(ah->source, source)) {
+					count++;
+				}
+			}
+			AST_LIST_TRAVERSE_SAFE_END;
+			break;
+		case AST_AUDIOHOOK_TYPE_WHISPER:
+			AST_LIST_TRAVERSE_SAFE_BEGIN(&chan->audiohooks->whisper_list, ah, list) {
+				if (!strcmp(ah->source, source)) {
+					count++;
+				}
+			}
+			AST_LIST_TRAVERSE_SAFE_END;
+			break;
+		case AST_AUDIOHOOK_TYPE_MANIPULATE:
+			AST_LIST_TRAVERSE_SAFE_BEGIN(&chan->audiohooks->manipulate_list, ah, list) {
+				if (!strcmp(ah->source, source)) {
+					count++;
+				}
+			}
+			AST_LIST_TRAVERSE_SAFE_END;
+			break;
+		default:
+			ast_log(LOG_DEBUG, "Invalid audiohook type supplied, (%d)\n", type);
+			return -1;
+	}
+
+	return count;
+}
+
+/* Count number of channel audiohooks by type that are running */
+int ast_channel_audiohook_count_by_source_running(struct ast_channel *chan, const char *source, enum ast_audiohook_type type)
+{
+	int count = 0;
+	struct ast_audiohook *ah = NULL;
+	if (!chan->audiohooks)
+		return -1;
+
+	switch (type) {
+		case AST_AUDIOHOOK_TYPE_SPY:
+			AST_LIST_TRAVERSE_SAFE_BEGIN(&chan->audiohooks->spy_list, ah, list) {
+				if ((!strcmp(ah->source, source)) && (ah->status == AST_AUDIOHOOK_STATUS_RUNNING))
+					count++;
+			}
+			AST_LIST_TRAVERSE_SAFE_END;
+			break;
+		case AST_AUDIOHOOK_TYPE_WHISPER:
+			AST_LIST_TRAVERSE_SAFE_BEGIN(&chan->audiohooks->whisper_list, ah, list) {
+				if ((!strcmp(ah->source, source)) && (ah->status == AST_AUDIOHOOK_STATUS_RUNNING))
+					count++;
+			}
+			AST_LIST_TRAVERSE_SAFE_END;
+			break;
+		case AST_AUDIOHOOK_TYPE_MANIPULATE:
+			AST_LIST_TRAVERSE_SAFE_BEGIN(&chan->audiohooks->manipulate_list, ah, list) {
+				if ((!strcmp(ah->source, source)) && (ah->status == AST_AUDIOHOOK_STATUS_RUNNING))
+					count++;
+			}
+			AST_LIST_TRAVERSE_SAFE_END;
+			break;
+		default:
+			ast_log(LOG_DEBUG, "Invalid audiohook type supplied, (%d)\n", type);
+			return -1;
+	}
+	return count;
+}
+
diff -Naur asterisk-1.4.42_original/main/callerid.c asterisk-1.4.42_switchfin/main/callerid.c
--- asterisk-1.4.42_original/main/callerid.c	2011-03-14 13:38:24.000000000 -0300
+++ asterisk-1.4.42_switchfin/main/callerid.c	2011-09-05 15:25:21.000000000 -0300
@@ -45,7 +45,17 @@
 #include "asterisk/options.h"
 #include "asterisk/utils.h"
 
+#ifdef USE_SPANDSP_CALLERID
+#define SPANDSP_EXPOSE_INTERNAL_STRUCTURES
+#include <spandsp.h>
+#endif
+
 struct callerid_state {
+#ifdef USE_SPANDSP_CALLERID
+	adsi_rx_state_t adsi;
+	char adsi_output[256];
+	int  adsi_len;
+#endif
 	fsk_data fskd;
 	char rawdata[256];
 	short oldstuff[160];
@@ -61,6 +71,7 @@
 
 	int skipflag; 
 	unsigned short crc;
+	FILE* fpdebug;
 };
 
 
@@ -77,6 +88,29 @@
 
 #define AST_CALLERID_UNKNOWN	"<unknown>"
 
+#ifdef USE_SPANDSP_CALLERID
+void cid_put_msg_func_t(void *user_data, const uint8_t *msg, int len)
+{
+	/*given the nature of calling adsi_rx for each sample, we'll always
+	* only have one byte at a time here */
+	struct callerid_state *cid = (struct callerid_state *)user_data;
+	cid->adsi_len = len;
+	memcpy(cid->adsi_output,msg,len > sizeof(cid->adsi_output) ? sizeof(cid->adsi_output) : len);
+}
+
+int fsk_serie_spandsp(struct callerid_state *cid, short *buffer, int *len)
+{
+
+	cid->adsi_len = 0;
+	adsi_rx(&cid->adsi,buffer,*len);
+	*len = 0;
+	if (cid->adsi_len >= 0) {
+		return 1;
+	}
+	return 0;
+}
+#endif
+
 static inline void gen_tones(unsigned char *buf, int len, int codec, float ddr1, float ddi1, float ddr2, float ddi2, float *cr1, float *ci1, float *cr2, float *ci2)
 {
 	int x;
@@ -134,6 +168,13 @@
 	struct callerid_state *cid;
 
 	if ((cid = ast_calloc(1, sizeof(*cid)))) {
+#ifdef USE_SPANDSP_CALLERID
+		adsi_rx_init(&cid->adsi,
+				(cid_signalling == 2) ? ADSI_STANDARD_CLIP : ADSI_STANDARD_CLASS,
+				cid_put_msg_func_t,
+				cid);
+#endif
+
 		cid->fskd.spb = 7.0;          	/* 1200 baud */
 		/* cid->fskd.hdlc = 0; */     	/* Async */
 		cid->fskd.nbit = 8;           	/* 8 bits */
@@ -559,7 +600,11 @@
 		buf[x+cid->oldlen/2] = AST_XLAW(ubuf[x]);
 	while(mylen >= 160) {
 		olen = mylen;
+#ifdef USE_SPANDSP_CALLERID
+		res = fsk_serie_spandsp(cid, buf, &mylen);
+#else
 		res = fsk_serie(&cid->fskd, buf, &mylen, &b);
+#endif
 		if (mylen < 0) {
 			ast_log(LOG_ERROR, "No start bit found in fsk data.\n");
 			free(obuf);
@@ -572,6 +617,14 @@
 			return -1;
 		}
 		if (res == 1) {
+#ifdef USE_SPANDSP_CALLERID
+			int index;
+			cid->sawflag = 2;
+			for (index = 0;index < cid->adsi_len;index++)
+			{
+				b = cid->adsi_output[index] & 0x00ff;
+#endif
+			/* Ignore invalid bytes */
 			if (b > 0xff) {
 				if (cid->sawflag != 5) {
 					/* Ignore invalid bytes */
@@ -619,6 +672,7 @@
 				if (!cid->len) {
 					cid->rawdata[cid->pos] = '\0';
 					cid->sawflag = 5;
+#ifndef USE_SPANDSP_CALLERID
 				}
 				break;
 			case 5: /* Check checksum */
@@ -628,7 +682,7 @@
 					cid->sawflag = 0;
 					break;
 				}
-		
+#endif		
 				cid->number[0] = '\0';
 				cid->name[0] = '\0';
 				/* If we get this far we're fine.  */
@@ -705,10 +759,16 @@
 				}
 				free(obuf);
 				return 1;
+#ifdef USE_SPANDSP_CALLERID
+                               }
+#endif
 				break;
 			default:
 				ast_log(LOG_ERROR, "Dunno what to do with a digit in sawflag %d\n", cid->sawflag);
 			}
+#ifdef USE_SPANDSP_CALLERID
+		} /*for*/
+#endif
 		}
 	}
 	if (mylen) {
diff -Naur asterisk-1.4.42_original/main/dsp.c asterisk-1.4.42_switchfin/main/dsp.c
--- asterisk-1.4.42_original/main/dsp.c	2010-05-19 03:32:27.000000000 -0300
+++ asterisk-1.4.42_switchfin/main/dsp.c	2011-09-05 16:00:46.000000000 -0300
@@ -60,6 +60,27 @@
 #include "asterisk/alaw.h"
 #include "asterisk/utils.h"
 
+unsigned int cycles(void);
+
+#ifdef __BFIN__
+unsigned int cycles() {
+  int ret;
+
+   __asm__ __volatile__
+   (
+   "%0 = CYCLES;\n\t"
+   : "=&d" (ret)
+   :
+   : "R1"
+   );
+
+   return ret;
+}
+#else
+unsigned int cycles() {}
+#endif
+int dsp_sample;
+
 /*! Number of goertzels for progress detect */
 enum gsamp_size {
 	GSAMP_SIZE_NA = 183,			/*!< North America - 350, 440, 480, 620, 950, 1400, 1800 Hz */
@@ -132,7 +153,7 @@
 /*! All THRESH_XXX values are in GSAMP_SIZE chunks (us = 22ms) */
 enum gsamp_thresh {
 	THRESH_RING = 8,        	/*!< Need at least 150ms ring to accept */
-	THRESH_TALK = 2,        	/*!< Talk detection does not work continuously */
+	THRESH_TALK = 4,        	/*!< Talk detection does not work continuously */
 	THRESH_BUSY = 4,        	/*!< Need at least 80ms to accept */
 	THRESH_CONGESTION = 4,  	/*!< Need at least 80ms to accept */
 	THRESH_HANGUP = 60,     	/*!< Need at least 1300ms to accept hangup */
@@ -194,6 +215,9 @@
 	float v2;
 	float v3;
 	float fac;
+	int16_t v2_fix;
+	int16_t v3_fix;
+	int16_t fac_fix;
 #ifndef OLD_DSP_ROUTINES
 	int samples;
 #endif	
@@ -293,14 +317,28 @@
 static char bell_mf_positions[] = "1247C-358A--69*---0B----#";
 #endif
 
+#define AMP_SCALE 8
+#define FAC_SCALE 14
+
+extern int dsp_sample;
+
 static inline void goertzel_sample(goertzel_state_t *s, short sample)
 {
+#ifdef __FIXED_PT__
+	int16_t v1_fix;
+	int     mpy;
+	v1_fix = s->v2_fix;
+	s->v2_fix = s->v3_fix;
+	mpy = (int16_t)( ((int)s->fac_fix * (int)s->v2_fix) >> FAC_SCALE );
+	s->v3_fix = mpy - v1_fix + (sample>>AMP_SCALE);
+#else
 	float v1;
 	float fsamp  = sample;
 	
 	v1 = s->v2;
 	s->v2 = s->v3;
 	s->v3 = s->fac * s->v2 - v1 + fsamp;
+#endif
 }
 
 static inline void goertzel_update(goertzel_state_t *s, short *samps, int count)
@@ -314,13 +352,19 @@
 
 static inline float goertzel_result(goertzel_state_t *s)
 {
+#ifdef __FIXED_PT__
+	s->v2 = (float)s->v2_fix * (1<<AMP_SCALE);
+	s->v3 = (float)s->v3_fix * (1<<AMP_SCALE);
+#endif
 	return s->v3 * s->v3 + s->v2 * s->v2 - s->v2 * s->v3 * s->fac;
 }
 
 static inline void goertzel_init(goertzel_state_t *s, float freq, int samples)
 {
 	s->v2 = s->v3 = 0.0;
+	s->v2_fix = s->v3_fix = 0;
 	s->fac = 2.0 * cos(2.0 * M_PI * (freq / 8000.0));
+	s->fac_fix = (int16_t)(s->fac*(1<<FAC_SCALE) + 0.5);
 #ifndef OLD_DSP_ROUTINES
 	s->samples = samples;
 #endif
@@ -329,6 +373,7 @@
 static inline void goertzel_reset(goertzel_state_t *s)
 {
 	s->v2 = s->v3 = 0.0;
+	s->v2_fix = s->v3_fix = 0;
 }
 
 struct ast_dsp {
@@ -436,15 +481,14 @@
 	float fax_energy_2nd;
 #endif	
 #endif /* FAX_DETECT */
-	float famp;
-	float v1;
 	int i;
 	int j;
 	int sample;
 	int best_row;
 	int best_col;
 	int hit;
-	int limit;
+	int limit,before;
+	before = cycles();
 
 	hit = 0;
 	for (sample = 0;  sample < samples;  sample = limit) {
@@ -456,6 +500,20 @@
 #if defined(USE_3DNOW)
 		_dtmf_goertzel_update (s->row_out, amp + sample, limit - sample);
 		_dtmf_goertzel_update (s->col_out, amp + sample, limit - sample);
+#elif defined(__FIXED_PT__)
+	for(j=0; j<4; j++) {
+		goertzel_update(&s->row_out[j], amp + sample, limit - sample);
+		goertzel_update(&s->col_out[j], amp + sample, limit - sample);
+	}
+	{
+		int acc;
+
+		acc = 0;
+		for (j = sample;  j < limit;  j++) {
+			acc += (amp[j] >> AMP_SCALE)*(amp[j] >> AMP_SCALE);
+		}
+		s->energy += (float)acc * ((float)(1<<AMP_SCALE)) * ((float)(1<<AMP_SCALE));
+	}
 #ifdef OLD_DSP_ROUTINES
 		_dtmf_goertzel_update (s->row_out2nd, amp + sample, limit2 - sample);
 		_dtmf_goertzel_update (s->col_out2nd, amp + sample, limit2 - sample);
@@ -1032,7 +1090,7 @@
 	/* Amplify ignored stuff */
 	i2 *= TONE_THRESH;
 	i1 *= TONE_THRESH;
-	e *= TONE_THRESH;
+	e *= TONE_THRESH/2;
 	/* Check first tone */
 	if ((p1 < i1) || (p1 < i2) || (p1 < e))
 		return 0;
@@ -1082,10 +1140,17 @@
 			pass = dsp->gsamp_size - dsp->gsamps;
 		}
 		for (x = 0; x < pass; x++) {
+			int acc = 0;
 			for (y = 0; y < dsp->freqcount; y++) {
 				goertzel_sample(&dsp->freqs[y], s[x]);
+#ifdef __FIXED_PT__
+				acc += (s[x] >> AMP_SCALE)* (s[x] >> AMP_SCALE);
+			}
+			dsp->genergy += (float)acc * ((float)(1<<AMP_SCALE)) * ((float)(1<<AMP_SCALE));
+#else
 			}
 			dsp->genergy += s[x] * s[x];
+#endif
 		}
 		s += pass;
 		dsp->gsamps += pass;
@@ -1496,6 +1561,8 @@
 		dsp->display_inband_dtmf_warning = 0;
 		return af;
 	}
+#define TMP_DR
+#ifdef TMP_DR
 	silence = __ast_dsp_silence(dsp, shortdata, len, NULL);
 	if ((dsp->features & DSP_FEATURE_SILENCE_SUPPRESS) && silence) {
 		memset(&dsp->f, 0, sizeof(dsp->f));
@@ -1628,6 +1695,7 @@
 			}
 		}
 	}
+#endif
 	FIX_INF(af);
 	return af;
 }
diff -Naur asterisk-1.4.42_original/main/frame.c asterisk-1.4.42_switchfin/main/frame.c
--- asterisk-1.4.42_original/main/frame.c	2010-06-11 15:23:05.000000000 -0300
+++ asterisk-1.4.42_switchfin/main/frame.c	2011-09-05 16:04:00.000000000 -0300
@@ -110,7 +110,7 @@
 	{ 1, AST_FORMAT_SLINEAR, "slin", "16 bit Signed Linear PCM", 160, 10, 70, 10, 20, AST_SMOOTHER_FLAG_BE },	/*!< 7 */
 	{ 1, AST_FORMAT_LPC10, "lpc10", "LPC10", 7, 20, 20, 20, 20 },		/*!<  8: codec_lpc10.c */ 
 	{ 1, AST_FORMAT_G729A, "g729", "G.729A", 10, 10, 230, 10, 20, AST_SMOOTHER_FLAG_G729 },	/*!<  9: Binary commercial distribution */
-	{ 1, AST_FORMAT_SPEEX, "speex", "SpeeX", 10, 10, 60, 10, 20 },		/*!< 10: codec_speex.c */
+	{ 1, AST_FORMAT_SPEEX, "speex", "SpeeX", 38, 20, 300, 20, 20 },         /*!< 10: codec_speex.c */
 	{ 1, AST_FORMAT_ILBC, "ilbc", "iLBC", 50, 30, 30, 30, 30 },		/*!< 11: codec_ilbc.c */ /* inc=30ms - workaround */
 	{ 1, AST_FORMAT_G726_AAL2, "g726aal2", "G.726 AAL2", 40, 10, 300, 10, 20 },	/*!<  12: codec_g726.c */
 	{ 1, AST_FORMAT_G722, "g722", "G722"},					/*!< 13 */
@@ -1492,7 +1492,9 @@
 	int samples=0;
 	switch(f->subclass) {
 	case AST_FORMAT_SPEEX:
-		samples = speex_samples(f->data, f->datalen);
+		/* DR: hard coded for quality=8 mode.
+		300 bits (38 bytes) converted to 160 samples */
+		samples = 160 * (f->datalen / 38);
 		break;
 	case AST_FORMAT_G723_1:
                 samples = g723_samples(f->data, f->datalen);
diff -Naur asterisk-1.4.42_original/main/loader.c asterisk-1.4.42_switchfin/main/loader.c
--- asterisk-1.4.42_original/main/loader.c	2010-07-09 15:23:23.000000000 -0300
+++ asterisk-1.4.42_switchfin/main/loader.c	2011-09-05 16:05:51.000000000 -0300
@@ -660,6 +660,13 @@
 		ast_verbose("The previous reload command didn't finish yet\n");
 		return -1;	/* reload already in progress */
 	}
+
+        if (ast_lastreloadtime && time(NULL) - ast_lastreloadtime < 5) {
+        	ast_verbose("The previous reload was less than 5 seconds ago.\n");
+        	ast_mutex_unlock(&reloadlock);
+        	return -1;
+        }
+
 	ast_lastreloadtime = time(NULL);
 
 	/* Call "predefined" reload here first */
diff -Naur asterisk-1.4.42_original/main/manager.c asterisk-1.4.42_switchfin/main/manager.c
--- asterisk-1.4.42_original/main/manager.c	2011-06-15 12:15:30.000000000 -0300
+++ asterisk-1.4.42_switchfin/main/manager.c	2011-09-05 16:39:10.000000000 -0300
@@ -1191,7 +1191,7 @@
 		astman_send_error(s, m, "Filename not specified");
 		return 0;
 	}
-	if (!(cfg = ast_config_load_with_comments(fn))) {
+	if (!(cfg = ast_config_load(fn))) {	
 		astman_send_error(s, m, "Config file not found");
 		return 0;
 	}
@@ -1301,7 +1301,7 @@
 		astman_send_error(s, m, "Filename not specified");
 		return 0;
 	}
-	if (!(cfg = ast_config_load_with_comments(sfn))) {
+	if (!(cfg = ast_config_load(sfn))) {
 		astman_send_error(s, m, "Config file not found");
 		return 0;
 	}
@@ -3002,7 +3002,7 @@
 			}
 
 			if (res == 1 && (l = lseek(ss.fd, 0, SEEK_END)) > 0) {
-				if (MAP_FAILED == (buf = mmap(NULL, l, PROT_READ | PROT_WRITE, MAP_SHARED, ss.fd, 0))) {
+				if (MAP_FAILED == (buf = mmap(NULL, l, PROT_READ | PROT_WRITE, MAP_PRIVATE, ss.fd, 0))) {
 					ast_log(LOG_WARNING, "mmap failed.  Manager request output was not processed\n");
 				} else {
 					char *tmpbuf;
diff -Naur asterisk-1.4.42_original/pbx/Makefile asterisk-1.4.42_switchfin/pbx/Makefile
--- asterisk-1.4.42_original/pbx/Makefile	2010-05-11 16:55:42.000000000 -0300
+++ asterisk-1.4.42_switchfin/pbx/Makefile	2011-09-05 16:10:16.000000000 -0300
@@ -73,3 +73,7 @@
 $(if $(filter pbx_dundi,$(EMBEDDED_MODS)),modules.link,pbx_dundi.so): dundi-parser.o
 
 pbx_gtkconsole.o: _ASTCFLAGS+=-Wno-strict-prototypes
+
+pbx_lua.so:
+	$(CC) -o pbx_lua.so -shared  $(ASTLDFLAGS) pbx_lua.o $(wildcard $(ASTTOPDIR)/../uClinux-dist/user/lua/lua-5.1.4/src/*[!lua].o)
+
diff -Naur asterisk-1.4.42_original/res/res_agi.c asterisk-1.4.42_switchfin/res/res_agi.c
--- asterisk-1.4.42_original/res/res_agi.c	2011-04-22 11:34:23.000000000 -0300
+++ asterisk-1.4.42_switchfin/res/res_agi.c	2011-09-05 16:11:41.000000000 -0300
@@ -308,7 +308,7 @@
 	/* Block SIGHUP during the fork - prevents a race */
 	sigfillset(&signal_set);
 	pthread_sigmask(SIG_BLOCK, &signal_set, &old_set);
-	pid = fork();
+	pid = vfork();
 	if (pid < 0) {
 		ast_log(LOG_WARNING, "Failed to fork(): %s\n", strerror(errno));
 		pthread_sigmask(SIG_SETMASK, &old_set, NULL);
diff -Naur asterisk-1.4.42_original/res/res_features.c asterisk-1.4.42_switchfin/res/res_features.c
--- asterisk-1.4.42_original/res/res_features.c	2011-06-23 15:16:52.000000000 -0300
+++ asterisk-1.4.42_switchfin/res/res_features.c	2011-09-06 09:52:11.000000000 -0300
@@ -64,6 +64,7 @@
 #include "asterisk/adsi.h"
 #include "asterisk/devicestate.h"
 #include "asterisk/monitor.h"
+#include "asterisk/audiohook.h"
 #include "asterisk/global_datastores.h"
 
 /*
@@ -161,6 +162,7 @@
 static int parkedcallreparking;                            /*!< Who can PARKCALL after picking up a parked call */
 static int parkedcallhangup;                               /*!< Who can DISCONNECT after picking up a parked call */
 static int parkedcallrecording;                            /*!< Who can AUTOMON after picking up a parked call */
+static int parkedcallmixrecording;                         /*!< Who can AUTOMIXMON after picking up a parked call */
 
 static char courtesytone[256];                             /*!< Courtesy tone */
 static int parkedplay = 0;                                 /*!< Who to play the courtesy tone to */
@@ -206,6 +208,12 @@
 static struct ast_app *monitor_app = NULL;
 static int monitor_ok = 1;
 
+static struct ast_app *mixmonitor_app = NULL;
+static int mixmonitor_ok = 1;
+
+static struct ast_app *stopmixmonitor_app = NULL;
+static int stopmixmonitor_ok = 1;
+
 struct parkeduser {
 	struct ast_channel *chan;                   /*!< Parking channel */
 	struct timeval start;                       /*!< Time the parking started */
@@ -927,6 +935,122 @@
 	return -1;
 }
 
+static int builtin_automixmonitor(struct ast_channel *chan, struct ast_channel *peer, struct ast_bridge_config *config, char *code, int sense, void *data)
+{
+	char *caller_chan_id = NULL, *callee_chan_id = NULL, *args = NULL, *touch_filename = NULL, *outtime = NULL;
+	int x = 0;
+	size_t len;
+	time_t t;
+	struct ast_channel *caller_chan, *callee_chan;
+	const char *mixmonitor_spy_type = "MixMonitor";
+	int count = 0;
+
+	if (!mixmonitor_ok) {
+		ast_log(LOG_ERROR,"Cannot record the call. The mixmonitor application is disabled.\n");
+		return -1;
+	}
+
+	if (!(mixmonitor_app = pbx_findapp("MixMonitor"))) {
+		mixmonitor_ok = 0;
+		ast_log(LOG_ERROR,"Cannot record the call. The mixmonitor application is disabled.\n");
+		return -1;
+	}
+
+	set_peers(&caller_chan, &callee_chan, peer, chan, sense);
+
+	if (!ast_strlen_zero(courtesytone)) {
+		if (ast_autoservice_start(callee_chan))
+			return -1;
+		if (ast_stream_and_wait(caller_chan, courtesytone, caller_chan->language, "")) {
+			ast_log(LOG_WARNING, "Failed to play courtesy tone!\n");
+			ast_autoservice_stop(callee_chan);
+			return -1;
+		}
+		if (ast_autoservice_stop(callee_chan))
+			return -1;
+	}
+
+	ast_channel_lock(callee_chan);
+	count = ast_channel_audiohook_count_by_source(callee_chan, mixmonitor_spy_type, AST_AUDIOHOOK_TYPE_SPY);
+	ast_channel_unlock(callee_chan);
+
+	// This means a mixmonitor is attached to the channel, running or not is unknown.
+	if (count > 0) {
+		
+		if (option_verbose > 3)
+			ast_verbose(VERBOSE_PREFIX_3 "User hit '%s' to stop recording call.\n", code);
+
+		//Make sure they are running
+		ast_channel_lock(callee_chan);
+		count = ast_channel_audiohook_count_by_source_running(callee_chan, mixmonitor_spy_type, AST_AUDIOHOOK_TYPE_SPY);
+		ast_channel_unlock(callee_chan);
+		if (count > 0) {
+			if (!stopmixmonitor_ok) {
+				ast_log(LOG_ERROR,"Cannot stop recording the call. The stopmixmonitor application is disabled.\n");
+				return -1;
+			}
+			if (!(stopmixmonitor_app = pbx_findapp("StopMixMonitor"))) {
+				stopmixmonitor_ok = 0;
+				ast_log(LOG_ERROR,"Cannot stop recording the call. The stopmixmonitor application is disabled.\n");
+				return -1;
+			} else {
+				pbx_exec(callee_chan, stopmixmonitor_app, "");
+				return FEATURE_RETURN_SUCCESS;
+			}
+		}
+		
+		ast_log(LOG_WARNING,"Stopped MixMonitors are attached to the channel.\n");	
+	}			
+
+	if (caller_chan && callee_chan) {
+		const char *touch_format = pbx_builtin_getvar_helper(caller_chan, "TOUCH_MIXMONITOR_FORMAT");
+		const char *touch_monitor = pbx_builtin_getvar_helper(caller_chan, "TOUCH_MIXMONITOR");
+
+		if (!touch_format)
+			touch_format = pbx_builtin_getvar_helper(callee_chan, "TOUCH_MIXMONITOR_FORMAT");
+
+		if (!touch_monitor)
+			touch_monitor = pbx_builtin_getvar_helper(callee_chan, "TOUCH_MIXMONITOR");
+
+		if (touch_monitor) {
+			len = strlen(touch_monitor) + 50;
+			args = alloca(len);
+			touch_filename = alloca(len);
+			snprintf(touch_filename, len, "%s", touch_monitor); 
+			snprintf(args, len, "%s.%s", touch_filename, (touch_format) ? touch_format : "wav");
+		} else {
+			t = time(NULL);
+			outtime = alloca(100);
+			caller_chan_id = ast_strdupa(S_OR(caller_chan->cid.cid_num, caller_chan->name));
+			callee_chan_id = ast_strdupa(S_OR(callee_chan->cid.cid_num, callee_chan->name));
+			strftime(outtime, 100, "%Y%m%d-%H%M%S", localtime(&t));
+			len = strlen(caller_chan_id) + strlen(callee_chan_id) + strlen(outtime) + 50;
+			args = alloca(len);
+			touch_filename = alloca(len);
+			snprintf(touch_filename, len, "%s-%s-%s", caller_chan_id, callee_chan_id, outtime);
+			snprintf(args, len, "%s.%s", touch_filename, S_OR(touch_format, "wav"));
+		}
+
+		for( x = 0; x < strlen(args); x++) {
+			if (args[x] == '/')
+				args[x] = '-';
+		}
+
+		if (option_verbose > 3)
+			ast_verbose(VERBOSE_PREFIX_3 "User hit '%s' to record call. filename: %s\n", code, touch_filename);
+
+		pbx_exec(callee_chan, mixmonitor_app, args);
+		pbx_builtin_setvar_helper(callee_chan, "TOUCH_MIXMONITOR_OUTPUT", touch_filename);
+		pbx_builtin_setvar_helper(caller_chan, "TOUCH_MIXMONITOR_OUTPUT", touch_filename);
+		return FEATURE_RETURN_SUCCESS;
+	
+	}
+
+	ast_log(LOG_NOTICE,"Cannot record the call. One or both channels have gone away.\n");
+	return -1;
+
+}
+
 static int builtin_disconnect(struct ast_channel *chan, struct ast_channel *peer, struct ast_bridge_config *config, char *code, int sense, void *data)
 {
 	if (option_verbose > 3)
@@ -1366,6 +1490,7 @@
 	{ AST_FEATURE_AUTOMON, "One Touch Monitor", "automon", "", "", builtin_automonitor, AST_FEATURE_FLAG_NEEDSDTMF, "" },
 	{ AST_FEATURE_DISCONNECT, "Disconnect Call", "disconnect", "*", "*", builtin_disconnect, AST_FEATURE_FLAG_NEEDSDTMF, "" },
 	{ AST_FEATURE_PARKCALL, "Park Call", "parkcall", "", "", builtin_parkcall, AST_FEATURE_FLAG_NEEDSDTMF, "" },
+	{ AST_FEATURE_AUTOMIXMON, "One Touch MixMonitor", "automixmon", "", "", builtin_automixmonitor, AST_FEATURE_FLAG_NEEDSDTMF, "" },
 };
 
 
@@ -3176,6 +3301,12 @@
 		if ((parkedcallrecording == AST_FEATURE_FLAG_BYCALLER) || (parkedcallrecording == AST_FEATURE_FLAG_BYBOTH)) {
 			ast_set_flag(&(config.features_caller), AST_FEATURE_AUTOMON);
 		}
+		if ((parkedcallmixrecording == AST_FEATURE_FLAG_BYCALLEE) || (parkedcallmixrecording == AST_FEATURE_FLAG_BYBOTH)) {
+			ast_set_flag(&(config.features_callee), AST_FEATURE_AUTOMIXMON);
+		}
+		if ((parkedcallmixrecording == AST_FEATURE_FLAG_BYCALLER) || (parkedcallmixrecording == AST_FEATURE_FLAG_BYBOTH)) {
+			ast_set_flag(&(config.features_caller), AST_FEATURE_AUTOMIXMON);
+		}
 		res = ast_bridge_call(chan, peer, &config);
 
 		pbx_builtin_setvar_helper(chan, "PARKEDCHANNEL", peer->name);
@@ -3493,6 +3624,7 @@
 	parkedcallreparking = 0;
 	parkedcallhangup = 0;
 	parkedcallrecording = 0;
+	parkedcallmixrecording = 0;
 
 	transferdigittimeout = DEFAULT_TRANSFER_DIGIT_TIMEOUT;
 	featuredigittimeout = DEFAULT_FEATURE_DIGIT_TIMEOUT;
@@ -3561,6 +3693,15 @@
 				parkedcallrecording = AST_FEATURE_FLAG_BYCALLEE;
 			else if (!strcasecmp(var->value, "both"))
 				parkedcallrecording = AST_FEATURE_FLAG_BYBOTH;
+		} else if (!strcasecmp(var->name, "parkedcallmixrecording")) {
+			if (!strcasecmp(var->value, "no"))
+				parkedcallmixrecording = 0;
+			else if (!strcasecmp(var->value, "caller"))
+				parkedcallmixrecording = AST_FEATURE_FLAG_BYCALLER;
+			else if (!strcasecmp(var->value, "callee"))
+				parkedcallmixrecording = AST_FEATURE_FLAG_BYCALLEE;
+			else if (!strcasecmp(var->value, "both"))
+				parkedcallmixrecording = AST_FEATURE_FLAG_BYBOTH;
 		} else if (!strcasecmp(var->name, "adsipark")) {
 			adsipark = ast_true(var->value);
 		} else if (!strcasecmp(var->name, "transferdigittimeout")) {
diff -Naur asterisk-1.4.42_original/utils/Makefile asterisk-1.4.42_switchfin/utils/Makefile
--- asterisk-1.4.42_original/utils/Makefile	2010-03-25 17:41:15.000000000 -0300
+++ asterisk-1.4.42_switchfin/utils/Makefile	2011-09-05 16:33:52.000000000 -0300
@@ -26,7 +26,7 @@
 #     changes are made to ast_expr2.y or ast_expr2.fl (or the corresponding .c files),
 #     as a regression test. Others (mere mortals?) need not bother, but they are
 #     more than welcome to play! The regression test itself is in expr2.testinput.
-ALL_UTILS:=astman smsq stereorize streamplayer aelparse muted
+ALL_UTILS:=astman smsq stereorize streamplayer aelparse
 UTILS:=$(ALL_UTILS)
 
 include $(ASTTOPDIR)/Makefile.rules
Index: asterisk/menuselect/menuselect_newt.c
===================================================================
--- asterisk/menuselect/menuselect_newt.c	(revision 904)
+++ asterisk/menuselect/menuselect_newt.c	(revision 906)
@@ -90,9 +90,9 @@
 {
 	char buffer[128] = { 0 };
 
-	struct depend *dep;
-	struct conflict *con;
-	struct use *uses;
+	struct reference *dep;
+	struct reference *con;
+	struct reference *uses;
 
 	reset_display();
 
@@ -119,6 +119,7 @@
 		strcpy(buffer, "");
 		AST_LIST_TRAVERSE(&mem->uses, uses, list) {
 			strncat(buffer, uses->displayname, sizeof(buffer) - strlen(buffer) - 1);
+			strncat(buffer, uses->member ? "(M)" : "(E)", sizeof(buffer) - strlen(buffer) - 1);
 			if (AST_LIST_NEXT(uses, list))
 				strncat(buffer, ", ", sizeof(buffer) - strlen(buffer) - 1);
 		}
Index: asterisk/menuselect/menuselect.c
===================================================================
--- asterisk/menuselect/menuselect.c	(revision 904)
+++ asterisk/menuselect/menuselect.c	(revision 906)
@@ -191,9 +191,9 @@
 /*! \brief Free a member structure and all of its members */
 static void free_member(struct member *mem)
 {
-	struct depend *dep;
-	struct conflict *cnf;
-	struct use *use;
+	struct reference *dep;
+	struct reference *cnf;
+	struct reference *use;
 
 	while ((dep = AST_LIST_REMOVE_HEAD(&mem->deps, list)))
 		free(dep);
@@ -210,9 +210,9 @@
 	FILE *f;
 	struct tree *tree;
 	struct member *mem;
-	struct depend *dep;
-	struct conflict *cnf;
-	struct use *use;
+	struct reference *dep;
+	struct reference *cnf;
+	struct reference *use;
 	mxml_node_t *cur;
 	mxml_node_t *cur2;
 	mxml_node_t *cur3;
@@ -345,27 +345,6 @@
 			     cur3 && cur3->child;
 			     cur3 = mxmlFindElement(cur3, cur2, "use", NULL, NULL, MXML_NO_DESCEND))
 			{
-#if !defined(HAVE_ATTRIBUTE_weak_import) && !defined(HAVE_ATTRIBUTE_weakref)
-				/* If the compiler won't support the functionality required for "use", then "use" -> "depend" */
-				if (!(dep = calloc(1, sizeof(*dep)))) {
-					free_member(mem);
-					return -1;
-				}
-				if ((tmp = mxmlElementGetAttr(cur3, "name"))) {
-					if (!strlen_zero(tmp)) {
-						dep->name = tmp;
-					}
-				}
-				if (!strlen_zero(cur3->child->value.opaque)) {
-					dep->displayname = cur3->child->value.opaque;
-					if (!dep->name) {
-						dep->name = dep->displayname;
-					}
-					AST_LIST_INSERT_TAIL(&mem->deps, dep, list);
-				} else {
-					free(dep);
-				}
-#else
 				if (!(use = calloc(1, sizeof(*use)))) {
 					free_member(mem);
 					return -1;
@@ -381,9 +360,9 @@
 						use->name = use->displayname;
 					}
 					AST_LIST_INSERT_TAIL(&mem->uses, use, list);
-				} else
+				} else {
 					free(use);
-#endif
+				}
 			}
 
 			if (add_member(mem, cat))
@@ -404,7 +383,7 @@
 	unsigned int result = 0;
 	struct category *cat;
 	struct member *mem;
-	struct depend *dep;
+	struct reference *dep;
 	struct dep_file *dep_file;
 	unsigned int changed, old_failure;
 
@@ -491,7 +470,7 @@
 	unsigned int result = 0;
 	struct category *cat;
 	struct member *mem;
-	struct conflict *cnf;
+	struct reference *cnf;
 	struct dep_file *dep_file;
 	unsigned int changed, old_failure;
 
@@ -661,10 +640,11 @@
 {
 	struct category *cat, *cat2;
 	struct member *mem, *mem2;
-	struct depend *dep;
-	struct conflict *cnf;
-	struct use *use;
+	struct reference *dep;
+	struct reference *cnf;
+	struct reference *use;
 
+	/* Traverse through each module's dependency list and determine whether each is another module */
 	AST_LIST_TRAVERSE(&categories, cat, list) {
 		AST_LIST_TRAVERSE(&cat->members, mem, list) {
 			AST_LIST_TRAVERSE(&mem->deps, dep, list) {
@@ -693,6 +673,7 @@
 		}
 	}
 
+	/* Traverse through each module's use list and determine whether each is another module */
 	AST_LIST_TRAVERSE(&categories, cat, list) {
 		AST_LIST_TRAVERSE(&cat->members, mem, list) {
 			AST_LIST_TRAVERSE(&mem->uses, use, list) {
@@ -721,7 +702,23 @@
 		}
 	}
 
+	/* If weak linking is not supported, move module uses which are other modules to the dependency list */
+#if !defined(HAVE_ATTRIBUTE_weak_import) && !defined(HAVE_ATTRIBUTE_weakref)
 	AST_LIST_TRAVERSE(&categories, cat, list) {
+		AST_LIST_TRAVERSE(&cat->members, mem, list) {
+			AST_LIST_TRAVERSE_SAFE_BEGIN(&mem->uses, use, list) {
+				if (use->member) {
+					AST_LIST_REMOVE_CURRENT(&mem->uses, list);
+					AST_LIST_INSERT_TAIL(&mem->deps, use, list);
+				}
+			}
+			AST_LIST_TRAVERSE_SAFE_END;
+		}
+	}
+#endif
+
+	/* Traverse through each category marked as exclusive and mark every member as conflicting with every other member */
+	AST_LIST_TRAVERSE(&categories, cat, list) {
 		if (!cat->exclusive)
 			continue;
 
@@ -740,6 +737,7 @@
 		}
 	}
 
+	/* Traverse through each category and determine whether named conflicts for each module are other modules */
 	AST_LIST_TRAVERSE(&categories, cat, list) {
 		AST_LIST_TRAVERSE(&cat->members, mem, list) {
 			AST_LIST_TRAVERSE(&mem->conflicts, cnf, list) {
@@ -825,7 +823,7 @@
 
 unsigned int enable_member(struct member *mem)
 {
-	struct depend *dep;
+	struct reference *dep;
 	unsigned int can_enable = 1;
 
 	AST_LIST_TRAVERSE(&mem->deps, dep, list) {
@@ -1062,8 +1060,8 @@
 	FILE *f;
 	struct category *cat;
 	struct member *mem;
-	struct depend *dep;
-	struct use *use;
+	struct reference *dep;
+	struct reference *use;
 	struct dep_file *dep_file;
 
 	if (!(f = fopen(output_makedeps, "w"))) {
@@ -1148,8 +1146,8 @@
 	FILE *f;
 	struct category *cat;
 	struct member *mem;
-	struct depend *dep;
-	struct use *use;
+	struct reference *dep;
+	struct reference *use;
 
 	if (!(f = fopen(output_makeopts, "w"))) {
 		fprintf(stderr, "Unable to open build configuration file (%s) for writing!\n", output_makeopts);
@@ -1284,8 +1282,8 @@
 #ifdef MENUSELECT_DEBUG
 	struct category *cat;
 	struct member *mem;
-	struct depend *dep;
-	struct conflict *cnf;
+	struct reference *dep;
+	struct reference *cnf;
 
 	AST_LIST_TRAVERSE(&categories, cat, list) {
 		fprintf(stderr, "Category: '%s'\n", cat->name);
@@ -1312,9 +1310,9 @@
 {
 	struct category *cat;
 	struct member *mem;
-	struct depend *dep;
-	struct conflict *cnf;
-	struct use *use;
+	struct reference *dep;
+	struct reference *cnf;
+	struct reference *use;
 
 	while ((cat = AST_LIST_REMOVE_HEAD(&categories, list))) {
 		while ((mem = AST_LIST_REMOVE_HEAD(&cat->members, list))) {
@@ -1404,8 +1402,8 @@
 	unsigned int insane = 0;
 	struct category *cat;
 	struct member *mem;
-	struct depend *dep;
-	struct use *use;
+	struct reference *dep;
+	struct reference *use;
 	struct dep_file *dep_file;
 	unsigned int dep_header_printed;
 	unsigned int group_header_printed;
Index: asterisk/menuselect/menuselect_gtk.c
===================================================================
--- asterisk/menuselect/menuselect_gtk.c	(revision 904)
+++ asterisk/menuselect/menuselect_gtk.c	(revision 906)
@@ -268,9 +268,9 @@
 			char dep_buf[64] = "";
 			char use_buf[64] = "";
 			char cnf_buf[64] = "";
-			struct depend *dep;
-			struct use *use;
-			struct conflict *cnf;
+			struct reference *dep;
+			struct reference *use;
+			struct reference *cnf;
 
 			AST_LIST_TRAVERSE(&mem->deps, dep, list) {
 				strncat(dep_buf, dep->displayname, sizeof(dep_buf) - strlen(dep_buf) - 1);
Index: asterisk/menuselect/menuselect.h
===================================================================
--- asterisk/menuselect/menuselect.h	(revision 904)
+++ asterisk/menuselect/menuselect.h	(revision 906)
@@ -34,41 +34,19 @@
 
 struct member;
 
-struct depend {
+struct reference {
 	/*! the name of the dependency */
 	const char *name;
 	/*! the display name of the dependency */
 	const char *displayname;
 	/*! if this dependency is a member, not an external object */
 	struct member *member;
+	/*! if this package was found */
+	unsigned char met:1;
 	/*! for linking */
-	AST_LIST_ENTRY(depend) list;
+	AST_LIST_ENTRY(reference) list;
 };
 
-struct conflict {
-	/*! the name of the conflict */
-	const char *name;
-	/*! the display name of the conflict */
-	const char *displayname;
-	/*! if this conflict is a member, not an external object */
-	const struct member *member;
-	/*! for linking */
-	AST_LIST_ENTRY(conflict) list;
-};
-
-struct use {
-	/*! the name of the used package */
-	const char *name;
-	/*! the display name of the used package */
-	const char *displayname;
-	/*! if this used package is a member, not an external object */
-	struct member *member;
-	/*! if this used package was found */
-	unsigned char met;
-	/*! for linking */
-	AST_LIST_ENTRY(use) list;
-};
-
 enum failure_types {
 	NO_FAILURE = 0,
 	SOFT_FAILURE = 1,
@@ -104,11 +82,11 @@
 	 * when explicitly set. */
 	unsigned int explicitly_enabled_only:1;
 	/*! dependencies of this module */
-	AST_LIST_HEAD_NOLOCK(, depend) deps;
+	AST_LIST_HEAD_NOLOCK(, reference) deps;
 	/*! conflicts of this module */
-	AST_LIST_HEAD_NOLOCK(, conflict) conflicts;
+	AST_LIST_HEAD_NOLOCK(, reference) conflicts;
 	/*! optional packages used by this module */
-	AST_LIST_HEAD_NOLOCK(, use) uses;
+	AST_LIST_HEAD_NOLOCK(, reference) uses;
 	/*! for making a list of modules */
 	AST_LIST_ENTRY(member) list;
 };
Index: asterisk/menuselect/menuselect_curses.c
===================================================================
--- asterisk/menuselect/menuselect_curses.c	(revision 904)
+++ asterisk/menuselect/menuselect_curses.c	(revision 906)
@@ -182,9 +182,9 @@
 static void display_mem_info(WINDOW *menu, struct member *mem, int start, int end)
 {
 	char buf[64];
-	struct depend *dep;
-	struct conflict *con;
-	struct use *use;
+	struct reference *dep;
+	struct reference *con;
+	struct reference *use;
 
 	wmove(menu, end - start + 2, max_x / 2 - 16);
 	wclrtoeol(menu);
Index: asterisk/menuselect/linkedlists.h
===================================================================
--- asterisk/menuselect/linkedlists.h	(revision 904)
+++ asterisk/menuselect/linkedlists.h	(revision 906)
@@ -222,14 +222,16 @@
   the list traversal (and without having to re-traverse the list to modify the
   previous entry, if any).
  */
-#define AST_LIST_REMOVE_CURRENT(head, field)						\
+#define AST_LIST_REMOVE_CURRENT(head, field) do {					\
+	__new_prev->field.next = NULL;							\
 	__new_prev = __list_prev;							\
 	if (__list_prev)								\
 		__list_prev->field.next = __list_next;					\
 	else										\
 		(head)->first = __list_next;						\
 	if (!__list_next)								\
-		(head)->last = __list_prev;
+		(head)->last = __list_prev;						\
+	} while (0)
 
 /*!
   \brief Inserts a list entry before the current entry during a traversal.
