--- asterisk/main/loader.c	2009-11-22 17:09:49.000000000 +0200
+++ asterisk/main/loader.c	2009-11-22 17:13:12.000000000 +0200
@@ -620,6 +620,13 @@
 		ast_verbose("The previous reload command didn't finish yet\n");
 		return -1;	/* reload already in progress */
 	}
+
+        if (ast_lastreloadtime && time(NULL) - ast_lastreloadtime < 5) {
+        	ast_verbose("The previous reload was less than 5 seconds ago.\n");
+        	ast_mutex_unlock(&reloadlock);
+        	return -1;
+        }
+
 	ast_lastreloadtime = time(NULL);
 
 	/* Call "predefined" reload here first */
--- asterisk/main/manager.c	2009-11-22 17:08:29.000000000 +0200
+++ asterisk/main/manager.c	2009-11-22 17:09:27.000000000 +0200
@@ -1176,7 +1176,7 @@
 		astman_send_error(s, m, "Filename not specified");
 		return 0;
 	}
-	if (!(cfg = ast_config_load_with_comments(fn))) {
+	if (!(cfg = ast_config_load(fn))) {
 		astman_send_error(s, m, "Config file not found");
 		return 0;
 	}
@@ -1286,7 +1286,7 @@
 		astman_send_error(s, m, "Filename not specified");
 		return 0;
 	}
-	if (!(cfg = ast_config_load_with_comments(sfn))) {
+	if (!(cfg = ast_config_load(sfn))) {
 		astman_send_error(s, m, "Config file not found");
 		return 0;
 	}
--- asterisk/utils/Makefile	2009-11-22 17:07:28.000000000 +0200
+++ asterisk/utils/Makefile	2009-11-22 17:08:01.000000000 +0200
@@ -26,7 +26,7 @@
 #     changes are made to ast_expr2.y or ast_expr2.fl (or the corresponding .c files),
 #     as a regression test. Others (mere mortals?) need not bother, but they are
 #     more than welcome to play! The regression test itself is in expr2.testinput.
-ALL_UTILS:=astman smsq stereorize streamplayer aelparse muted
+ALL_UTILS:=astman smsq stereorize streamplayer aelparse
 UTILS:=$(ALL_UTILS)
 
 include $(ASTTOPDIR)/Makefile.rules
--- asterisk/codecs/Makefile	2009-11-22 17:05:16.000000000 +0200
+++ asterisk/codecs/Makefile	2009-11-22 17:07:13.000000000 +0200
@@ -45,6 +45,7 @@
 	$(MAKE) -C gsm clean
 	$(MAKE) -C lpc10 clean
 	$(MAKE) -C ilbc clean
+	$(MAKE) -C g722 clean
 
 gsm/lib/libgsm.a:
 	@mkdir -p gsm/lib
@@ -59,3 +60,9 @@
 	@$(MAKE) -C ilbc all _ASTCFLAGS="$(filter-out -Wmissing-prototypes -Wmissing-declarations,$(_ASTCFLAGS)) $(AST_NO_STRICT_OVERFLOW)"
 
 $(if $(filter codec_ilbc,$(EMBEDDED_MODS)),modules.link,codec_ilbc.so): $(LIBILBC)
+
+LIBG722:=g722/libg722.a
+$(LIBG722):
+	@$(MAKE) -C g722 all
+
+$(if $(filter codec_g722,$(EMBEDDED_MODS)),modules.link,codec_g722.so): $(LIBG722)
--- asterisk/channels/chan_dahdi.c	2009-11-22 18:50:52.000000000 +0200
+++ asterisk/channels/chan_dahdi.c	2009-11-23 00:35:42.000000000 +0200
@@ -116,6 +116,8 @@
 };
 static struct ast_jb_conf global_jbconf;
 
+extern unsigned int cycles(void);
+
 #ifndef DAHDI_TONEDETECT
 /* Work around older code with no tone detect */
 #define DAHDI_EVENT_DTMFDOWN 0
@@ -883,6 +885,10 @@
 	int polarity;
 	/*! \brief DSP feature flags: DSP_FEATURE_xxx */
 	int dsp_features;
+	/*! \brief DR: stats for DSP execution */
+	int dsp_cycles_last;     
+	int dsp_cycles_worst;
+	int dsp_cycles_average;
 	/*! \brief DTMF digit in progress.  0 when no digit in progress. */
 	char begindigit;
 } *iflist = NULL, *ifend = NULL;
@@ -5069,6 +5075,7 @@
 	int index;
 	void *readbuf;
 	struct ast_frame *f;
+	int before;
 
 	while (ast_mutex_trylock(&p->lock)) {
 		DEADLOCK_AVOIDANCE(&ast->lock);
@@ -5321,8 +5328,17 @@
 		p->subs[index].f.datalen= 0;
 	}
 	if (p->dsp && (!p->ignoredtmf || p->callwaitcas || p->busydetect  || p->callprogress) && !index) {
-		/* Perform busy detection. etc on the dahdi line */
+		/* Perform busy detection. etc on the dahdi line */	
+		/* DR: measure some execution stats around this as it is a
+		computationally intensive part of the real time code */
+		before = cycles();
 		f = ast_dsp_process(ast, p->dsp, &p->subs[index].f);
+		p->dsp_cycles_last = cycles() - before;
+		if (p->dsp_cycles_last > p->dsp_cycles_worst) {
+			p->dsp_cycles_worst = p->dsp_cycles_last;
+		}
+		p->dsp_cycles_average = (int)(0.1*(float)p->dsp_cycles_last +
+					      0.9*(float)p->dsp_cycles_average);
 		if (f) {
 			if ((f->frametype == AST_FRAME_CONTROL) && (f->subclass == AST_CONTROL_BUSY)) {
 				if ((ast->_state == AST_STATE_UP) && !p->outgoing) {
@@ -9199,6 +9215,9 @@
 								pri->pvts[x]->owner->_softhangup |= AST_SOFTHANGUP_DEV;
 							ast_mutex_unlock(&pri->pvts[x]->lock);
 						}
+						pri->pvts[x]->dsp_cycles_last = 0;
+						pri->pvts[x]->dsp_cycles_worst = 0;
+						pri->pvts[x]->dsp_cycles_average = 0;				
 				}
 				break;
 			case PRI_EVENT_KEYPAD_DIGIT:
@@ -10576,6 +10595,7 @@
 	return RESULT_SUCCESS;
 }
 
+extern int dsp_sample;
 static int dahdi_show_channels(int fd, int argc, char **argv)
 {
 #define FORMAT "%7s %-10.10s %-15.15s %-10.10s %-20.20s\n"
@@ -10716,6 +10736,8 @@
 			ast_cli(fd, "Fax Handled: %s\n", tmp->faxhandled ? "yes" : "no");
 			ast_cli(fd, "Pulse phone: %s\n", tmp->pulsedial ? "yes" : "no");
 			ast_cli(fd, "Echo Cancellation: %d taps%s, currently %s\n", tmp->echocancel, tmp->echocanbridged ? "" : " unless TDM bridged", tmp->echocanon ? "ON" : "OFF");
+			ast_cli(fd, "DSP cycles last: %d worst: %d average: %d sample: %d\n",
+				tmp->dsp_cycles_last, tmp->dsp_cycles_worst, tmp->dsp_cycles_average, dsp_sample);			
 			if (tmp->master)
 				ast_cli(fd, "Master Channel: %d\n", tmp->master->channel);
 			for (x = 0; x < MAX_SLAVES; x++) {
--- asterisk/main/dsp.c	2009-11-22 17:14:04.000000000 +0200
+++ asterisk/main/dsp.c	2009-11-23 00:48:43.000000000 +0200
@@ -60,6 +60,27 @@
 #include "asterisk/alaw.h"
 #include "asterisk/utils.h"
 
+unsigned int cycles(void);
+
+#ifdef __BLACKFIN__
+unsigned int cycles() {
+  int ret;
+
+   __asm__ __volatile__
+   (
+   "%0 = CYCLES;\n\t"
+   : "=&d" (ret)
+   :
+   : "R1"
+   );
+
+   return ret;
+}
+#else
+unsigned int cycles() {}
+#endif
+int dsp_sample;
+
 /*! Number of goertzels for progress detect */
 enum gsamp_size {
 	GSAMP_SIZE_NA = 183,			/*!< North America - 350, 440, 480, 620, 950, 1400, 1800 Hz */
@@ -132,7 +153,7 @@
 /*! All THRESH_XXX values are in GSAMP_SIZE chunks (us = 22ms) */
 enum gsamp_thresh {
 	THRESH_RING = 8,        	/*!< Need at least 150ms ring to accept */
-	THRESH_TALK = 2,        	/*!< Talk detection does not work continuously */
+	THRESH_TALK = 4,        	/*!< Talk detection does not work continuously */
 	THRESH_BUSY = 4,        	/*!< Need at least 80ms to accept */
 	THRESH_CONGESTION = 4,  	/*!< Need at least 80ms to accept */
 	THRESH_HANGUP = 60,     	/*!< Need at least 1300ms to accept hangup */
@@ -194,6 +215,9 @@
 	float v2;
 	float v3;
 	float fac;
+	int16_t v2_fix;
+	int16_t v3_fix;
+	int16_t fac_fix;
 #ifndef OLD_DSP_ROUTINES
 	int samples;
 #endif	
@@ -293,14 +317,28 @@
 static char bell_mf_positions[] = "1247C-358A--69*---0B----#";
 #endif
 
+#define AMP_SCALE 8
+#define FAC_SCALE 14
+
+extern int dsp_sample;
+
 static inline void goertzel_sample(goertzel_state_t *s, short sample)
 {
+#ifdef __FIXED_PT__
+	int16_t v1_fix;
+	int     mpy;
+	v1_fix = s->v2_fix;
+	s->v2_fix = s->v3_fix;
+	mpy = (int16_t)( ((int)s->fac_fix * (int)s->v2_fix) >> FAC_SCALE );
+	s->v3_fix = mpy - v1_fix + (sample>>AMP_SCALE);
+#else
 	float v1;
 	float fsamp  = sample;
 	
 	v1 = s->v2;
 	s->v2 = s->v3;
 	s->v3 = s->fac * s->v2 - v1 + fsamp;
+#endif
 }
 
 static inline void goertzel_update(goertzel_state_t *s, short *samps, int count)
@@ -314,13 +352,19 @@
 
 static inline float goertzel_result(goertzel_state_t *s)
 {
+#ifdef __FIXED_PT__
+	s->v2 = (float)s->v2_fix * (1<<AMP_SCALE);
+	s->v3 = (float)s->v3_fix * (1<<AMP_SCALE);
+#endif
 	return s->v3 * s->v3 + s->v2 * s->v2 - s->v2 * s->v3 * s->fac;
 }
 
 static inline void goertzel_init(goertzel_state_t *s, float freq, int samples)
 {
 	s->v2 = s->v3 = 0.0;
+	s->v2_fix = s->v3_fix = 0;
 	s->fac = 2.0 * cos(2.0 * M_PI * (freq / 8000.0));
+	s->fac_fix = (int16_t)(s->fac*(1<<FAC_SCALE) + 0.5);
 #ifndef OLD_DSP_ROUTINES
 	s->samples = samples;
 #endif
@@ -329,6 +373,7 @@
 static inline void goertzel_reset(goertzel_state_t *s)
 {
 	s->v2 = s->v3 = 0.0;
+	s->v2_fix = s->v3_fix = 0;
 }
 
 struct ast_dsp {
@@ -435,15 +480,14 @@
 	float fax_energy_2nd;
 #endif	
 #endif /* FAX_DETECT */
-	float famp;
-	float v1;
 	int i;
 	int j;
 	int sample;
 	int best_row;
 	int best_col;
 	int hit;
-	int limit;
+	int limit,before;
+	before = cycles();
 
 	hit = 0;
 	for (sample = 0;  sample < samples;  sample = limit) {
@@ -455,12 +499,25 @@
 #if defined(USE_3DNOW)
 		_dtmf_goertzel_update (s->row_out, amp + sample, limit - sample);
 		_dtmf_goertzel_update (s->col_out, amp + sample, limit - sample);
+#elif defined(__FIXED_PT__)
+	for(j=0; j<4; j++) {
+		goertzel_update(&s->row_out[j], amp + sample, limit - sample);
+		goertzel_update(&s->col_out[j], amp + sample, limit - sample);
+	}
+	{
+		int acc;
+
+		acc = 0;
+		for (j = sample;  j < limit;  j++) {
+			acc += (amp[j] >> AMP_SCALE)*(amp[j] >> AMP_SCALE);
+		}
+		s->energy += (float)acc * ((float)(1<<AMP_SCALE)) * ((float)(1<<AMP_SCALE));
+	}
 #ifdef OLD_DSP_ROUTINES
 		_dtmf_goertzel_update (s->row_out2nd, amp + sample, limit2 - sample);
 		_dtmf_goertzel_update (s->col_out2nd, amp + sample, limit2 - sample);
 #endif		
 		/* XXX Need to fax detect for 3dnow too XXX */
-		#warning "Fax Support Broken"
 #else
 		/* The following unrolled loop takes only 35% (rough estimate) of the 
 		   time of a rolled loop on the machine on which it was developed */
@@ -1031,7 +1088,7 @@
 	/* Amplify ignored stuff */
 	i2 *= TONE_THRESH;
 	i1 *= TONE_THRESH;
-	e *= TONE_THRESH;
+	e *= TONE_THRESH/2;
 	/* Check first tone */
 	if ((p1 < i1) || (p1 < i2) || (p1 < e))
 		return 0;
@@ -1080,9 +1137,17 @@
 		if (pass > dsp->gsamp_size - dsp->gsamps) 
 			pass = dsp->gsamp_size - dsp->gsamps;
 		for (x=0;x<pass;x++) {
-			for (y=0;y<dsp->freqcount;y++) 
+			int acc = 0;
+			for (y=0;y<dsp->freqcount;y++){ 
 				goertzel_sample(&dsp->freqs[y], s[x]);
+#ifdef __FIXED_PT__
+				acc += (s[x] >> AMP_SCALE)* (s[x] >> AMP_SCALE);
+			}
+			dsp->genergy += (float)acc * ((float)(1<<AMP_SCALE)) * ((float)(1<<AMP_SCALE));
+#else
+			}
 			dsp->genergy += s[x] * s[x];
+#endif		
 		}
 		s += pass;
 		dsp->gsamps += pass;
@@ -1481,6 +1546,8 @@
 		ast_log(LOG_WARNING, "Inband DTMF is not supported on codec %s. Use RFC2833\n", ast_getformatname(af->subclass));
 		return af;
 	}
+#define TMP_DR
+#ifdef TMP_DR
 	silence = __ast_dsp_silence(dsp, shortdata, len, NULL);
 	if ((dsp->features & DSP_FEATURE_SILENCE_SUPPRESS) && silence) {
 		memset(&dsp->f, 0, sizeof(dsp->f));
@@ -1613,6 +1680,7 @@
 			}
 		}
 	}
+#endif
 	FIX_INF(af);
 	return af;
 }
--- asterisk/channels/misdn/isdn_lib.c	2009-10-02 02:18:28.000000000 +0300
+++ asterisk/channels/misdn/isdn_lib.c	2009-12-06 02:37:54.000000000 +0200
@@ -293,7 +293,13 @@
 	}
 }
 
+#define ISDN_LIB_DO_NOT_FLIP_BITS
+#ifdef ISDN_LIB_DO_NOT_FLIP_BITS
 
+#define init_flip_bits(x) 	do { /* NOP */ } while(0)
+#define flip_buf_bits(a,b) 	do { /* NOP */ } while(0)
+
+#else
 static char flip_table[256];
 
 static void init_flip_bits(void)
@@ -320,7 +326,7 @@
 	
 	return start;
 }
-
+#endif /* #ifdef ISDN_LIB_DO_NOT_FLIP_BITS */
 
 
 
@@ -1035,7 +1041,7 @@
 		li.st = bc->b_stid; /*  given idx */
 
 
-#define MISDN_DSP
+#undef MISDN_DSP
 #ifndef MISDN_DSP
 		bc->nodsp=1;
 #endif
@@ -4542,7 +4548,7 @@
 	int ec_arr[2];
 
 	if (bc->ec_enable) {
-		cb_log(3, stack?stack->port:0,"Sending Control ECHOCAN_ON taps:%d\n",bc->ec_deftaps);
+		cb_log(3, stack?stack->port:0,"Sending Control HW_ECHOCAN_ON taps:%d\n",bc->ec_deftaps);
 	
 		switch (bc->ec_deftaps) {
 		case 4:
@@ -4564,7 +4570,7 @@
 		ec_arr[0]=bc->ec_deftaps;
 		ec_arr[1]=0;
 		
-		manager_ph_control_block(bc,  ECHOCAN_ON,  ec_arr, sizeof(ec_arr));
+		manager_ph_control_block(bc,  HW_ECHOCAN_ON,  ec_arr, sizeof(ec_arr));
 	}
 #endif
 	}
@@ -4587,8 +4593,8 @@
 	manager_ph_control_block(bc, PIPELINE_CFG, "", 0);
 #else
 	if ( ! bc->ec_enable) {
-		cb_log(3, stack?stack->port:0, "Sending Control ECHOCAN_OFF\n");
-		manager_ph_control(bc,  ECHOCAN_OFF, 0);
+		cb_log(3, stack?stack->port:0, "Sending Control HW_ECHOCAN_OFF\n");
+		manager_ph_control(bc,  HW_ECHOCAN_OFF, 0);
 	}
 #endif
 }
--- asterisk/channels/chan_misdn.c	2009-11-25 13:05:33.000000000 +0100
+++ asterisk/channels/chan_misdn.c	2009-11-25 12:59:09.000000000 +0100
@@ -3892,6 +3892,7 @@
 
 	if (!ch->need_queue_hangup) {
 		cb_log(2, port, " --> No need to queue hangup\n");
+		return;
 	}
 
 	ch->need_queue_hangup = 0;
--- asterisk/apps/app_directory.c	2010-05-06 13:00:52.000000000 +0300
+++ asterisk/apps/app_directory.c	2010-05-06 13:01:26.000000000 +0300
@@ -179,7 +179,7 @@
 					break;
 				}
 				if (fd > -1)
-					fdm = mmap(NULL, fdlen, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+					fdm = mmap(NULL, fdlen, PROT_READ | PROT_WRITE, MAP_PRIVATE , fd, 0);
 			}
 			if (fdm != MAP_FAILED) {
 				memset(fdm, 0, fdlen);
--- asterisk/apps/app_voicemail.c	2010-05-06 13:02:26.000000000 +0300
+++ asterisk/apps/app_voicemail.c	2010-05-06 13:03:07.000000000 +0300
@@ -2413,7 +2413,7 @@
 					}
 					/* Read out in small chunks */
 					for (offset = 0; offset < colsize2; offset += CHUNKSIZE) {
-						if ((fdm = mmap(NULL, CHUNKSIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, offset)) == MAP_FAILED) {
+						if ((fdm = mmap(NULL, CHUNKSIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, offset)) == MAP_FAILED) {
 							ast_log(LOG_WARNING, "Could not mmap the output file: %s (%d)\n", strerror(errno), errno);
 							SQLFreeHandle(SQL_HANDLE_STMT, stmt);
 							ast_odbc_release_obj(obj);
@@ -2731,7 +2731,7 @@
 		fdlen = lseek(fd, 0, SEEK_END);
 		lseek(fd, 0, SEEK_SET);
 		printf("Length is %zd\n", fdlen);
-		fdm = mmap(NULL, fdlen, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+		fdm = mmap(NULL, fdlen, PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);
 		if (fdm == MAP_FAILED) {
 			ast_log(LOG_WARNING, "Memory map failed!\n");
 			ast_odbc_release_obj(obj);
--- asterisk/codecs/Makefile	2010-05-15 11:06:33.000000000 +0300
+++ asterisk/codecs/Makefile	2010-05-15 11:05:01.000000000 +0300
@@ -71,3 +71,7 @@
         
 
 $(if $(filter codec_g722,$(EMBEDDED_MODS)),modules.link,codec_g722.so): $(LIBG722)
+
+$(if $(filter codec_g729,$(EMBEDDED_MODS)),modules.link,codec_g729.so):
+	$(CC) -o codec_g729.so -shared $(ASTLDFLAGS)  codec_g729.o $(ASTTOPDIR)/../uClinux-dist/lib/libbfgdots/g729/src.fdpic/partial_local.o
+
--- asterisk/configure	2010-06-06 02:05:57.000000000 +0300
+++ asterisk/configure	2010-06-06 02:08:26.000000000 +0300
@@ -10310,7 +10310,7 @@
 fi
 if test "x$ac_cv_func_fork_works" = xcross; then
   case $host in
-    *-*-amigaos* | *-*-msdosdjgpp* | *-*-uclinux* | *-*-linux-uclibc* )
+    *-*-amigaos* | *-*-msdosdjgpp* | *-*-uclinux* | *-*-linux-uclibc* | bfin-*-* )
       # Override, as these systems have only a dummy fork() stub
       ac_cv_func_fork_works=no
       ;;
@@ -14488,14 +14488,15 @@
    fi
 fi
 
-   ac_fn_c_check_header_mongrel "$LINENO" "linux/mISDNdsp.h" "ac_cv_header_linux_mISDNdsp_h" "$ac_includes_default"
-if test "x$ac_cv_header_linux_mISDNdsp_h" = x""yes; then :
-
-cat >>confdefs.h <<_ACEOF
-#define MISDN_1_2 1
-_ACEOF
-
-fi
+# DPN: disabled pipeline mode in chan_misdn
+#   ac_fn_c_check_header_mongrel "$LINENO" "linux/mISDNdsp.h" "ac_cv_header_linux_mISDNdsp_h" "$ac_includes_default"
+#if test "x$ac_cv_header_linux_mISDNdsp_h" = x""yes; then :
+#
+#cat >>confdefs.h <<_ACEOF
+##define MISDN_1_2 1
+#_ACEOF
+#
+#fi
 
 
 fi
--- asterisk/res/res_agi.c	2010-06-06 15:55:29.000000000 +0300
+++ asterisk/res/res_agi.c	2010-06-06 15:56:02.000000000 +0300
@@ -308,7 +308,7 @@
 	/* Block SIGHUP during the fork - prevents a race */
 	sigfillset(&signal_set);
 	pthread_sigmask(SIG_BLOCK, &signal_set, &old_set);
-	pid = fork();
+	pid = vfork();
 	if (pid < 0) {
 		ast_log(LOG_WARNING, "Failed to fork(): %s\n", strerror(errno));
 		pthread_sigmask(SIG_SETMASK, &old_set, NULL);
