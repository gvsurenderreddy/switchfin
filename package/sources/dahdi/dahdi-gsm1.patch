diff -urP dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi/bfsi.c dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi-gsm/bfsi.c
--- dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi/bfsi.c	2010-09-02 16:55:21.000000000 +0300
+++ dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi-gsm/bfsi.c	2010-09-02 16:51:42.000000000 +0300
@@ -36,6 +36,9 @@
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+
+  Dimitar Penev : GSM1 support added in Switchfin
+  Copyright 2010 Switchfin dpn@switchfin.org
 */
 
 #include <linux/module.h>
@@ -550,7 +553,7 @@
 	/* 0 bit delay between FS pulse and first data bit,
 	   multichannel frame mode enabled, 
 	   multichannel tx and rx DMA packing enabled */
-	bfin_write_SPORT0_MCMC2(0x001c);
+	bfin_write_SPORT0_MCMC2(0x101c);//YN was 0x001c //One bit delay between FS pulse and first data bit
 
 }
 #endif
Binary files build_ip04/dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi/bfsi.ko and /BACKUP/dahdi-gsm/bfsi.ko differ
Binary files build_ip04/dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi/bfsi.o and /BACKUP/dahdi-gsm/bfsi.o differ
diff -urP dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi/fx.c dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi-gsm/fx.c
--- dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi/fx.c	2010-09-02 16:55:21.000000000 +0300
+++ dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi-gsm/fx.c	2010-09-02 16:51:42.000000000 +0300
@@ -36,6 +36,9 @@
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+
+  Dimitar Penev : GSM1 support added in Switchfin
+  Copyright 2010 Switchfin dpn@switchfin.org
 */
 
 #define FX_MAX_DBS     4  // max number of 4fx daughter boards
@@ -44,6 +47,9 @@
 #define FX_LED_RED     1
 #define FX_LED_GREEN   2
 
+#include "GSM_module_SPI.h" //YN
+char  port_type[FX_MAX_PORTS];//YN
+
 static int led[FX_MAX_DBS];
 
 /*
diff -urP dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi/gsm_module.c dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi-gsm/gsm_module.c
--- dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi/gsm_module.c	1970-01-01 02:00:00.000000000 +0200
+++ dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi-gsm/gsm_module.c	2010-09-02 16:51:42.000000000 +0300
@@ -0,0 +1,1071 @@
+/*
+ * GSM Interface Driver for Zapata Telephony interface
+ *
+ * Written by Youliy Ninov <yni@ucpbx.com>
+ *         
+ *
+ * Copyright (C) 2008, uCPBX Ltd.
+ *
+ * All rights reserved.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+ *
+ */
+//#include <linux/delay.h>
+
+#include "GSM_module_SPI.h"
+
+extern int sport_configure(int baud);
+
+extern int outgoing_call_state;
+extern int incomming_call_state;
+extern char  port_type[FX_MAX_PORTS];
+
+
+//SPORT1 emulates SPI communication through the CPLD.
+//Each time we address the SPI device on the GSM module (SC16IS750) we
+//need to reconfigure the SPORT1 interface, since the SPI2UART (SC16IS750) accepts
+//16-bit SPI words only
+static int sport_configure_gsm(int baud)
+{
+
+	//It is important to stop SPORT1 before we reconfigure it. Otherwise
+	//some registers do not always get initialiazed
+	sport1_write_TCR1( sport1_read_TCR1() & ~(TSPEN) ); 
+	sport1_write_RCR1( sport1_read_RCR1() & ~(RSPEN) ); 
+	__builtin_bfin_ssync();
+	/* Register SPORTx_TCR1 ( relative details pls refer 12-12 of hardware reference ) 
+	        TCKFE ( Clock Falling Edge Select )   ( Bit14 ) 
+          	LTFS ( Bit11) :  0 - Active high TFS; 1 - Active low TFS
+		ITFS ( Bit9 ) :  0 - External TFS used; 1 - Internal TFS used 
+		TFSR: 0 - Dose not require TFS for every data word;  1 - Requires TFS for every data word
+		TLSBIT: 0 - Transmit MSB first ;  1 - Transmit LSB first
+		ITCLK: 0 - External transmit clock selected; 1 - Internal transmit clock selected
+	*/
+	sport1_write_TCR1( LATFS | LTFS | TFSR | ITFS | ITCLK);
+	__builtin_bfin_ssync();
+		
+	/* 16 bit word length  */
+	sport1_write_TCR2(0xf);
+    
+	/* SPORTx_TCLK frequency = ( System Clock frequency ) / ( 2 * ( SPORTx_TCLKDIV + 1 ) )   */
+	sport1_write_TCLKDIV(baud);
+	sport1_write_TFSDIV(0xf);
+	
+	/* Initialization of SPORT1_RCR1 and SPORT1_RCR2, similar to the Register SPORTx_TCR1  and SPORTx_TCR2 */
+	sport1_write_RCR1(LARFS | LRFS | RFSR);  
+	sport1_write_RCR2(0xf);      /* 16 bit word length      */
+	
+	sport1_write_RCLKDIV(baud);
+	sport1_write_RFSDIV(0xf);
+	
+	__builtin_bfin_ssync();
+
+	PRINTK("tcr1:0x%x, tcr2:0x%x, rcr1:0x%x, rcr2:0x%x\n",
+		sport1_read_TCR1(), sport1_read_TCR2(),
+		sport1_read_RCR1(), sport1_read_RCR2());
+
+	return 0;
+}
+
+//This is the function that transmits 16-bit data to the SPI2UART
+//It has been verified for 1.33MHz SPI clock. If lower clocks
+//are necessary some of the delays in the function must be 
+//increased. It works also for 13.3 MHz.
+static void sport_tx_word(u16 chip_select, u16 bits)
+{
+	/* Enable the transmit operation */
+	sport1_write_TCR1( sport1_read_TCR1() | TSPEN ); 
+	while (!(sport1_read_TCR1() & TSPEN));
+
+	/* drop chip select */
+	if ( chip_select >7 )
+	{
+		/* Clear PFx used for chip_select */
+#if (defined(CONFIG_BF533) || defined(CONFIG_BF532))
+        bfin_write_FIO_FLAG_C((1<<chip_select));
+#endif
+#if (defined(CONFIG_BF536) || defined(CONFIG_BF537))
+        bfin_write_PORTFIO_CLEAR((1<<chip_select));
+#endif
+		__builtin_bfin_ssync();
+		udelay(2);	//tsu1 - Setup Time, /CS to SCLK fall
+	}
+	//Transmit 16 bits
+	bfin_write_SPORT1_TX16(bits);
+
+	while (!(sport1_read_STAT() & TXHRE));
+
+	/*  Wait for the last byte sent out (clocked out!) */
+	udelay(30);//!
+
+	/* Raise chip select */
+	if ( chip_select >7 )
+	{
+		/* Raise PFx High*/
+#if (defined(CONFIG_BF533) || defined(CONFIG_BF532))
+    bfin_write_FIO_FLAG_S((1<<chip_select));
+#endif
+#if (defined(CONFIG_BF536) || defined(CONFIG_BF537))
+        bfin_write_PORTFIO_SET((1<<chip_select));
+#endif
+		__builtin_bfin_ssync();
+		udelay(20);	
+	}
+
+#ifdef SPORT_INTERFACE_DEBUG
+	txCnt++;
+	PRINTK("Send the %d word OK!\n", txCnt);
+#endif
+	return;
+} 
+
+//This is the function that reads data from the SPI2UART chip on 
+//on the GSM module. The first 8 bits are sent to the SPI2UART (
+//padded by 8 trailing zeros). The second 8 bits are the data from
+// the SPI2UART chip (padded by 8 front zeros).
+//It has been verified for 1.33MHz SPI clock. If lower clocks
+//are necessary some of the delays in the function must be 
+//increased. It works also for 13.3 MHz.
+static u16 sport_rx_word(u16 chip_select,u16 regdata)
+{
+	u16 ret = 0;
+	PRINTK("Come into %s\n",__FUNCTION__);
+
+	/* Enable the transmit operation */
+	sport1_write_TCR1( sport1_read_TCR1() | TSPEN ); 
+	while (!(sport1_read_TCR1() & TSPEN));
+
+	/* Enable the receive operation */
+	sport1_write_RCR1( sport1_read_RCR1() | RSPEN ); 
+	while (!(sport1_read_RCR1() & RSPEN));
+	
+	/* drop chip select */
+	if ( chip_select >7 )
+	{
+		/* Clear PFx used for chip_select */
+#if (defined(CONFIG_BF533) || defined(CONFIG_BF532))
+    bfin_write_FIO_FLAG_C((1<<chip_select));
+#endif
+#if (defined(CONFIG_BF536) || defined(CONFIG_BF537))
+        bfin_write_PORTFIO_CLEAR((1<<chip_select));
+#endif
+		__builtin_bfin_ssync();
+		udelay(2);	//tsu1 - Setup Time, /CS to SCLK fall
+	}
+
+	/* Tx data and  generate a FSYNC */
+	bfin_write_SPORT1_TX16(regdata);
+
+	//Wait for the SPI2UART to answer
+	while (!(sport1_read_STAT() & RXNE))
+	{
+		PRINTK("%s Line%d:status:%x  %d \n", __FUNCTION__, __LINE__, sport1_read_STAT(), txCnt);
+	}
+
+	/*  Wait for the last byte sent out  */
+	udelay(13);
+
+	ret = (u16)bfin_read_SPORT1_RX16();
+	PRINTK("%s Line%d: tcr1:0x%x, tcr2:0x%x, rcr1:0x%x, rcr2:0x%x\n",
+		__FUNCTION__, __LINE__,
+		sport1_read_TCR1(), sport1_read_TCR2(),
+		sport1_read_RCR1(), sport1_read_RCR2());
+
+	/* Raise chip select */
+	if ( chip_select >7 )
+	{
+		/* Raise High of PFx */
+#if (defined(CONFIG_BF533) || defined(CONFIG_BF532))
+    	bfin_write_FIO_FLAG_S((1<<chip_select));
+#endif
+#if (defined(CONFIG_BF536) || defined(CONFIG_BF537))
+        bfin_write_PORTFIO_SET((1<<chip_select));
+#endif
+		__builtin_bfin_ssync();
+		udelay(20);
+	}
+	PRINTK("%s Line%d receive word OK!\n",__FUNCTION__, __LINE__ );
+
+	return ret;
+}
+
+//This is the complete reading function of the SPI2UART
+//Internal workings:
+//1.Select the card to program
+//2.Configure the sport1 interface for the GSM module access
+//3.Read data fromt the SPI2UART chip
+//4.Reconfigure sport1 interface for FXS/FXO access
+static u16 fx_read_SPI2UART(struct wcfxs *wc,int port,int value) 
+{
+    u16  reg;
+
+ if (port > 4)
+      port += 0x40 - 4;
+#ifdef CONFIG_4FX_SPI_INTERFACE
+    bfsi_spi_write_8_bits(SPI_NCSB, port); 
+#else// added YN
+
+	__wcfxs_setcard(wc, port);//We wish to progarmm module 'port'
+
+ 	sport_configure_gsm(SPI_BAUDS_GSM); //Configure the SPI (sport) to 1.33MHz/16bits (GSM access)
+	reg=sport_rx_word(SPI_NCSA,value);//Read register
+ 	sport_configure(SPI_BAUDS);//Reconfigure the SPI (sport) to 1.33MHz/8bits
+
+#endif
+
+    return reg;
+}
+//This function is used when we need to send data without any Chip Select active.
+//This is used for addressing the Codec (WM8510), since the clock is gated by an
+//AND gate (see schematics).
+//Internal workings:
+//1.Configure the sport1 interface for the GSM module access
+//2.Transmit data to the CODEC
+//3.Reconfigure sport1 interface for FXS/FXO access
+static void fx_write_SPI2UART_wo_CS(int value) 
+{
+ sport_configure_gsm(SPI_BAUDS_GSM); //Configure the SPI (sport) to 1.33MHz/16bits
+ sport_tx_word(0,value);//Tx data
+ sport_configure(SPI_BAUDS);//Reconfigure the SPI (sport) to 1.33MHz/8bits
+}
+
+//This is the complete reading function of the SPI2UART
+//Internal workings:
+//1.Select the card to program
+//2.Configure the sport1 interface for the GSM module access
+//3.Transmit data to the SPI2UART chip
+//4.Reconfigure sport1 interface for FXS/FXO access
+static void fx_write_SPI2UART(struct wcfxs *wc,int port,int value) 
+{
+
+ if (port > 4)
+      port += 0x40 - 4;
+#ifdef CONFIG_4FX_SPI_INTERFACE
+    bfsi_spi_write_8_bits(SPI_NCSB, port); 
+#else//adde YN
+
+	__wcfxs_setcard(wc, port);//We wish to progarmm module 'port'
+	
+ 	sport_configure_gsm(SPI_BAUDS_GSM); //Configure the SPI (sport) to 1.33MHz/16bits
+ 	sport_tx_word(SPI_NCSA,value);//Tx to register
+ 	sport_configure(SPI_BAUDS);//Reconfigure the SPI (sport) to 1.33MHz/8bits
+
+#endif
+
+}
+
+//This function implements writing followed by reading from the same
+//register of SPI2UART and compares the results.
+//Internal workings:
+//1.Select the card to program
+//2.Configure the sport1 interface for the GSM module access
+//3.Transmit data to the SPI2UART chip
+//4.Read data from the SPI2UART chip
+//5.Compare Tx and Rx data
+//4.Reconfigure sport1 interface for FXS/FXO access
+static int fx_program_register_SPI2UART(struct wcfxs *wc,int port,int value) 
+{
+    u16  reg,temp;
+
+ if (port > 4)
+      port += 0x40 - 4;
+#ifdef CONFIG_4FX_SPI_INTERFACE
+    bfsi_spi_write_8_bits(SPI_NCSB, port); 
+
+#else//added YN
+
+	__wcfxs_setcard(wc, port);//We wish to progarmm module 'port'
+
+ 	sport_configure_gsm(SPI_BAUDS_GSM); //Configure the SPI (sport) to 1.33MHz/16bits
+ 	sport_tx_word(SPI_NCSA,value);//Write register
+ 	value=value | 0x8000;//change writing to reading!
+ 	reg=sport_rx_word(SPI_NCSA,value);//Read register
+	temp=value | 0xff00;
+ 	sport_configure(SPI_BAUDS);//Reconfigure the SPI (sport) to 1.33MHz/8bits
+	if(temp!=reg){
+		 printk("Register not programmed! T=%x R=%x Rm=%x\n",value,reg,temp);
+		 return 1;
+	}
+	return 0;
+#endif
+
+}
+
+//This function is used for detection of the GSM module (on which port
+//it is placed,if any). A register of the SPI2UAR is read. After reset
+//the register value is 0x001D. When this value is found, the GSM module
+//place is fixed and a the respective diode is set to RED (same as for a FXO module)
+void gsm_auto_detect(struct wcfxs *wc,char port_type[], int bit_reset) 
+{
+  int i;
+  u16  reg;
+	
+  //Traverse all the available ports
+  for(i=0; i<FX_MAX_PORTS; i++) {
+    if(port_type[i] == '-'){//if there is an unassigned port check it!
+	reg = fx_read_SPI2UART(wc,i,0x9800);
+	//printk("GAD:i=%d reg=%x\n",i,reg);
+  	 if (reg == 0xff1D) {// When GSM module is found
+	 // printk("GAD1:%x\n",reg);
+   	  port_type[i] = 'G';
+	  fx_set_led(i+1, FX_LED_RED);//Set let to RED
+	  wc->curcard=-1;// setting led messes with the current card settings
+  	  break;//only one GSM module per system!
+	 }
+    }//end if(port_type[i]..
+  }//end for
+}//end gsm_auto_detect
+
+//This function implements sending data to the GSM module through the 
+//SPI2UART.Data is sent to the UARTs FIFO character by charachter.
+//CR and LF are added after every command/data
+void GSM_send(struct wcfxs *wc,int port,const char * info)
+{
+	int count;
+	count=0;
+	if (debug)
+		printk("Sent: %s\n",info);
+	while(info[count]!=0x00)
+	{
+		//Send data to THR
+		//==>  R/~W A3 A2 A1 A0 CH1 CH0 X
+		//==>   0    0  0  0  0  0   0  0 ==0x00
+		//THR address and command bits default to 0, so we neglect the command word entirely
+		fx_write_SPI2UART(wc,port,info[count]);
+		count++;
+	}
+	fx_write_SPI2UART(wc,port,0x000d);//send CR
+	fx_write_SPI2UART(wc,port,0x000a);//send LF
+}
+
+//This function receives data from the GSM module through the 
+//SPI2UART.Data is received from the UARTs FIFO character by charachter.
+//It checks if there is data to read and if yes ->reads it, if no 
+// an 'x' character is output.
+char * GSM_receive(struct wcfxs *wc,int port)
+{
+	static char GSM_string[60];
+	u16 reg,i,temp;
+	int keep_s;
+	
+	//Get the number of characters in the Rx FIFO
+	//==>  R/~W A3 A2 A1 A0 CH1 CH0 X
+	//==>   1    1  0  0  1  0   0  0 ==0xC8. RXLVL register
+	reg=fx_read_SPI2UART(wc,port,0xC800); 
+	reg=reg & 0x00ff;
+	//Check if data to read is available
+	if(reg==0) {//if no data to read -> output 'x' string
+		GSM_string[0]='x';
+		GSM_string[1]=0x00;//string terminating character
+		return GSM_string;
+	}
+
+	//Get all the characters and put them in a char array
+	keep_s=0;
+	for(i=0;i<reg;i++){
+		temp=fx_read_SPI2UART(wc,port,0x8000); 
+		temp=temp & 0x00ff;
+		if((temp==0x000d)||(temp==0x000a)){
+			if(debug>=2)
+				printk("\n");
+			//Add the terminating character when at least one char has been received
+			if(keep_s>0){
+				GSM_string[keep_s]=0x00;
+				keep_s+=1;
+			}
+		}
+		else{		
+			if(debug>=2)
+				printk("%c",(char)temp);
+			GSM_string[keep_s]=(char)temp;
+			keep_s+=1;
+		}		
+	}
+
+	return GSM_string;
+}
+
+//The function is placed in the main SPORT interrupt
+// It implements a state mashine for control of the Dialed/Received
+//calls. When necessary it passed signals to Zaptel.
+void wcfxs_gsm_control(struct wcfxs *wc, int card)
+{
+	static int interrupt_count=0;
+	char * p2char;
+
+//Dialing part
+
+	//Once we have dialed the number we expect an OK received from
+	//the modem. When OK is received, we switch to the next state
+	if(outgoing_call_state==1){
+		p2char=GSM_receive(wc,card);
+		if(strcmp(p2char,"x")==0) return;
+		if(strcmp(p2char,"0")==0){
+			outgoing_call_state=2;
+			//dahdi_hooksig(&wc->chans[card], DAHDI_RXSIG_OFFHOOK);
+			if (debug>=2)
+				printk("OK recevied!\n");
+			return;
+		}
+		else{
+			if (debug>=2)
+				printk("ocs=%d str_rec=%s\n",outgoing_call_state,p2char);
+			outgoing_call_state=0;
+			dahdi_hooksig(&wc->chans[card], DAHDI_RXSIG_ONHOOK);
+			if (debug>=2)
+				printk("OK not received!\n");
+			return;	
+		}
+			
+	}
+	
+	//During converstaion
+	//We continue looking for "NO CARRIER" "BUSY" or other signals.
+	if(outgoing_call_state==2){
+		p2char=GSM_receive(wc,card);
+		if(strcmp(p2char,"x")==0) return;
+		//If NO CARRIER received, initialize the state machine
+		//Inform zaptel for call disconnect
+		if(strcmp(p2char,"3")==0){
+			outgoing_call_state=0;
+			dahdi_hooksig(&wc->chans[card], DAHDI_RXSIG_ONHOOK);
+			if (debug>=2)
+				printk("NO CARRIER %s\n",p2char);
+			return;
+		}
+		//If BUSY received, initialize the state machine
+		//Inform zaptel for call disconnect
+		if(strcmp(p2char,"7")==0){
+			outgoing_call_state=0;
+			dahdi_hooksig(&wc->chans[card], DAHDI_RXSIG_ONHOOK);
+			if (debug>=2)
+				printk("BUSY %s\n",p2char);
+			return;
+		}
+		//If NO ANSWER received, initialize the state machine
+		//Inform zaptel for call disconnect
+		if(strcmp(p2char,"8")==0){
+			outgoing_call_state=0;
+			dahdi_hooksig(&wc->chans[card], DAHDI_RXSIG_ONHOOK);
+			if (debug>=2)
+				printk("NO ANSWER %s\n",p2char);
+			return;
+		}
+		if (debug>=2)
+			printk("ocs=%d str_rec=%s\n",outgoing_call_state,p2char);	
+		return;		
+	}
+
+//Receiving a call
+	//Waiting for RING signal from the GSM
+	if(incomming_call_state==0){
+		
+			p2char=GSM_receive(wc,card);
+			//When RING is received
+			if(strcmp(p2char,"2")==0){
+				 interrupt_count=2;
+				 if (debug>=2)
+					 printk("Ring: %s\n",p2char);
+			}
+			else{
+				if(strcmp(p2char,"x")!=0){
+					if (debug>=2)
+						printk("ics=%d str_rec=%s\n",incomming_call_state,p2char);
+				}
+			}
+			if(interrupt_count==2){
+				dahdi_hooksig(&wc->chans[card], DAHDI_RXSIG_RING);
+				if (debug>=2)
+					printk("dahdi_hooksig DAHDI_RXSIG_RING sent!\n");
+				interrupt_count=1;
+				return;
+			}	
+			if(interrupt_count==1) {
+				dahdi_hooksig(&wc->chans[card], DAHDI_RXSIG_OFFHOOK);
+				if (debug>=2)
+					printk("dahdi_hooksig DAHDI_RXSIG_OFFHOOK sent!\n");
+				interrupt_count=0;
+				incomming_call_state=1;
+				return;
+			}
+			return;
+
+	}
+		
+	//Ringing and checking for call disconnect
+	if(incomming_call_state==1){
+			p2char=GSM_receive(wc,card);
+
+			//It is necessary to set the state to DAHDI_TXSTATE_OFFHOOK, otherwise
+			//there is a problem when call is disconnected before it is answered
+			wc->chans[card].txstate=1;//!! YN
+			//When call is disconnected before it is answered
+			if(strcmp(p2char,"3")==0){
+				incomming_call_state=0;
+				interrupt_count=0;
+				
+				dahdi_hooksig(&wc->chans[card],DAHDI_RXSIG_ONHOOK);
+				if (debug>=2)
+					printk("NO CARRIER %s\n",p2char);
+				return;
+			}
+			//When RING is received
+			if(strcmp(p2char,"2")==0){
+				 interrupt_count=2;
+				 if (debug>=2)
+					 printk("Ring: %s\n",p2char);
+			}
+			else{
+				if(strcmp(p2char,"x")!=0) {
+					if (debug>=2)
+						printk("ics=%d str_rec=%s\n",incomming_call_state,p2char);
+				}
+			}
+			if(interrupt_count==2){
+				dahdi_hooksig(&wc->chans[card], DAHDI_RXSIG_RING);
+				if (debug>=2)
+					printk("dahdi_hooksig DAHDI_RXSIG_RING sent!\n");
+				interrupt_count=1;
+				return;
+			}	
+			if(interrupt_count==1) {
+				dahdi_hooksig(&wc->chans[card], DAHDI_RXSIG_OFFHOOK);
+				if (debug>=2)
+					printk("dahdi_hooksig DAHDI_RXSIG_OFFHOOK sent!\n");
+				interrupt_count=0;
+				return;
+			}
+			return;
+	}		
+
+	//Connected state (during conversation)
+	if(incomming_call_state==2){
+		p2char=GSM_receive(wc,card);
+		if(strcmp(p2char,"x")==0) return;
+		//Looking for NO CARRIER. If received, inform zaptel
+		//that the other party has ended the conversation
+		if(strcmp(p2char,"3")==0){
+			incomming_call_state=0;
+			dahdi_hooksig(&wc->chans[card], DAHDI_RXSIG_ONHOOK);
+			if (debug>=2){
+				printk("NO CARRIER %s\n",p2char);
+				printk("dahdi_hooksig DAHDI_RXSIG_ONHOOK sent!\n");
+			}
+			return;
+		}
+		if (debug>=2)
+			printk("ics=%d str_rec=%s\n",incomming_call_state,p2char);	
+		return;
+	}
+		
+}//end wcfxs_gsm_control
+
+
+
+//This function implements the initialization of the 
+//SPI2UART chip
+static int init_SC16IS750(struct wcfxs *wc,int port)
+{
+	int ret;
+
+	//Program LCR 
+	//==>  R/~W A3 A2 A1 A0 CH1 CH0 X
+	//==>   0    0  0  1  1  0   0  0 ==0x18
+	ret=fx_program_register_SPI2UART(wc,port,0x1880); //0x80 allows special register set programming
+	if(ret)
+		return 1;
+	//program DLL
+	//==>  R/~W A3 A2 A1 A0 CH1 CH0 X
+	//==>   0    0  0  0  0  0   0  0 ==0x00
+	//according to the formula on pp.17 for 3.6864 MHz oscillator we need  divisor=24=18HEX
+	//in order to get 9600 bauds
+	//for 38400 bauds we need divisor=6
+	ret=fx_program_register_SPI2UART(wc,port,0x0006);//program oscillator
+	if(ret)
+		return 1;
+
+	//program DLM
+	//==>  R/~W A3 A2 A1 A0 CH1 CH0 X
+	//==>   0    0  0  0  1  0   0  0 ==0x08
+	ret=fx_program_register_SPI2UART(wc,port,0x0800);//program oscillator
+	if(ret)
+		return 1;
+
+	//Program LCR to access EFR register
+	//==>  R/~W A3 A2 A1 A0 CH1 CH0 X
+	//==>   0    0  0  1  1  0   0  0 ==0x18
+	ret=fx_program_register_SPI2UART(wc,port,0x18BF);//0xBF allows EFR register programming
+	if(ret)
+		return 1;
+
+	//Program EFR register
+	//==>  R/~W A3 A2 A1 A0 CH1 CH0 X
+	//==>   0    0  0  1  0  0   0  0 ==0x10
+	ret=fx_program_register_SPI2UART(wc,port,0x10D0);//auto CTS,auto RTS,enable enhanced functions
+	if(ret)
+		return 1;
+	
+	//Program LCR 
+	//==>  R/~W A3 A2 A1 A0 CH1 CH0 X
+	//==>   0    0  0  1  1  0   0  0 ==0x18
+	ret=fx_program_register_SPI2UART(wc,port,0x1803);//8n1, no parity
+	if(ret)
+		return 1;
+
+	//Program MCR
+	//==>  R/~W A3 A2 A1 A0 CH1 CH0 X
+	//==>   0    0  1  0  0  0   0  0 ==0x20
+	ret=fx_program_register_SPI2UART(wc,port,0x2004);//TCR and TLR enable
+	if(ret)
+		return 1;
+
+	//Program TCR
+	//==>  R/~W A3 A2 A1 A0 CH1 CH0 X
+	//==>   0    0  1  1  0  0   0  0 ==0x60
+	ret=fx_program_register_SPI2UART(wc,port,0x301E);//resume at 4 halt at 60 charachters
+	if(ret)
+		return 1;
+
+	//Program FCR 
+	//==>  R/~W A3 A2 A1 A0 CH1 CH0 X
+	//==>   0    0  0  1  0  0   0  0 ==0x10
+	fx_write_SPI2UART(wc,port,0x10c6); //NOTE: Write only register!
+	//reset TXFIFO, reset RXFIFO,RX trigger=60 characters, non FIFO mode
+	
+	//Program IER
+	//==>  R/~W A3 A2 A1 A0 CH1 CH0 X
+	//==>   0    0  0  0  1  0   0  0 ==0x08
+	ret=fx_program_register_SPI2UART(wc,port,0x0801);//enable Rx interrupt
+	if(ret)
+		return 1;
+
+	//Program FCR 
+	//==>  R/~W A3 A2 A1 A0 CH1 CH0 X
+	//==>   0    0  0  1  0  0   0  0 ==0x10;//enable FIFO
+	fx_write_SPI2UART(wc,port,0x1007); //NOTE: Write only register!
+
+
+	//Set GPIO_CS at High,PWRKEY high. IOState register  0x0B.DTR high
+	//==>  R/~W A3 A2 A1 A0 CH1 CH0 X
+	//==>   0    1  0  1  1  0   0  0 ==0x58
+	fx_write_SPI2UART(wc,port,0x5825);//gives bad results when read (inputs)
+	//fx_program_register_SPI2UART(wc,port,0x5801);
+
+	//Program GPIO_CS as output,GPIO0 (PWRKEY)as output,DTR output IODir register 0x0A
+	//==>  R/~W A3 A2 A1 A0 CH1 CH0 X
+	//==>   0    1  0  1  0  0   0  0 ==0x50
+//	fx_write_SPI2UART(wc,port,0x5000);
+	ret=fx_program_register_SPI2UART(wc,port,0x5025);
+	if(ret)
+		return 1;
+	
+	return 0;
+
+}
+
+//Implements the GSM module initialization
+//through the SPI2UART chip.
+static int init_GSM(struct wcfxs *wc,int port)
+{
+	u16 reg;
+	char * p2char;
+	int cntr;
+
+//GSM management part
+	//Check if VDD_EXT is in high state
+	//(if GSM modem if ON).
+	reg=fx_read_SPI2UART(wc,port,0xd800); 
+	if (debug)
+		printk("VDD_EXT=%x\n",reg);
+
+	//Reset the GSM modem if it has already been started!
+	if((reg & 0x0002)!=0){
+		printk("Resetting the GSM modem!\n");	
+
+		//Power down GSM modem
+		cntr=3;
+		do {
+		GSM_send(wc,port,"at+cpowd=1");
+		printk("Logging off the network........!\n");
+		wait_just_a_bit(7*HZ);
+		p2char=GSM_receive(wc,port);
+		if (debug)
+			printk("Received: %s\n",p2char);
+		} while(strcmp(p2char,"NORMAL POWER DOWN")!=0 && (--cntr>0));
+
+
+		//Check if VDD_EXT is in high state
+		//(make sure the modem in in OFF state)
+		reg=fx_read_SPI2UART(wc,port,0xd800); 
+		if (debug)
+			printk("VDD_EXT=%x\n",reg);
+		if((reg & 0x0002)!=0) {
+			printk("Unable to reset the GSM modem!!\n");
+			return 1;
+		}
+
+		//Wait for more than 0.5 seconds
+		wait_just_a_bit(1*HZ);
+		
+	}
+
+	//Start the GSM if has not been started already
+	else{
+		printk("Starting the GSM modem!\n");
+	}
+	
+	//Whether after RESET of after complete disconnet
+	//of the main board from the main supply, we need to start
+	// the GSM modem
+
+	//Lower PWRKEY for more than two seconds
+	//==>  R/~W A3 A2 A1 A0 CH1 CH0 X
+	//==>   0    1  0  1  1  0   0  0 ==0x58
+	fx_write_SPI2UART(wc,port,0x5824);
+
+	printk("Wait for GSM module start!\n");
+	//Keep PWRKEY low for more than two seconds (three in this case)
+	wait_just_a_bit(3*HZ);
+
+	//Raise PWRKEY again 
+	//==>  R/~W A3 A2 A1 A0 CH1 CH0 X
+	//==>   0    1  0  1  1  0   0  0 ==0x58
+	fx_write_SPI2UART(wc,port,0x5825);
+	wait_just_a_bit(1*HZ);//DPN
+
+	//Check if VDD_EXT is in high state
+	//(if modem is ON)
+	reg=fx_read_SPI2UART(wc,port,0xd800); 
+	if (debug)
+		printk("VDD_EXT=%x\n",reg);
+	if((reg & 0x0002)==0){
+		 printk("Unable to start the GSM modem!!\n");
+		return 1; 
+	}
+
+	//Ensure autobauding and modem answer
+	GSM_send(wc,port,"at");
+	// Wait 
+	wait_just_a_bit(HZ);
+	p2char=GSM_receive(wc,port);
+	if (debug)
+		printk("Received: %s\n",p2char);
+
+	//Make sure there that there is no echo to the terminal
+	cntr=3;
+	do {
+	GSM_send(wc,port,"ate0");
+	wait_just_a_bit(HZ/10);
+	p2char=GSM_receive(wc,port);
+	if (debug)
+		printk("Received: %s\n",p2char);
+	} while(strcmp(p2char,"OK")!=0 && (--cntr>0));
+		
+
+	//Change the modem answer type, i.e.
+	//switch from "OK" to '0",etc.
+	cntr=3;
+	do {
+		GSM_send(wc,port,"atv0");
+		wait_just_a_bit(HZ/10);
+		p2char=GSM_receive(wc,port);
+		if (debug)
+			printk("Received: %s\n",p2char);
+	} while(strcmp(p2char,"0")!=0 && (--cntr>0));
+	
+	//Error message verbose string
+	cntr=3;
+	do {
+		GSM_send(wc,port,"at+cmee=2");
+		wait_just_a_bit(HZ/10);
+		p2char=GSM_receive(wc,port);
+		if (debug)
+			printk("Received: %s\n",p2char);
+	} while(strcmp(p2char,"0")!=0 && (--cntr>0));
+	
+
+
+	//SIM PIN check
+	GSM_send(wc,port,"at+cpin?");
+	wait_just_a_bit(HZ/2);
+	p2char=GSM_receive(wc,port);
+	if (debug)
+		printk("Received: %s\n",p2char);
+	
+
+	//If SIM pin has not been entered, enter it
+	if(strcmp(p2char,"+CPIN: SIM PIN")==0)
+	{
+		//Enter PIN and wait for OK
+		do{
+			GSM_send(wc,port,SIM_Enter_string);//"at+cpin=\"3700\"");
+			wait_just_a_bit(3*HZ);
+			p2char=GSM_receive(wc,port);
+			if (debug)
+				printk("Received: %s\n",p2char);
+			//PIN entered but wrong -> exit
+			if(strcmp(p2char,"+CME ERROR: incorrect password")==0)
+			{
+				printk("WRONG SIM PIN!\n");
+				return 1;
+			}
+		} while(strcmp(p2char,"0")!=0);
+	}
+	//if No SIM PIN required
+	else
+	{
+		//Card not inserted
+		if(strcmp(p2char,"+CME ERROR: SIM not inserted")==0)
+		{
+			printk("SIM NOT INSERTED! PLEASE INSERT SIM!\n");
+			return 1;
+
+		}
+		else
+		{
+			//Card unlocked
+			if(strcmp(p2char,"+CPIN: READY")==0)
+			{
+				printk("SIM CARD UNLOCKED!\n");
+			}
+			//Other problems!
+			else{
+				printk("SIM ERROR!\n");
+				return 1;
+			}
+
+
+		}
+			
+		
+	}
+	
+	// Wait until the modem is initialized properly
+	if(debug)
+		printk("Wait some time for GSM PIN init!\n");
+	wait_just_a_bit(10*HZ);
+
+	//text result code ,dial and busy enabled
+	do {
+	GSM_send(wc,port,"atx4");
+	wait_just_a_bit(HZ/10);
+	p2char=GSM_receive(wc,port);
+	if (debug)
+		printk("Received: %s\n",p2char);
+	} while(strcmp(p2char,"0")!=0);
+
+	//Adjust mic volume
+	do {
+	GSM_send(wc,port,"at+cmic=0,0");
+	wait_just_a_bit(HZ/10);
+	p2char=GSM_receive(wc,port);
+	if (debug)
+		printk("Received: %s\n",p2char);
+	} while(strcmp(p2char,"0")!=0);
+
+
+        //Adjust the side-tone level to 0dB
+        do {
+        GSM_send(wc,port,"at+sidet=0");
+        wait_just_a_bit(HZ/10);
+        p2char=GSM_receive(wc,port);
+        if (debug)
+                printk("Received: %s\n",p2char);
+        } while(strcmp(p2char,"0")!=0);
+
+
+        //Set the built in echo canceler
+	//AT+ECHO=<voxGain>,<minMicEnergy>,<sampSlncePrd>,<channel>
+	//
+	// < voxGain >      : the parameter models the acoustic path between ear-piece and microphone.
+	// < minMicEnergy > : the parameter sets the minimum microphone energy level to beattained 
+	//                    before suppression is allowed. A typical value of this parameter is 20.
+	// < sampSlncePrd > : the parameter control the minimum number of speech frames that will be 
+	//                    replace with SID frames when an echo is detected. Atypical value of 
+	//		      this parameter is 4.
+	// <channel>        : channel, can be 0 or 1
+    	//		      1     AUX_AUDIO
+    	//		      0     NORMAL_AUDIO
+        do {
+        GSM_send(wc,port,"at+echo=5000,5,4,0");
+        wait_just_a_bit(HZ/10);
+        p2char=GSM_receive(wc,port);
+        if (debug)
+                printk("Received: %s\n",p2char);
+        } while(strcmp(p2char,"0")!=0);
+
+
+	//Adjust loudspeaker volume
+	do {
+	GSM_send(wc,port,"at+clvl=90");
+	wait_just_a_bit(HZ/10);
+	p2char=GSM_receive(wc,port);
+	if (debug)
+		printk("Received: %s\n",p2char);
+	} while(strcmp(p2char,"0")!=0);
+
+	if(debug)
+		printk("\n");
+	
+	return 0;
+}
+
+//Implements latching of the data in the SPI input register of 
+//the codec. Acts as a chip select. Only the rising edge of
+//the signal matters.
+static void Codec_reg_data_latch(struct wcfxs *wc,int port)
+{
+	//Latch data into the codec by raising and lowering the SPI2UART's GPIO
+	
+	//Lower GPIO_CS
+	//==>  R/~W A3 A2 A1 A0 CH1 CH0 X
+	//==>   0    1  0  1  1  0   0  0 ==0x58
+	fx_write_SPI2UART(wc,port,0x5821);
+
+	
+	//Raise GPIO_CS
+	//==>  R/~W A3 A2 A1 A0 CH1 CH0 X
+	//==>   0    1  0  1  1  0   0  0 ==0x58
+	fx_write_SPI2UART(wc,port,0x5825);
+
+}
+
+//Initializaion of the codec
+static void init_WM8510(struct wcfxs *wc,int port)
+{	
+
+	//Resetting the chip ;Register 0x0;Write any value
+	fx_write_SPI2UART_wo_CS(0x000F); 
+	Codec_reg_data_latch(wc,port);
+
+	//Powering up and enables ;Register 0x1
+	//7bit address + 9bit data= 8bits +8bits
+	// 8bits= 0x02 + 8bits = 0x0B (set BIASEN=1,BUFIOEN=1,VMIDSEL=11)
+	fx_write_SPI2UART_wo_CS(0x020F); 
+	Codec_reg_data_latch(wc,port);
+
+	//Starting the ALC function;Register 0x20; ALCSEL;max gain
+	fx_write_SPI2UART_wo_CS(0x4138); 
+	Codec_reg_data_latch(wc,port);
+
+	//DAC volume. Register 0x0B; 
+	fx_write_SPI2UART_wo_CS(0x16D0); //was 0x16F0
+	Codec_reg_data_latch(wc,port);
+
+	//OSR enable=128 OSR;Register 0x0E;set ADCOSR, High pass filter enabled
+	fx_write_SPI2UART_wo_CS(0x1D08); 
+	Codec_reg_data_latch(wc,port);
+
+        //Register 0x21;
+        fx_write_SPI2UART_wo_CS(0x420B); //ALCLVL -> -7.5dB relative to Full Scale
+					 //ALC hold time 0 ms
+					 //zero crossing disable		
+        Codec_reg_data_latch(wc,port);
+
+
+	//Noise gate enable;Register 0x22;set ALCMODE->limiter!
+	fx_write_SPI2UART_wo_CS(0x4532); //ALCMODE->limiter!
+	//fx_write_SPI2UART_wo_CS(0x4432);   //ALCMODE->Normal
+					   //26.2ms/6db gain ramp up
+					   //3.33ms/6db gain ramp down 
+	Codec_reg_data_latch(wc,port);
+	
+   	//Noise gate enable;Register 0x23;set NGATEN
+	fx_write_SPI2UART_wo_CS(0x4608); 
+	Codec_reg_data_latch(wc,port);
+
+	//Output limiter enable;Register 0x18;disable LIMEN
+	fx_write_SPI2UART_wo_CS(0x3032); 
+	Codec_reg_data_latch(wc,port);
+	
+	//Output limiter gain adjust;Register 0x19;set LIMLVL
+	fx_write_SPI2UART_wo_CS(0x3270); 
+	Codec_reg_data_latch(wc,port);
+
+	//Audio interface register;Register 0x04;
+	//Setting DSP/PCM mode TDM, 16 bit samples
+	fx_write_SPI2UART_wo_CS(0x0818); 
+	Codec_reg_data_latch(wc,port);
+	
+	//Clock generation register;Register 0x06;
+	//Setting CLKSEL to 1; MCLKDIV=1
+	fx_write_SPI2UART_wo_CS(0x0C00); 
+	Codec_reg_data_latch(wc,port);
+	
+	//Companding register;Register 0x05;
+	//Setting ADC_COMP and DAC_COMP to u-law;Loopback disabled
+	fx_write_SPI2UART_wo_CS(0x0A14); 
+	Codec_reg_data_latch(wc,port);
+
+	//Sampling rate register;Register 0x07;
+	//Setting sampling rate to 8kHz
+	fx_write_SPI2UART_wo_CS(0x0E0A); 
+	Codec_reg_data_latch(wc,port);
+
+	//OSR enable=128 OSR;Register 0x0A;set DACOSR=128
+	fx_write_SPI2UART_wo_CS(0x1408); 
+	Codec_reg_data_latch(wc,port);
+
+	//Input PGA enable;Register 0x2;set INPGAEN, set ADCEN:BOOSTENABLE
+	fx_write_SPI2UART_wo_CS(0x0415); 
+	Codec_reg_data_latch(wc,port);
+
+	//Input PGA boost stage: Reg 0x2f;PGABOOST= 0
+	fx_write_SPI2UART_wo_CS(0x5F00); 
+	Codec_reg_data_latch(wc,port);
+
+	//output of DAC switching; Register 0x32
+	//fx_write_SPI2UART_wo_CS(0x6400);//Output of DAC to MONOOUT 
+	fx_write_SPI2UART_wo_CS(0x6401);  //Output of DAC to spkoutP/spkoutN outputs
+	Codec_reg_data_latch(wc,port);
+
+	//MONOOUTPUT mute;reg=0x38; MONOMUTE=1
+	//fx_write_SPI2UART_wo_CS(0x7001);     //the case we have used MONOOUTPUT, MONOOUTPUT not mute
+	fx_write_SPI2UART_wo_CS(0x7040); //for  spkoutP/spkoutN outputs, MONOOUTPUT is mute
+	Codec_reg_data_latch(wc,port);
+
+
+	//DAC startup;Register 0x3; Set DACEN bit
+	//enable MONOOUT 
+	//fx_write_SPI2UART_wo_CS(0x0689); //enable MONOOUT
+	fx_write_SPI2UART_wo_CS(0x0665); //enable spkoutP/spkoutN outputs
+	Codec_reg_data_latch(wc,port);
+
+}
+
+//All the functions for GSM module init
+int Initialize_GSM_module(struct wcfxs *wc,int port)
+{
+	int ret;
+	//Init SPI2UART
+	ret=init_SC16IS750(wc,port);
+	if(ret)
+		return 1;
+	//Init CODEC
+	init_WM8510(wc,port);
+	//Init GSM 
+	ret=init_GSM(wc,port);
+	if(ret)
+		return 1;
+	
+	return 0;
+}
+
+
+
+
+
diff -urP dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi/GSM_module_SPI.h dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi-gsm/GSM_module_SPI.h
--- dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi/GSM_module_SPI.h	1970-01-01 02:00:00.000000000 +0200
+++ dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi-gsm/GSM_module_SPI.h	2010-09-02 16:51:42.000000000 +0300
@@ -0,0 +1,69 @@
+
+#ifndef GSM_MODULE_SPI
+
+
+
+/* Modified by Alex Tao */
+#ifdef CONFIG_4FX_SPI_INTERFACE
+#define SPI_BAUDS   5  /* 12.5 MHz for 100MHz system clock    */
+#define SPI_NCSA    3  /* nCS bit for SPI data                */
+#define SPI_NCSB    12 /* nCS bit for SPI mux                 */
+#else
+#define SPI_BAUDS   49  /* 13.4 MHz for 133MHz system clock    */
+#define SPI_BAUDS_GSM 49 //1.33MHz for 133Mhz system clock; 4 MHz allowed //YN
+/* Use other PF signals */
+#define SPI_NCSA    8    /* Simulate SPORT interface as SPI */
+#define SPI_NCSB    9
+#endif
+
+#define FX_MAX_PORTS   8  // max number of ports in system
+
+#define FX_LED_RED     1
+
+//penev
+#define GSM_MODULE_SPI
+
+
+//#define SPORT_INTERFACE_DEBUG
+#ifdef SPORT_INTERFACE_DEBUG
+#define PRINTK(args...) printk(args)
+#else
+#define PRINTK(args...)
+#endif
+
+#ifdef SPORT_INTERFACE_DEBUG
+static int txCnt = 0, rxCnt = 0;
+#endif
+
+#ifndef SPI_NCSB
+/* Use other PF signals */
+#define SPI_NCSA    8    /* Simulate SPORT interface as SPI */
+#define SPI_NCSB    9
+#endif
+#define SPORT_nPWR	12
+
+#ifndef SPORT1_REGBASE
+#define SPORT1_REGBASE 0xFFC00900
+#endif
+
+#define DEFINE_SPORT1_REG(reg, off) \
+static inline u16 sport1_read_##reg(void) \
+            { return *(volatile unsigned short*)(SPORT1_REGBASE + off); } \
+static inline void sport1_write_##reg(u16 v) \
+            {*(volatile unsigned short*)(SPORT1_REGBASE + off) = v;\
+             __builtin_bfin_ssync();}
+
+
+DEFINE_SPORT1_REG(TCR1,0x00)
+DEFINE_SPORT1_REG(TCR2,0x04)
+DEFINE_SPORT1_REG(TCLKDIV,0x08)
+DEFINE_SPORT1_REG(TFSDIV,0x0C)
+
+DEFINE_SPORT1_REG(RCR1, 0x20)
+DEFINE_SPORT1_REG(RCR2, 0x24)
+DEFINE_SPORT1_REG(RCLKDIV,0x28)
+DEFINE_SPORT1_REG(RFSDIV,0x2C)
+DEFINE_SPORT1_REG(STAT,0x30)
+
+#endif
+
diff -urP dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi/sport_interface.c dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi-gsm/sport_interface.c
--- dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi/sport_interface.c	2010-09-02 16:55:21.000000000 +0300
+++ dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi-gsm/sport_interface.c	2010-09-02 16:51:42.000000000 +0300
@@ -46,56 +46,20 @@
 #include <asm/uaccess.h>
 
 #include "sport_interface.h"
+#include "GSM_module_SPI.h"//YN
 
 
-//#define SPORT_INTERFACE_DEBUG
-#ifdef SPORT_INTERFACE_DEBUG
-#define PRINTK(args...) printk(args)
-#else
-#define PRINTK(args...)
-#endif
-
-#ifdef SPORT_INTERFACE_DEBUG
-static int txCnt = 0, rxCnt = 0;
-#endif
-
-#ifndef SPI_NCSB
-/* Use other PF signals */
-#define SPI_NCSA    8    /* Simulate SPORT interface as SPI */
-#define SPI_NCSB    9
-#endif
-#define SPORT_nPWR	12
-
-#ifndef SPORT1_REGBASE
-#define SPORT1_REGBASE 0xFFC00900
-#endif
-
-#define DEFINE_SPORT1_REG(reg, off) \
-static inline u16 sport1_read_##reg(void) \
-            { return *(volatile unsigned short*)(SPORT1_REGBASE + off); } \
-static inline void sport1_write_##reg(u16 v) \
-            {*(volatile unsigned short*)(SPORT1_REGBASE + off) = v;\
-             __builtin_bfin_ssync();}
-
-
-DEFINE_SPORT1_REG(TCR1,0x00)
-DEFINE_SPORT1_REG(TCR2,0x04)
-DEFINE_SPORT1_REG(TCLKDIV,0x08)
-DEFINE_SPORT1_REG(TFSDIV,0x0C)
-
-DEFINE_SPORT1_REG(RCR1, 0x20)
-DEFINE_SPORT1_REG(RCR2, 0x24)
-DEFINE_SPORT1_REG(RCLKDIV,0x28)
-DEFINE_SPORT1_REG(RFSDIV,0x2C)
-DEFINE_SPORT1_REG(STAT,0x30)
-
-
-static int sport_configure(int baud);
+int sport_configure(int baud);
 
 
 /* When FX_MODE, we need not fill the struct of sport_config */
-static int sport_configure(int baud)
+int sport_configure(int baud)
 {
+
+	//Disable the receiving and transmitter	
+	sport1_write_TCR1( sport1_read_TCR1() & ~(TSPEN) ); 
+	sport1_write_RCR1( sport1_read_RCR1() & ~(RSPEN) ); 
+
 	/* Register SPORTx_TCR1 ( relative details pls refer 12-12 of hardware reference ) 
 	        TCKFE ( Clock Falling Edge Select )   ( Bit14 ) 
           	LTFS ( Bit11) :  0 - Active high TFS; 1 - Active low TFS
@@ -252,6 +216,23 @@
 {
 	sport_configure(baud); /* Default should be 0x1 */
 
+//Raise chip selects PF8 and PF9; ADDEd by YN
+#if (defined(CONFIG_BF533) || defined(CONFIG_BF532))
+	bfin_write_FIO_FLAG_S(1<<8);
+	bfin_write_FIO_FLAG_S(1<<9);
+#endif
+#if (defined(CONFIG_BF536) || defined(CONFIG_BF537))
+	bfin_write_PORTFIO_SET(1<<8);
+	bfin_write_PORTFIO_SET(1<<9);
+#endif
+#if (defined(CONFIG_BF533) || defined(CONFIG_BF532))
+	bfin_write_FIO_FLAG_S( 1 << SPORT_nPWR );
+#endif
+#if (defined(CONFIG_BF536) || defined(CONFIG_BF537))
+	bfin_write_PORTFIO_SET( 1 << SPORT_nPWR );
+#endif
+__builtin_bfin_ssync();//YN
+
 	PRINTK("Before setting, FIOD_DIR = 0x%04x\n", bfin_read_FIO_DIR());
 	PRINTK("Before setting, new_chip_select_mask = 0x%04x\n", new_chip_select_mask);
 	if (new_chip_select_mask & 0xff00) 
@@ -276,9 +257,6 @@
 	bfin_write_PORTFIO_SET( 1 << SPORT_nPWR );
 #endif
 	
-	//Enable SPORT1 interface
-	sport1_write_TCR1( sport1_read_TCR1() | TSPEN );
-
 	return 0; /* succeed */
 }
 
@@ -318,6 +296,7 @@
   	udelay(1000); 
 }
 
+EXPORT_SYMBOL( sport_configure);
 EXPORT_SYMBOL( sport_tx_byte );
 EXPORT_SYMBOL( sport_rx_byte );
 EXPORT_SYMBOL( sport_interface_init );
Binary files build_ip04/dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi/sport_interface.ko and /BACKUP/dahdi-gsm/sport_interface.ko differ
Binary files build_ip04/dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi/sport_interface.o and /BACKUP/dahdi-gsm/sport_interface.o differ
diff -urP dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi/wcfxs.c dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi-gsm/wcfxs.c
--- dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi/wcfxs.c	2010-09-02 16:55:21.000000000 +0300
+++ dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi-gsm/wcfxs.c	2010-09-02 16:51:42.000000000 +0300
@@ -47,7 +47,8 @@
  *  5 Mar. 2010 Dimitar Penev Modified for DAHDI
  * 18 Mar. 2010 Dimitar Penev included IP01 support 
  * for use in Switchfin, based on the previous work done by Atcom
- * 	
+ * 01 Sep. 2010 Dimitar Penev added GSM1 support 	
+ * 
  * Copyright @ 2010 Switchfin <dpn@switchfin.org>
  */
 
@@ -272,19 +273,7 @@
 
 /* ------------------------ Blackfin -------------------------*/
 
-/* Modified by Alex Tao */
-#ifdef CONFIG_4FX_SPI_INTERFACE
-#define SPI_BAUDS   5  /* 12.5 MHz for 100MHz system clock    */
-#define SPI_NCSA    3  /* nCS bit for SPI data                */
-#define SPI_NCSB    12 /* nCS bit for SPI mux                 */
-#else
-#ifdef CONFIG_4FX_SPORT_INTERFACE
-#define SPI_BAUDS   4  /* 13.4 MHz for 133MHz system clock    */
-/* Use other PF signals */
-#define SPI_NCSA    8    /* Simulate SPORT interface as SPI */
-#define SPI_NCSB    9
-#endif
-#endif
+#include "GSM_module_SPI.h"//yn
 
 #define RESET_BIT   4  /* GPIO bit tied to nRESET on Si chips */
 
@@ -338,6 +327,7 @@
 
 #define MOD_TYPE_FXS	0
 #define MOD_TYPE_FXO	1
+#define MOD_TYPE_GSM    2 //added YN
 
 #define MINPEGTIME	10 * 8		/* 30 ms peak to peak gets us no more than 100 Hz */
 #define PEGTIME		50 * 8		/* 50ms peak to peak gets us rings of 10 Hz or more */
@@ -345,6 +335,12 @@
 
 #define NUM_CAL_REGS 12
 
+int outgoing_call_state=0;// YN
+int incomming_call_state=0;// YN
+
+//Used for resheduling the TDM 8-bit slots
+static int card2TDMslot_mapping[NUM_CARDS];// YN
+
 struct calregs {
 	unsigned char vals[NUM_CAL_REGS];
 };
@@ -411,6 +407,19 @@
 	struct dahdi_chan *_chans[NUM_CARDS];
 };
 
+//YN =>from here
+inline void __wcfxs_setcard(struct wcfxs *wc, int card);
+
+static char *SIM_pin="3700";
+static char SIM_Enter_string[20]="at+cpin=\"";
+
+static int debug = 0;
+static void wait_just_a_bit(int foo);
+
+//Must be included after the wcfxs structure definition
+#include "gsm_module.c"
+
+//<=to here
 
 struct wcfxs_desc {
 	char *name;
@@ -434,7 +443,6 @@
 		    int count, int *eof, void *data);
 #endif
 
-static int debug = 0;
 static int robust = 0;
 static int timingonly = 0;
 static int lowpower = 0;
@@ -451,8 +459,7 @@
 
 static int wcfxs_init_ok = 0;
 
-static int wcfxs_init_proslic(struct wcfxs *wc, int card, int fast , int manual, int sane);
-static void wait_just_a_bit(int foo);
+static int wcfxs_init_proslic(struct wcfxs *wc, int card,int TDM_channel_offset, int fast , int manual, int sane);
 
 #ifdef AUDIO_RINGCHECK
 static inline void ring_check(struct wcfxs *wc, int card)
@@ -518,37 +525,39 @@
 int serialnum = 0;
 int notzero=0;
 
+//Modified YN
+//TDM slots are resheduled according to card2TDMslot_mapping
 static inline void wcfxs_transmitprep(struct wcfxs *wc, u8 *writechunk)
 {
 	int x;
+	//static u8 temp[8]={255,137,128,137,255,9,0,9};
 
 	/* Calculate Transmission */
 	dahdi_transmit(&wc->span);
 
 	for (x=0;x<DAHDI_CHUNKSIZE;x++) {
 		if (wc->cardflag & (1 << 7))
-			writechunk[8*x+7] = wc->chans[7].writechunk[x];
+			writechunk[8*x+card2TDMslot_mapping[7]] = wc->chans[7].writechunk[x];//YN
 		if (wc->cardflag & (1 << 6))
-			writechunk[8*x+6] = wc->chans[6].writechunk[x];
+			writechunk[8*x+card2TDMslot_mapping[6]] = wc->chans[6].writechunk[x];//YN
 		if (wc->cardflag & (1 << 5))
-			writechunk[8*x+5] = wc->chans[5].writechunk[x];
+			writechunk[8*x+card2TDMslot_mapping[5]] = wc->chans[5].writechunk[x];//YN
 		if (wc->cardflag & (1 << 4))
-			writechunk[8*x+4] = wc->chans[4].writechunk[x];
-
+			writechunk[8*x+card2TDMslot_mapping[4]] = wc->chans[4].writechunk[x];//YN
 		if (wc->cardflag & (1 << 3))
-			writechunk[8*x+3] = wc->chans[3].writechunk[x];
+			writechunk[8*x+card2TDMslot_mapping[3]] = wc->chans[3].writechunk[x];//YN
 		if (wc->cardflag & (1 << 2))
-			writechunk[8*x+2] = wc->chans[2].writechunk[x];
+			writechunk[8*x+card2TDMslot_mapping[2]] = wc->chans[2].writechunk[x];//YN
 		if (wc->cardflag & (1 << 1))
-			writechunk[8*x+1] = wc->chans[1].writechunk[x];
+			writechunk[8*x+card2TDMslot_mapping[1]] = wc->chans[1].writechunk[x];//YN
 		if (wc->cardflag & (1 << 0)) {
-			writechunk[8*x+0] = wc->chans[0].writechunk[x];
-			//writechunk[8*x+0] = DAHDI_LIN2MU(sw[swi++]);
-			//if (swi == 6) swi = 0;
+			writechunk[8*x+card2TDMslot_mapping[0]] = wc->chans[0].writechunk[x];//YN
 		}
 	}
 }
 
+//Modified YN
+//TDM slots are resheduled according to card2TDMslot_mapping
 static inline void wcfxs_receiveprep(struct wcfxs *wc, u8 *readchunk)
 {
 	int x;
@@ -557,22 +566,21 @@
 	//memset(readchunk, 0, 64);
 	for (x=0;x<DAHDI_CHUNKSIZE;x++) {
 		if (wc->cardflag & (1 << 7))
-			wc->chans[7].readchunk[x] = readchunk[8*x+7];
+			wc->chans[7].readchunk[x] = readchunk[8*x+card2TDMslot_mapping[7]];//YN
 		if (wc->cardflag & (1 << 6))
-			wc->chans[6].readchunk[x] = readchunk[8*x+6];
+			wc->chans[6].readchunk[x] = readchunk[8*x+card2TDMslot_mapping[6]];//YN
 		if (wc->cardflag & (1 << 5))
-			wc->chans[5].readchunk[x] = readchunk[8*x+5];
+			wc->chans[5].readchunk[x] = readchunk[8*x+card2TDMslot_mapping[5]];//YN
 		if (wc->cardflag & (1 << 4))
-			wc->chans[4].readchunk[x] = readchunk[8*x+4];
-
+			wc->chans[4].readchunk[x] = readchunk[8*x+card2TDMslot_mapping[4]];//YN
 		if (wc->cardflag & (1 << 3))
-			wc->chans[3].readchunk[x] = readchunk[8*x+3];
+			wc->chans[3].readchunk[x] = readchunk[8*x+card2TDMslot_mapping[3]];//YN
 		if (wc->cardflag & (1 << 2))
-			wc->chans[2].readchunk[x] = readchunk[8*x+2];
+			wc->chans[2].readchunk[x] = readchunk[8*x+card2TDMslot_mapping[2]];//YN
 		if (wc->cardflag & (1 << 1))
-			wc->chans[1].readchunk[x] = readchunk[8*x+1];
+			wc->chans[1].readchunk[x] = readchunk[8*x+card2TDMslot_mapping[1]];//YN
 		if (wc->cardflag & (1 << 0))
-			wc->chans[0].readchunk[x] = readchunk[8*x+0];
+			wc->chans[0].readchunk[x] = readchunk[8*x+card2TDMslot_mapping[0]];//YN
 	}
 #ifdef AUDIO_RINGCHECK
 	for (x=0;x<wc->cards;x++)
@@ -590,8 +598,7 @@
 }
 
 /* we have only one card at the moment */
-
-static inline void __wcfxs_setcard(struct wcfxs *wc, int card)
+inline void __wcfxs_setcard(struct wcfxs *wc, int card)
 {
 	if (wc->curcard != card) {
 #ifndef SF_IP01
@@ -982,7 +989,7 @@
 					printk("wcfxs: Card %d Going off hook\n", card);
 				dahdi_hooksig(&wc->chans[card], DAHDI_RXSIG_OFFHOOK);
 				if (robust)
-					wcfxs_init_proslic(wc, card, 1, 0, 1);
+					wcfxs_init_proslic(wc, card,card2TDMslot_mapping[card], 1, 0, 1);//YN
 				wc->mod.fxs.oldrxhook[card] = 1;
 			
 			} else if (wc->mod.fxs.oldrxhook[card] && !wc->mod.fxs.debouncehook[card]) {
@@ -1006,7 +1013,7 @@
 	res = wcfxs_getreg(wc, card, 8);
 	if (res) {
 		printk("Ouch, part reset, quickly restoring reality (%d)\n", card);
-		wcfxs_init_proslic(wc, card, 1, 0, 1);
+		wcfxs_init_proslic(wc, card,card2TDMslot_mapping[card],1, 0, 1);
 	} else {
 		res = wcfxs_getreg(wc, card, 64);
 		if (!res && (res != wc->mod.fxs.lasttxhook[card])) {
@@ -1065,10 +1072,17 @@
               if (!(wc->intcount & 0xfc))
                 wcfxs_proslic_recheck_sanity(wc, x);
 #endif
-            } else if (wc->modtype[x] == MOD_TYPE_FXO) {
+	    }
+	    else {
+			if ((wc->modtype[x] == MOD_TYPE_FXO) && (port_type[x] != 'G')) {
               	/* ring detection, despite name */
             	wcfxs_voicedaa_check_hook(wc, x); 
             }
+			else{
+				if (wc->modtype[x] == MOD_TYPE_FXO) 
+					wcfxs_gsm_control(wc, x); 
+			}
+		 }
           }
 
 #ifdef DR_DONT_NEED
@@ -1404,7 +1418,8 @@
 	schedule_timeout(foo);
 }
 
-static int wcfxs_init_voicedaa(struct wcfxs *wc, int card, int fast, int manual, int sane)
+//YN TDM_channel_offset parameter added
+static int wcfxs_init_voicedaa(struct wcfxs *wc, int card, int TDM_channel_offset, int fast, int manual, int sane)//YN
 {
 	unsigned char reg16=0, reg26=0, reg30=0, reg31=0;
 	long newjiffies;
@@ -1448,9 +1463,9 @@
 	wcfxs_setreg(wc, card, 31, reg31);
 
 	/* Set Transmit/Receive timeslot */
-	wcfxs_setreg(wc, card, 34, (card) * 8);
+	wcfxs_setreg(wc, card, 34, ((TDM_channel_offset) * 8)+1);//YN // YN moved to +1 from FSYNC
 	wcfxs_setreg(wc, card, 35, 0x00);
-	wcfxs_setreg(wc, card, 36, (card) * 8);
+	wcfxs_setreg(wc, card, 36, ((TDM_channel_offset) * 8)+1);//YN // YN moved to +1 from FSYNC
 	wcfxs_setreg(wc, card, 37, 0x00);
 
 	/* Enable ISO-Cap */
@@ -1502,7 +1517,8 @@
 	return 0;
 }
 
-static int wcfxs_init_proslic(struct wcfxs *wc, int card, int fast, int manual, int sane)
+//YN TDM_channel_offset parameter added
+static int wcfxs_init_proslic(struct wcfxs *wc, int card, int TDM_channel_offset,int fast, int manual, int sane)
 {
 
 	unsigned short tmp[5];
@@ -1635,9 +1651,9 @@
 
     wcfxs_setreg(wc, card, 1, 0x28);
  	// U-Law 8-bit interface
-    wcfxs_setreg(wc, card, 2, (card) * 8);    // Tx Start count low byte  0
+    wcfxs_setreg(wc, card, 2, ((TDM_channel_offset) * 8)+1);    // Tx Start count low byte  0  // YN moved to +1 from FSYNC
     wcfxs_setreg(wc, card, 3, 0);    // Tx Start count high byte 0
-    wcfxs_setreg(wc, card, 4, (card) * 8);    // Rx Start count low byte  0
+    wcfxs_setreg(wc, card, 4, ((TDM_channel_offset) * 8)+1);    // Rx Start count low byte  0  //YN moved to +1 from FSYNC
     wcfxs_setreg(wc, card, 5, 0);    // Rx Start count high byte 0
     wcfxs_setreg(wc, card, 18, 0xff);     // clear all interrupt
     wcfxs_setreg(wc, card, 19, 0xff);
@@ -1710,7 +1726,7 @@
 		       transfers, not sure why we need to modify state of
 		       SLIC here?
 		    */
-		    wc->mod.fxs.idletxhookstate[chan->chanpos - 1] = 0x2;
+		    wc->mod.fxs.idletxhookstate[chan->chanpos - 1] = 0x2; /* OHT mode when idle */
 		
 		    if (wc->mod.fxs.lasttxhook[chan->chanpos - 1] == 0x1) {
 				// Apply the change if appropriate 
@@ -1819,8 +1835,11 @@
 static int wcfxs_hooksig(struct dahdi_chan *chan, enum dahdi_txsig  txsig)
 {
 	struct wcfxs *wc = chan->pvt;
+	size_t len;// YN
+	char GSM_Call_string[30]="atd";// YN
+
 	int reg=0;
-	if (wc->modtype[chan->chanpos - 1] == MOD_TYPE_FXO) {
+	if((wc->modtype[chan->chanpos - 1] == MOD_TYPE_FXO)&& (port_type[chan->chanpos - 1] != 'G')) {
 		/* XXX Enable hooksig for FXO XXX */
 		switch(txsig) {
 		case DAHDI_TXSIG_START:
@@ -1839,20 +1858,35 @@
 		default:
 			printk("wcfxo: Can't set tx state to %d\n", txsig);
 		}
-	} else {
+	} 
+	if (wc->modtype[chan->chanpos - 1] == MOD_TYPE_FXS) {//YN
 		switch(txsig) {
 		case DAHDI_TXSIG_ONHOOK:
+			//incomming_call_state 0, initial state+first ring, 1, ringing, 2 conversastion 				
+			if(incomming_call_state==2) {//During call 
+					GSM_send(wc,chan->chanpos - 1,"ath");//was GSM_send(wc,0,"ath");
+					incomming_call_state=0;//Initial state
+			}
+
 			wcfxs_set_led(wc, chan->chanpos, FX_LED_GREEN);
 			if (debug)
 			    printk("DAHDI_TXSIG_ONHOOK FXS %d\n", chan->chanpos - 1);
 			switch(chan->sig) {
 			case DAHDI_SIG_EM:
+				if (debug)
+			    		printk("DAHDI_SIG_EM FXS %d\n", chan->chanpos - 1);
 			case DAHDI_SIG_FXOKS:
+				if (debug)
+			    		printk("DAHDI_SIG_FXOKS FXS %d\n", chan->chanpos - 1);
 			case DAHDI_SIG_FXOLS:
+				if (debug)
+			    		printk("DAHDI_SIG_FXOLS FXS %d\n", chan->chanpos - 1);
 			        //wc->mod.fxs.lasttxhook[chan->chanpos-1] = 1; /* power off audio paths */
 				wc->mod.fxs.lasttxhook[chan->chanpos-1] = wc->mod.fxs.idletxhookstate[chan->chanpos-1];
 				break;
 			case DAHDI_SIG_FXOGS:
+				if (debug)
+			    		printk("DAHDI_SIG_FXOGS %d\n", chan->chanpos - 1);
 				wc->mod.fxs.lasttxhook[chan->chanpos-1] = 3;
 				break;
 			}
@@ -1863,9 +1897,15 @@
 			    printk("DAHDI_TXSIG_OFFHOOK FXS %d\n", chan->chanpos - 1);
 			switch(chan->sig) {
 			case DAHDI_SIG_EM:
+				if (debug)
+			    		printk("DAHDI_SIG_EM FXS %d\n", chan->chanpos - 1);
+
 				wc->mod.fxs.lasttxhook[chan->chanpos-1] = 5;
 				break;
 			default:
+				if (debug)
+			    		printk("default detected %d\n", chan->chanpos - 1);
+
 				wc->mod.fxs.lasttxhook[chan->chanpos-1] = wc->mod.fxs.idletxhookstate[chan->chanpos-1];
 				break;
 			}
@@ -1884,6 +1924,62 @@
 		default:
 			printk("wcfxs: Can't set tx state to %d\n", txsig);
 		}
+
+		if (debug)
+			printk("Setting FXS hook state to %d (%02x)\n", txsig, reg);
+
+#if 1
+		wcfxs_setreg(wc, chan->chanpos - 1, 64, wc->mod.fxs.lasttxhook[chan->chanpos-1]);
+#endif
+	}
+	if ((wc->modtype[chan->chanpos - 1] == MOD_TYPE_FXO) && (port_type[chan->chanpos - 1] == 'G')) {//YN
+		/* XXX Enable hooksig for GSM */
+		switch(txsig) {
+		case DAHDI_TXSIG_START:
+			if (debug)
+			    printk("DAHDI_TXSIG_START GSM %d\n", chan->chanpos - 1);
+			if(strlen(chan->txdialbuf)!=0){
+				// The line below is necessary when we call and the other side is BUSY
+				// Without this line -> blank signal is received
+				chan->rxhooksig = DAHDI_RXSIG_OFFHOOK;// YN
+				//Generate the GSM calling number string
+				strcpy(GSM_Call_string,"atd");
+				if (debug)
+					printk("chan->txdialbuf => %s\n",chan->txdialbuf);
+				strcat(GSM_Call_string,chan->txdialbuf);
+				len=strlen( GSM_Call_string);
+				GSM_Call_string[len-1]=0;//There is a "w" char which must be removed
+				strcat(GSM_Call_string,";");
+				if (debug)
+					printk("GSM string => %s\n",GSM_Call_string);
+				
+				if((outgoing_call_state==0)&&(incomming_call_state==0)){
+					GSM_send(wc,chan->chanpos - 1,GSM_Call_string);//"atd0899359529;");
+					outgoing_call_state=1;
+				}
+				break;
+			}
+		case DAHDI_TXSIG_OFFHOOK:
+			if(incomming_call_state==1){//During ringing DAHDI gives OFFHOOK
+					incomming_call_state=2;
+					GSM_send(wc,chan->chanpos - 1,"ata");//was GSM_send(wc,0,"ata");//Answer the call
+			}
+			if (debug)
+			    printk("DAHDI_TXSIG_OFFHOOK GSM %d\n", chan->chanpos - 1);
+			wc->mod.fxo.offhook[chan->chanpos - 1] = 1;
+			break;
+		case DAHDI_TXSIG_ONHOOK:
+			if(outgoing_call_state==2) {
+					GSM_send(wc,chan->chanpos - 1,"ath");//was GSM_send(wc,0,"ath");//hangup for GSM
+					outgoing_call_state=0;
+			}
+			if (debug)
+			    printk("DAHDI_TXSIG_ONHOOK GSM %d\n", chan->chanpos - 1);
+			wc->mod.fxo.offhook[chan->chanpos - 1] = 0;
+			break;
+		default:
+			printk("wcfxo: Can't set tx state to %d (GSM)\n", txsig);
+		}
 #if 1
 		if (debug) {
 		    char tmp;
@@ -1941,10 +2037,18 @@
 	/* Finalize signalling  */
 	for (x=0;x<wc->cards;x++) {
 		if (wc->cardflag & (1 << x)) {
-			if (wc->modtype[x] == MOD_TYPE_FXO)
-				wc->chans[x].sigcap = DAHDI_SIG_FXSKS | DAHDI_SIG_FXSLS | DAHDI_SIG_SF | DAHDI_SIG_CLEAR;
-			else
-				wc->chans[x].sigcap = DAHDI_SIG_FXOKS | DAHDI_SIG_FXOLS | DAHDI_SIG_FXOGS | DAHDI_SIG_SF | DAHDI_SIG_EM | DAHDI_SIG_CLEAR;
+			switch(wc->modtype[x])
+			{
+				case MOD_TYPE_FXO:
+					wc->chans[x].sigcap = DAHDI_SIG_FXSKS | DAHDI_SIG_FXSLS | DAHDI_SIG_SF | DAHDI_SIG_CLEAR;
+					break;
+				case MOD_TYPE_FXS: 
+					wc->chans[x].sigcap = DAHDI_SIG_FXOKS | DAHDI_SIG_FXOLS | DAHDI_SIG_FXOGS | DAHDI_SIG_SF | DAHDI_SIG_EM | DAHDI_SIG_CLEAR;			
+					break;
+				case MOD_TYPE_GSM://Added YN
+					wc->chans[x].sigcap = DAHDI_SIG_FXSKS | DAHDI_SIG_FXSLS | DAHDI_SIG_SF | DAHDI_SIG_CLEAR;
+					break;
+			}
 		}
 	}
 }
@@ -1976,12 +2080,7 @@
 static int wcfxs_hardware_init(struct wcfxs *wc)
 {
 	/* Hardware stuff */
-	unsigned char x;
-#ifdef	MULTI_SPI_FRAMEWORK
-	char          port_type[8];
-#else
-	char          port_type[FX_MAX_PORTS];
-#endif
+	unsigned char x,TDM_channel_offset;
         int           i;
 
 #ifdef CONFIG_4FX_SPI_INTERFACE
@@ -2016,6 +2115,7 @@
 
 #ifdef MULTI_SPI_FRAMEWORK
 	multi_spi_auto_detect(port_type);
+        gsm_auto_detect(wc,port_type, RESET_BIT);//added YN
 
 	for(i=0; i<multi_spi_board_size(); i++) {
 	  printk("port: %d port_type: %c\n", i+1, port_type[i]);
@@ -2023,6 +2123,8 @@
 	
 #else
 	fx_auto_detect(port_type, RESET_BIT);
+        gsm_auto_detect(wc,port_type, RESET_BIT);//added YN
+
 	for(i=0; i<FX_MAX_PORTS; i++) {
 	  printk("port: %d port_type: %c\n", i+1, port_type[i]);
 	}
@@ -2036,54 +2138,97 @@
 #endif
 	/* configure daughter cards */
 
+	// YN Initialization of an array (resheduling TDM slots)
+	memset(card2TDMslot_mapping, -1, sizeof(card2TDMslot_mapping));//Initially no slot is occupied!
+
+	
+	//YN
+	//Since the TDM slot of the GSM module is not configurable we must allow
+	//it to take the first and second TDM slots. For this purpose we must
+	//check if a GSM module is available  and assign the first TDM slots to it.
+	TDM_channel_offset=0;
+	for (x=0;x<wc->cards;x++) {
+		if (port_type[x] == 'G') {
+			//Init GSM
+			if (!(Initialize_GSM_module(wc,x))){
+
+				wc->modtype[x]=MOD_TYPE_FXO;//WAS MOD_TYPE_GSM
+			
+				//Each GSM channel occupies two TDM slots (16-bit word!).
+				//Since we will use companding only the first 8 bits are meaningful. 
+				//The second 8 bits will however also be occupied!
+				TDM_channel_offset=2;//The next available TDM slot. 
+				card2TDMslot_mapping[x]=0;//Slot number occupied
+				wc->cardflag |= (1 << x);//YN This port is registered with zaptel
+				printk("Module %d - GSM : TDM slot %d\n",x,card2TDMslot_mapping[x]);//YN
+				break;//Only one GSM Module is allowed!
+			}
+			else{
+				printk("Module %d: FAILED GSM\n", x);
+			}
+		}//end of port_type[x]=='G'
+	}//end for
+	//bfin_write_FIO_FLAG_S(1<<14);//for test only
+
 	for (x=0;x<wc->cards;x++) {
 	  int sane=0,ret=0,readi=0;
 
 	  if (port_type[x] == 'O') {
-	    if (!(ret = wcfxs_init_voicedaa(wc, x, 0, 0, sane))) {
-	      wc->cardflag |= (1 << x);
-	      printk("Module %d: Installed -- AUTO FXO (%s mode)\n",x, fxo_modes[_opermode].name);
-	    } else
+	    if (!(ret = wcfxs_init_voicedaa(wc, x,TDM_channel_offset, 0, 0, sane))) {// changed YN
+	      wc->cardflag |= (1 << x);//YN
+	      printk("Module %d: Installed -- AUTO FXO (%s mode), TDM slot %d\n",x, fxo_modes[_opermode].name,TDM_channel_offset);//YN
+	      card2TDMslot_mapping[x]=TDM_channel_offset;
+	    } //end if (!...
+	    else
 	      printk("Module %d: Not installed\n", x);
-	  }
-	  else {
+	   TDM_channel_offset++; 
+ 	   continue;
+	  }//end port_type[x]=='O'
+	  //else {
+	  if (port_type[x] == 'S') {
 		
 	    sane=0;
 	    /* Init with Automatic Calibaration */
-	    if (!(ret = wcfxs_init_proslic(wc, x, 0, 0, sane))) {
-	      wc->cardflag |= (1 << x);
+	    if (!(ret = wcfxs_init_proslic(wc, x,TDM_channel_offset, 0, 0, sane))) {//changed YN
+	      wc->cardflag |= (1 << x);//YN
+	      card2TDMslot_mapping[x]=TDM_channel_offset;//added YN
 	      if (debug) {
 		readi = wcfxs_getreg(wc,x,LOOP_I_LIMIT);
 		printk("Proslic module %d loop current is %dmA\n",x,
 		       ((readi*3)+20));
-	      }
-	      printk("Module %d: Installed -- AUTO FXS\n",x);
-	    } 
+	      }//end debug
+	      printk("Module %d: Installed -- AUTO FXS, TDM slot %d\n",x,TDM_channel_offset);
+	      TDM_channel_offset++;//YN
+	    } //end if(!(ret=...
 	    else 
 	    {
 	          if(ret != -2) 
 		   {
 			sane=1;
 			/* Init with Manual Calibration */
-			if (!wcfxs_init_proslic(wc, x, 0, 1, sane)) 
+			if (!wcfxs_init_proslic(wc, x,TDM_channel_offset, 0, 1, sane)) 
 			{
-				wc->cardflag |= (1 << x);
+				wc->cardflag |= (1 << x);//YN
+				card2TDMslot_mapping[x]=TDM_channel_offset;//Added YN
                             if (debug) 
 				{
                                    readi = wcfxs_getreg(wc,x,LOOP_I_LIMIT);
                                     printk("Proslic module %d loop current is %dmA\n",x,
                                     ((readi*3)+20));
-                            }
-				printk("Module %d: Installed -- MANUAL FXS\n",x);
-			} 
+                            }//end debug
+				printk("Module %d: Installed -- MANUAL FXS, TDM slot %d\n",x,TDM_channel_offset);
+				TDM_channel_offset++;//added YN
+			} //end if(!wcfxs_init....
 			else 
 			{
 				printk("Module %d: FAILED FXS (%s)\n", x, fxshonormode ? fxo_modes[_opermode].name : "FCC");
-			} 
-		  } 
-	    } 
-	  }
-	}
+			} //end else
+		  } //end (ret!=-2
+	    } //end else
+	  }//end if (port_type[x] == 'S') 
+	//TDM_channel_offset++;
+	}//end for (x=0;x<wc->cards;x++) 
+
 
 	/* Return error if nothing initialized okay. */
 	if (!wc->cardflag && !timingonly) {
@@ -2227,7 +2372,7 @@
 	}
 	#endif
 }
-
+module_param(SIM_pin, charp, 0600);// New parameter YN
 module_param(debug, int, 0600);
 module_param(loopcurrent, int, 0600);
 module_param(robust, int, 0600);
 
diff -urP dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi/dahdi-base.c dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi-gsm/dahdi-base.c
--- dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi/dahdi-base.c	2010-04-19 22:42:53.000000000 +0300
+++ dahdi-linux-complete-2.3.0.1+2.3.0/linux/drivers/dahdi-gsm/dahdi-base.c	2010-09-02 16:48:07.000000000 +0300
@@ -3330,6 +3330,7 @@
 		case 'T':
 			chan->digitmode = DIGIT_MODE_DTMF;
 			chan->tonep = 0;
+			chan->span->hooksig(chan, DAHDI_TXSIG_START);
 			break;
 		case 'M':
 			chan->digitmode = DIGIT_MODE_MFR1;
@@ -3346,6 +3347,7 @@
 		case 'P':
 			chan->digitmode = DIGIT_MODE_PULSE;
 			chan->tonep = 0;
+			chan->span->hooksig(chan, DAHDI_TXSIG_START);
 			break;
 		default:
 			if ((c != 'W') && (chan->digitmode == DIGIT_MODE_PULSE)) {
