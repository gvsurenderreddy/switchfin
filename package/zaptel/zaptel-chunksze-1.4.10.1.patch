--- kernel/zaptel-base.c	2008-04-03 19:27:33.000000000 -0400
+++ kernel/zaptel-base.c	2008-08-25 15:06:34.000000000 -0400
@@ -2112,7 +2112,7 @@
 				set_txtone(chan,0,0,0);
 			}
 		}
-		chan->otimer = timeout * ZT_CHUNKSIZE;			/* Otimer is timer in samples */
+		chan->otimer = timeout;			/* Otimer is timer in samples */
 		return;
 	}
 	if (chan->span->hooksig) {
@@ -2120,7 +2120,7 @@
 			chan->txhooksig = txsig;
 			chan->span->hooksig(chan, txsig);
 		}
-		chan->otimer = timeout * ZT_CHUNKSIZE;			/* Otimer is timer in samples */
+		chan->otimer = timeout;			/* Otimer is timer in samples */
 		return;
 	} else {
 		for (x=0;x<NUM_SIGS;x++) {
@@ -2131,7 +2131,7 @@
 				chan->txhooksig = txsig;
 				chan->txsig = outs[x][txsig+1];
 				chan->span->rbsbits(chan, chan->txsig);
-				chan->otimer = timeout * ZT_CHUNKSIZE;	/* Otimer is timer in samples */
+				chan->otimer = timeout;	/* Otimer is timer in samples */
 				return;
 			}
 		}
@@ -3931,7 +3931,7 @@
 			break;
 		case ZT_MAINT_LOOPUP:
 		case ZT_MAINT_LOOPDOWN:
-			spans[maint.spanno]->mainttimer = ZT_LOOPCODE_TIME * ZT_CHUNKSIZE;
+			spans[maint.spanno]->mainttimer = ZT_LOOPCODE_TIME;
 			rv = spans[maint.spanno]->maint(spans[maint.spanno], maint.command);
 			spin_unlock_irqrestore(&spans[maint.spanno]->lock, flags);
 			if (rv) return rv;
@@ -5838,7 +5838,7 @@
 		zt_rbs_sethook(chan, ZT_TXSIG_OFFHOOK, ZT_TXSTATE_OFFHOOK, 0);
 		/* See if we've gone back on hook */
 		if ((chan->rxhooksig == ZT_RXSIG_ONHOOK) && (chan->rxflashtime > 2))
-			chan->itimerset = chan->itimer = chan->rxflashtime * ZT_CHUNKSIZE;
+			chan->itimerset = chan->itimer = chan->rxflashtime;
 		wake_up_interruptible(&chan->txstateq);
 		break;
 		
@@ -5880,7 +5880,7 @@
 			break;
 		}
 		chan->txstate = ZT_TXSTATE_PULSEAFTER;
-		chan->otimer = chan->pulseaftertime * ZT_CHUNKSIZE;
+		chan->otimer = chan->pulseaftertime;
 		wake_up_interruptible(&chan->txstateq);
 		break;
 
@@ -5945,7 +5945,7 @@
 			}
 #endif
 			/* set wink timer */
-			chan->itimerset = chan->itimer = chan->rxwinktime * ZT_CHUNKSIZE;
+			chan->itimerset = chan->itimer = chan->rxwinktime;
 			break;
 		    case ZT_RXSIG_ONHOOK: /* went on hook */
 			/* This interface is now going on hook.
@@ -5955,10 +5955,10 @@
 #if defined(EMFLASH) || defined(EMPULSE)
 			else {
 #ifdef EMFLASH
-				chan->itimerset = chan->itimer = chan->rxflashtime * ZT_CHUNKSIZE;
+				chan->itimerset = chan->itimer = chan->rxflashtime;
 
 #else /* EMFLASH */
-				chan->itimerset = chan->itimer = chan->rxwinktime * ZT_CHUNKSIZE;
+				chan->itimerset = chan->itimer = chan->rxwinktime;
 
 #endif /* EMFLASH */
 				chan->gotgs = 0;
@@ -5981,12 +5981,12 @@
 		if (chan->txstate != ZT_TXSTATE_OFFHOOK) break;
 #ifdef	FXSFLASH
 		if (rxsig == ZT_RXSIG_ONHOOK) {
-			chan->itimer = ZT_FXSFLASHMAXTIME * ZT_CHUNKSIZE;
+			chan->itimer = ZT_FXSFLASHMAXTIME;
 			break;
 		} else 	if (rxsig == ZT_RXSIG_OFFHOOK) {
 			if (chan->itimer) {
 				/* did the offhook occur in the window? if not, ignore both events */
-				if (chan->itimer <= ((ZT_FXSFLASHMAXTIME - ZT_FXSFLASHMINTIME) * ZT_CHUNKSIZE))
+				if (chan->itimer <= ((ZT_FXSFLASHMAXTIME - ZT_FXSFLASHMINTIME)))
 					__qevent(chan, ZT_EVENT_WINKFLASH);
 			}
 			chan->itimer = 0;
@@ -6055,7 +6055,7 @@
 			if ((chan->txstate != ZT_TXSTATE_DEBOUNCE) &&
 			    (chan->txstate != ZT_TXSTATE_KEWL) && 
 			    (chan->txstate != ZT_TXSTATE_AFTERKEWL)) {
-				chan->itimerset = chan->itimer = chan->rxflashtime * ZT_CHUNKSIZE;
+				chan->itimerset = chan->itimer = chan->rxflashtime;
 			}
 			if (chan->txstate == ZT_TXSTATE_KEWL)
 				chan->kewlonhook = 1;
@@ -6159,7 +6159,8 @@
 				rxlin = ZT_XLAW(rxchunk[x], ss);
 				txlin = ZT_XLAW(txchunk[x], ss);
 				if (ss->echostate == ECHO_STATE_PRETRAINING) {
-					if (--ss->echotimer <= 0) {
+					ss->echotimer -= ZT_CHUNKTIME;
+					if (ss->echotimer <= 0) {
 						ss->echotimer = 0;
 						ss->echostate = ECHO_STATE_STARTTRAINING;
 					}
@@ -6277,7 +6278,11 @@
 	int x,r;
 
 	if (ms->dialing) ms->afterdialingtimer = 50;
-	else if (ms->afterdialingtimer) ms->afterdialingtimer--;
+	else if (ms->afterdialingtimer) {
+		ms->afterdialingtimer -= ZT_CHUNKTIME;
+		if (ms->afterdialingtimer < 0)
+			ms->afterdialingtimer = 0;
+	}
 	if (ms->afterdialingtimer && (!(ms->flags & ZT_FLAG_PSEUDO))) {
 		/* Be careful since memset is likely a macro */
 		rxb[0] = ZT_LIN2X(0, ms);
@@ -7200,8 +7205,9 @@
 		}
 		if (&span->chans[x] == span->chans[x].master) {
 			if (span->chans[x].otimer) {
-				span->chans[x].otimer -= ZT_CHUNKSIZE;
+				span->chans[x].otimer -= ZT_CHUNKTIME;
 				if (span->chans[x].otimer <= 0) {
+					span->chans[x].otimer = 0;
 					__rbs_otimer_expire(&span->chans[x]);
 				}
 			}
@@ -7244,7 +7250,7 @@
 		spin_unlock_irqrestore(&span->chans[x].lock, flags);
 	}
 	if (span->mainttimer) {
-		span->mainttimer -= ZT_CHUNKSIZE;
+		span->mainttimer -= ZT_CHUNKTIME;
 		if (span->mainttimer <= 0) {
 			span->mainttimer = 0;
 			if (span->maint)
@@ -7292,18 +7298,27 @@
 					__zt_real_receive(&span->chans[x]);
 			}
 			if (span->chans[x].itimer) {
-				span->chans[x].itimer -= ZT_CHUNKSIZE;
+				span->chans[x].itimer -= ZT_CHUNKTIME;
 				if (span->chans[x].itimer <= 0) {
+					span->chans[x].itimer = 0;
 					rbs_itimer_expire(&span->chans[x]);
 				}
 			}
-			if (span->chans[x].ringdebtimer)
-				span->chans[x].ringdebtimer--;
+
+			if (span->chans[x].ringdebtimer) {
+				span->chans[x].ringdebtimer -= ZT_CHUNKTIME;
+				if (span->chans[x].ringdebtimer < 0)
+					span->chans[x].ringdebtimer = 0;
+			}
+
 			if (span->chans[x].sig & __ZT_SIG_FXS) {
-				if (span->chans[x].rxhooksig == ZT_RXSIG_RING)
+				if (span->chans[x].rxhooksig == ZT_RXSIG_RING){
 					span->chans[x].ringtrailer = ZT_RINGTRAILER;
+				}	
 				else if (span->chans[x].ringtrailer) {
-					span->chans[x].ringtrailer-= ZT_CHUNKSIZE;
+					span->chans[x].ringtrailer-= ZT_CHUNKTIME;
+					if (span->chans[x].ringtrailer < 0)
+						span->chans[x].ringtrailer  = 0;
 					/* See if RING trailer is expired */
 					if (!span->chans[x].ringtrailer && !span->chans[x].ringdebtimer) 
 						__qevent(&span->chans[x],ZT_EVENT_RINGOFFHOOK);
@@ -7311,9 +7326,10 @@
 			}
 			if (span->chans[x].pulsetimer)
 			{
-				span->chans[x].pulsetimer--;
+				span->chans[x].pulsetimer-= ZT_CHUNKTIME;;
 				if (span->chans[x].pulsetimer <= 0)
 				{
+					span->chans[x].pulsetimer = 0;
 					if (span->chans[x].pulsecount)
 					{
 						if (span->chans[x].pulsecount > 12) {
--- kernel/zaptel.h	2008-03-25 14:42:53.000000000 -0400
+++ kernel/zaptel.h	2008-08-25 15:06:49.000000000 -0400
@@ -157,10 +157,11 @@
 
 #define ZT_CODE	'J'
 
-/* Default chunk size for conferences and such -- static right now, might make
-   variable sometime.  8 samples = 1 ms = most frequent service interval possible
-   for a USB device */
-#define ZT_CHUNKSIZE		 8
+/* Default chunk size for conferences and such.
+ * 8 samples = 1 ms = most frequent service interval possible for a USB device
+ */
+#define ZT_CHUNKSIZE            8 * SF_CHUNKSIZE /* SF_CHUNKSIZE should be 1 or 2 (ms) */
+#define ZT_CHUNKTIME            (ZT_CHUNKSIZE / 8) /* 8kHz */
 #define ZT_MIN_CHUNKSIZE	 ZT_CHUNKSIZE
 #define ZT_DEFAULT_CHUNKSIZE	 ZT_CHUNKSIZE
 #define ZT_MAX_CHUNKSIZE 	 ZT_CHUNKSIZE
@@ -1194,17 +1195,17 @@
 #define	ZT_DEFAULT_PULSEBREAKTIME 50	/* 50 ms of line open when dial pulsing */
 #define	ZT_DEFAULT_PULSEAFTERTIME 750	/* 750ms between dial pulse digits */
 
-#define	ZT_MINPULSETIME (15 * 8)	/* 15 ms minimum */
+#define	ZT_MINPULSETIME 15 	/* 15 ms minimum */
 
 #ifdef SHORT_FLASH_TIME
-#define	ZT_MAXPULSETIME (80 * 8)	/* we need 80 ms, not 200ms, as we have a short flash */
+#define	ZT_MAXPULSETIME 80 	/* we need 80 ms, not 200ms, as we have a short flash */
 #else
-#define	ZT_MAXPULSETIME (200 * 8)	/* 200 ms maximum */
+#define	ZT_MAXPULSETIME 200 	/* 200 ms maximum */
 #endif
 
-#define	ZT_PULSETIMEOUT ((ZT_MAXPULSETIME / 8) + 50)
+#define	ZT_PULSETIMEOUT (ZT_MAXPULSETIME  + 50) /*in ms*/
 
-#define ZT_RINGTRAILER (50 * 8)	/* Don't consider a ring "over" until it's been gone at least this
+#define ZT_RINGTRAILER (50)	/* Don't consider a ring "over" until it's been gone at least this
 									   much time */
 
 #define	ZT_LOOPCODE_TIME 10000		/* send loop codes for 10 secs */
--- ztscan.c	2008-03-18 18:53:01.000000000 -0400
+++ ztscan.c	2008-10-18 13:20:39.000000000 -0400
@@ -102,7 +102,11 @@
 
 	if (params.sigcap & (__ZT_SIG_DACS |  ZT_SIG_CAS)) {
 		/* this is a digital span */
-		fprintf(stdout, "type=digital-%s\n", spaninfo.spantype);
+		if (spaninfo.totalchans != 31)
+		//fprintf(stdout, "type=digital-%s\n", spaninfo.spantype);
+			fprintf(stdout, "type=digital-T1\n");
+		else
+			fprintf(stdout, "type=digital-E1\n");
 		fprintf(stdout, "syncsrc=%d\n", spaninfo.syncsrc);
 		fprintf(stdout, "lbo=%s\n", spaninfo.lboname);
 		fprintf(stdout, "coding_opts=");
