--- drivers/isdn/hardware/mISDN/dsp_cmx.c	2009-08-27 19:26:15.000000000 +0300
+++ drivers/isdn/hardware/mISDN/dsp_cmx_.c	2009-08-28 00:14:01.000000000 +0300
@@ -1138,7 +1138,11 @@
 	 * also add delay if requested by PH_SIGNAL
 	 */
 	if (dsp->rx_W < 0) {
-		if (dsp->features.has_jitter) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+                if (dsp->features.unclocked) {
+#else
+                if (dsp->features.has_jitter) {
+#endif
 			dsp->rx_R = (hh->dinfo & CMX_BUFF_MASK);
 			dsp->rx_W = (dsp->rx_R+dsp->cmx_delay) & CMX_BUFF_MASK;
 		} else {
@@ -1147,9 +1151,15 @@
 		}
 	}
 	/* if frame contains time code, write directly */
-	if (dsp->features.has_jitter) {
-		dsp->rx_W = (hh->dinfo & CMX_BUFF_MASK);
-	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+        if (dsp->features.unclocked) {
+#else
+        if (dsp->features.has_jitter) {
+#endif
+                dsp->rx_W = (hh->dinfo & CMX_BUFF_MASK);
+#warning remove me
+                printk(KERN_DEBUG "%s %08x\n", dsp->inst.name, hh->dinfo);
+        }
 	/*
 	 * if we underrun (or maybe overrun),
 	 * we set our new read pointer, and write silence to buffer
--- drivers/isdn/hardware/mISDN/dsp_octwareec.h	2009-08-27 19:26:15.000000000 +0300
+++ drivers/isdn/hardware/mISDN/dsp_octwareec_.h	2009-08-28 00:23:37.000000000 +0300
@@ -73,7 +73,7 @@
 	} else {
 		printk(KERN_ERR
 		    "echo_can_create error: kmalloc failed "
-		    "(requested %ld bytes)\n",
+		    "(requested %lu bytes)\n",
 		    sizeof(struct echo_can_state));
 	}
 
--- drivers/isdn/hardware/mISDN/dsp_pipeline.c	2009-08-27 19:26:15.000000000 +0300
+++ drivers/isdn/hardware/mISDN/dsp_pipeline_.c	2009-08-28 00:38:56.000000000 +0300
@@ -35,22 +35,40 @@
 
 /* uncomment for debugging */
 /*#define PIPELINE_DEBUG*/
-
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+extern struct mISDN_dsp_element *dsp_hwec;
+#else
 extern mISDN_dsp_element_t *dsp_hwec;
+#endif
+
 extern void dsp_hwec_enable          (dsp_t *dsp, const char *arg);
 extern void dsp_hwec_disable         (dsp_t *dsp);
 extern int  dsp_hwec_init            (void);
 extern void dsp_hwec_exit            (void);
 
 typedef struct _dsp_pipeline_entry {
-	mISDN_dsp_element_t *elem;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+        struct mISDN_dsp_element *elem;
+#else
+        mISDN_dsp_element_t *elem;
+#endif
 	void                *p;
 	struct list_head     list;
 } dsp_pipeline_entry_t;
 
 typedef struct _dsp_element_entry {
-	mISDN_dsp_element_t *elem;
-	struct class_device  dev;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+        struct mISDN_dsp_element *elem;
+        struct device  dev;
+
+#elif LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 26)
+        mISDN_dsp_element_t *elem;
+        struct device dev;
+
+#else
+        mISDN_dsp_element_t *elem;
+        struct class_device dev;
+#endif
 	struct list_head     list;
 } dsp_element_entry_t;
 
@@ -58,24 +76,42 @@
 static LIST_HEAD(dsp_elements);
 
 /* sysfs */
-static void elements_class_release (struct class_device *dev)
-{}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+static void elements_release(struct device *dev) {}
+#else
+static void elements_class_release (struct class_device *dev) {}
+#endif
 
 static struct class elements_class = {
 	.name = "mISDN-dsp-elements",
 #ifndef CLASS_WITHOUT_OWNER
 	.owner = THIS_MODULE,
 #endif
-	.release = &elements_class_release,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+        .dev_release = &elements_release,
+#else
+        .release = &elements_class_release,
+#endif
 };
 
-static ssize_t attr_show_args (struct class_device *dev, char *buf)
-{
-	mISDN_dsp_element_t *elem = class_get_devdata(dev);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+static ssize_t attr_show_args (struct device *dev, struct device_attribute *attr, char *buf) {
+        struct mISDN_dsp_element *elem = dev_get_drvdata(dev);
+
+#elif LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 26)
+static ssize_t attr_show_args (struct device *dev, struct device_attribute *attr, char *buf) {
+        mISDN_dsp_element_t *elem = dev_get_drvdata(dev);
+
+#else
+static ssize_t attr_show_args (struct class_device *dev, char *buf) {
+        mISDN_dsp_element_t *elem = class_get_devdata(dev);
+#endif
 	ssize_t len = 0;
 	int i = 0;
 
-	*buf = 0;
+#if LINUX_VERSION_CODE != KERNEL_VERSION(2, 6, 26)
+        *buf = 0;
+#endif
 	for (; i < elem->num_args; ++i)
 		len = sprintf(buf, "%sName:        %s\n%s%s%sDescription: %s\n\n", buf,
 					  elem->args[i].name,
@@ -87,12 +123,28 @@
 	return len;
 }
 
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+static struct device_attribute element_attributes[] = {
+        __ATTR(args, 0444, attr_show_args, NULL),
+};
+
+int mISDN_dsp_element_register (struct mISDN_dsp_element *elem) {
+
+#elif LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 26)
+static struct device_attribute element_attributes[] = {
+        __ATTR(args, 0444, attr_show_args, NULL),
+};
+
+int mISDN_dsp_element_register (mISDN_dsp_element_t *elem) {
+
+#else
 static struct class_device_attribute element_attributes[] = {
-	__ATTR(args, 0444, attr_show_args, NULL),
+        __ATTR(args, 0444, attr_show_args, NULL),
 };
 
-int mISDN_dsp_element_register (mISDN_dsp_element_t *elem)
-{
+int mISDN_dsp_element_register (mISDN_dsp_element_t *elem) {
+#endif
 	dsp_element_entry_t *entry;
 	u_long flags;
 	int re, i;
@@ -107,14 +159,27 @@
 	entry->elem = elem;
 
 	entry->dev.class = &elements_class;
-	class_set_devdata(&entry->dev, elem);
-	snprintf(entry->dev.class_id, BUS_ID_SIZE, elem->name);
-	if ((re = class_device_register(&entry->dev)))
-		goto err1;
-
-	for (i = 0; i < (sizeof(element_attributes) / sizeof(struct class_device_attribute)); ++i)
-		if ((re = class_device_create_file(&entry->dev, &element_attributes[i])))
-			goto err2;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+        dev_set_drvdata(&entry->dev, elem);
+
+        snprintf(entry->dev.bus_id, BUS_ID_SIZE, elem->name);
+        if ((re = device_register(&entry->dev)))
+                goto err1;
+
+        for (i = 0; i < (sizeof(element_attributes) / sizeof(struct device_attribute)); ++i)
+                if ((re = device_create_file(&entry->dev, &element_attributes[i])))
+                        goto err2;
+#else
+        class_set_devdata(&entry->dev, elem);
+
+        snprintf(entry->dev.class_id, BUS_ID_SIZE, elem->name);
+        if ((re = class_device_register(&entry->dev)))
+                goto err1;
+
+        for (i = 0; i < (sizeof(element_attributes) / sizeof(struct class_device_attribute)); ++i)
+                if ((re = class_device_create_file(&entry->dev, &element_attributes[i])))
+                        goto err2;
+#endif	
 
 	write_lock_irqsave(&dsp_elements_lock, flags);
 	list_add_tail(&entry->list, &dsp_elements);
@@ -125,14 +190,22 @@
 	return 0;
 
 err2:
-	class_device_unregister(&entry->dev);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+        device_unregister(&entry->dev);
+#else
+        class_device_unregister(&entry->dev);
+#endif
 err1:
 	kfree(entry);
 	return re;
 }
 
-void mISDN_dsp_element_unregister (mISDN_dsp_element_t *elem)
-{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+void mISDN_dsp_element_unregister (struct mISDN_dsp_element *elem) {
+
+#else
+void mISDN_dsp_element_unregister (mISDN_dsp_element_t *elem) {
+#endif
 	dsp_element_entry_t *entry, *n;
 	u_long flags;
 
@@ -145,7 +218,11 @@
 		if (entry->elem == elem) {
 			list_del(&entry->list);
 			write_unlock_irqrestore(&dsp_elements_lock, flags);
-			class_device_unregister(&entry->dev);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+                        device_unregister(&entry->dev);
+#else
+                        class_device_unregister(&entry->dev);
+#endif
 			kfree(entry);
 			printk(KERN_DEBUG "%s: %s unregistered\n", __FUNCTION__, elem->name);
 			return;
@@ -241,7 +318,11 @@
 	char *dup, *tok, *name, *args;
 	dsp_element_entry_t *entry, *n;
 	dsp_pipeline_entry_t *pipeline_entry;
-	mISDN_dsp_element_t *elem;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+        struct mISDN_dsp_element *elem;
+#else
+        mISDN_dsp_element_t *elem;
+#endif
 	u_long elements_flags, pipeline_flags;
 
 	if (!pipeline)
--- drivers/isdn/hardware/mISDN/l1oip_core.c	2009-08-27 19:26:15.000000000 +0300
+++ drivers/isdn/hardware/mISDN/l1oip_core_.c	2009-08-28 00:44:34.000000000 +0300
@@ -1249,9 +1249,11 @@
 /*
  * cleanup module
  */
-static void __exit
-l1oip_cleanup(void)
-{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+static void l1oip_cleanup(void) {
+#else
+static void __exit l1oip_cleanup(void) {
+#endif
 	l1oip_t *hc,*next;
 	int err;
 
--- drivers/isdn/hardware/mISDN/dsp_hwec.c	2009-08-28 00:50:26.000000000 +0300
+++ drivers/isdn/hardware/mISDN/dsp_hwec_.c	2009-08-28 00:57:05.000000000 +0300
@@ -26,11 +26,28 @@
 
 #include <linux/kernel.h>
 #include <linux/string.h>
-#include <linux/mISDNdsp.h>
+//#include <linux/mISDNdsp.h>
 #include <linux/mISDNif.h>
 #include "dsp.h"
 #include "helper.h"
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+static struct mISDN_dsp_element_arg args[] = {
+        { "deftaps", "128", "Set the number of taps of cancellation." },
+};
+
+static struct mISDN_dsp_element dsp_hwec_p = {
+        .name = "hwec",
+        .new = NULL,
+        .free = NULL,
+        .process_tx = NULL,
+        .process_rx = NULL,
+        .num_args = sizeof(args) / sizeof(struct mISDN_dsp_element_arg),
+        .args = args,
+};
+struct mISDN_dsp_element *dsp_hwec = &dsp_hwec_p;
+
+#else
 static mISDN_dsp_element_arg_t args[] = {
 	{ "deftaps", "128", "Set the number of taps of cancellation." },
 };
@@ -45,6 +62,7 @@
 	.args = args,
 };
 mISDN_dsp_element_t *dsp_hwec = &dsp_hwec_p;
+#endif
 
 void dsp_hwec_enable (dsp_t *dsp, const char *arg)
 {
--- drivers/isdn/hardware/mISDN/dsp_kb1ec.c	2009-08-28 00:50:26.000000000 +0300
+++ drivers/isdn/hardware/mISDN/dsp_kb1ec_.c	2009-08-28 00:59:59.000000000 +0300
@@ -90,6 +90,22 @@
 	dsp_cancel_rx(p, data, len);
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+static struct mISDN_dsp_element_arg args[] = {
+        { "deftaps", "128", "Set the number of taps of cancellation." },
+        { "training", "0", "Enable echotraining (0: disabled, 1: enabled)." },
+};
+
+static struct mISDN_dsp_element dsp_kb1ec = {
+        .name = "kb1ec",
+        .new = new,
+        .free = free,
+        .process_tx = process_tx,
+        .process_rx = process_rx,
+        .num_args = sizeof(args) / sizeof(struct mISDN_dsp_element_arg),
+        .args = args,
+};
+#else
 static mISDN_dsp_element_arg_t args[] = {
 	{ "deftaps", "128", "Set the number of taps of cancellation." },
 	{ "training", "0", "Enable echotraining (0: disabled, 1: enabled)." },
@@ -104,6 +120,7 @@
 	.num_args = sizeof(args) / sizeof(mISDN_dsp_element_arg_t),
 	.args = args,
 };
+#endif
 
 #ifdef MODULE
 static int __init dsp_kb1ec_init (void)
--- drivers/isdn/hardware/mISDN/dsp_mec2.c	2009-08-28 00:50:26.000000000 +0300
+++ drivers/isdn/hardware/mISDN/dsp_mec2_.c	2009-08-28 01:01:36.000000000 +0300
@@ -91,6 +91,22 @@
 	dsp_cancel_rx(p, data, len);
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+static struct mISDN_dsp_element_arg args[] = {
+        { "deftaps", "128", "Set the number of taps of cancellation." },
+        { "training", "0", "Enable echotraining (0: disabled, 1: enabled)." },
+};
+
+static struct mISDN_dsp_element dsp_mec2 = {
+        .name = "mec2",
+        .new = new,
+        .free = free,
+        .process_tx = process_tx,
+        .process_rx = process_rx,
+        .num_args = sizeof(args) / sizeof(struct mISDN_dsp_element_arg),
+        .args = args,
+};
+#else
 static mISDN_dsp_element_arg_t args[] = {
 	{ "deftaps", "128", "Set the number of taps of cancellation." },
 	{ "training", "0", "Enable echotraining (0: disabled, 1: enabled)." },
@@ -105,6 +121,7 @@
 	.num_args = sizeof(args) / sizeof(mISDN_dsp_element_arg_t),
 	.args = args,
 };
+#endif
 
 #ifdef MODULE
 static int __init dsp_mec2_init (void)
--- drivers/isdn/hardware/mISDN/dsp_mg2ec.c	2009-08-28 00:50:26.000000000 +0300
+++ drivers/isdn/hardware/mISDN/dsp_mg2ec_.c	2009-08-28 01:04:00.000000000 +0300
@@ -90,6 +90,22 @@
 	dsp_cancel_rx(p, data, len);
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
+static struct mISDN_dsp_element_arg args[] = {
+        { "deftaps", "128", "Set the number of taps of cancellation." },
+        { "training", "0", "Enable echotraining (0: disabled, 1: enabled)." },
+};
+
+static struct mISDN_dsp_element dsp_mg2ec = {
+        .name = "mg2ec",
+        .new = new,
+        .free = free,
+        .process_tx = process_tx,
+        .process_rx = process_rx,
+        .num_args = sizeof(args) / sizeof(struct mISDN_dsp_element_arg),
+        .args = args,
+};
+#else
 static mISDN_dsp_element_arg_t args[] = {
 	{ "deftaps", "128", "Set the number of taps of cancellation." },
 	{ "training", "0", "Enable echotraining (0: disabled, 1: enabled)." },
@@ -104,6 +120,7 @@
 	.num_args = sizeof(args) / sizeof(mISDN_dsp_element_arg_t),
 	.args = args,
 };
+#endif
 
 #ifdef MODULE
 static int __init dsp_mg2ec_init (void)
--- drivers/isdn/hardware/mISDN/hfc_multi.c	2009-08-28 01:06:24.000000000 +0300
+++ drivers/isdn/hardware/mISDN/hfc_multi_.c	2009-08-28 01:13:02.000000000 +0300
@@ -5035,9 +5035,11 @@
 	id_table:	hfmultipci_ids,
 };
 
-static void __exit
-HFCmulti_cleanup(void)
-{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 26)
+static void l1oip_cleanup(void) {
+#else
+static void __exit l1oip_cleanup(void) {
+#endif
 	hfc_multi_t *hc, *next;
 	int err;
 
--- drivers/isdn/hardware/mISDN/dsp_octwareec.c	2009-08-28 01:14:11.000000000 +0300
+++ drivers/isdn/hardware/mISDN/dsp_octwareec_.c	2009-08-28 01:17:23.000000000 +0300
@@ -91,20 +91,37 @@
 	dsp_cancel_rx(p, data, len);
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+static struct mISDN_dsp_element_arg args[] = {
+        { "deftaps", "128", "Set the number of taps of cancellation." },
+        { "training", "0", "Enable echotraining (0: disabled, 1: enabled)." },
+};
+
+static struct mISDN_dsp_element dsp_octwareec = {
+        .name = "octwareec",
+        .new = new,
+        .free = free,
+        .process_tx = process_tx,
+        .process_rx = process_rx,
+        .num_args = sizeof(args) / sizeof(struct mISDN_dsp_element_arg),
+        .args = args,
+};
+#else
 static mISDN_dsp_element_arg_t args[] = {
-	{ "deftaps", "128", "Set the number of taps of cancellation." },
-	{ "training", "0", "Enable echotraining (0: disabled, 1: enabled)." },
+        { "deftaps", "128", "Set the number of taps of cancellation." },
+        { "training", "0", "Enable echotraining (0: disabled, 1: enabled)." },
 };
 
 static mISDN_dsp_element_t dsp_octwareec = {
-	.name = "octwareec",
-	.new = new,
-	.free = free,
-	.process_tx = process_tx,
-	.process_rx = process_rx,
-	.num_args = sizeof(args) / sizeof(mISDN_dsp_element_arg_t),
-	.args = args,
+        .name = "octwareec",
+        .new = new,
+        .free = free,
+        .process_tx = process_tx,
+        .process_rx = process_rx,
+        .num_args = sizeof(args) / sizeof(mISDN_dsp_element_arg_t),
+        .args = args,
 };
+#endif
 
 #ifdef MODULE
 static int __init dsp_octwareec_init (void)
--- drivers/isdn/hardware/mISDN/dsp_oslec.c	2009-08-28 01:14:11.000000000 +0300
+++ drivers/isdn/hardware/mISDN/dsp_oslec_.c	2009-08-28 01:19:07.000000000 +0300
@@ -98,20 +98,37 @@
 	dsp_cancel_rx(p, data, len);
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 27)
+static struct  mISDN_dsp_element_arg args[] = {
+        { "deftaps", "128", "Set the number of taps of cancellation." },
+        { "training", "0", "Enable echotraining (0: disabled, 1: enabled)." },
+};
+
+static struct mISDN_dsp_element dsp_oslec = {
+        .name = "oslec",
+        .new = new,
+        .free = free,
+        .process_tx = process_tx,
+        .process_rx = process_rx,
+        .num_args = sizeof(args) / sizeof(struct mISDN_dsp_element_arg),
+        .args = args,
+};
+#else
 static mISDN_dsp_element_arg_t args[] = {
-	{ "deftaps", "128", "Set the number of taps of cancellation." },
-	{ "training", "0", "Enable echotraining (0: disabled, 1: enabled)." },
+        { "deftaps", "128", "Set the number of taps of cancellation." },
+        { "training", "0", "Enable echotraining (0: disabled, 1: enabled)." },
 };
 
 static mISDN_dsp_element_t dsp_oslec = {
-	.name = "oslec",
-	.new = new,
-	.free = free,
-	.process_tx = process_tx,
-	.process_rx = process_rx,
-	.num_args = sizeof(args) / sizeof(mISDN_dsp_element_arg_t),
-	.args = args,
+        .name = "oslec",
+        .new = new,
+        .free = free,
+        .process_tx = process_tx,
+        .process_rx = process_rx,
+        .num_args = sizeof(args) / sizeof(mISDN_dsp_element_arg_t),
+        .args = args,
 };
+#endif
 
 #ifdef MODULE
 static int __init dsp_oslec_init (void)
--- include/linux/mISDNif.h	2009-08-28 01:23:40.000000000 +0300
+++ include/linux/mISDNif_.h	2009-08-28 01:27:51.000000000 +0300
@@ -786,7 +786,11 @@
 	struct list_head	ilist;
 	spinlock_t		lock;
 	struct module		*owner;
-	struct class_device	class_dev;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+        struct device           class_dev;
+#else
+        struct class_device     class_dev;
+#endif
 };
 
 #ifdef OBSOLETE
@@ -819,7 +823,11 @@
 	mISDNinstance_t		*parent;
 	if_func_t		*function;
 	spinlock_t		*hwlock;
-	struct class_device	class_dev;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+        struct device           class_dev;
+#else
+        struct class_device     class_dev;
+#endif
 };
 
 #ifdef OBSOLETE
@@ -857,7 +865,11 @@
 	mISDNstack_t		*clone;
 	mISDNstack_t		*parent;
 	struct list_head	childlist;
-	struct class_device	class_dev;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+        struct device           class_dev;
+#else
+        struct class_device     class_dev;
+#endif
 	/* temporary use */
 	mISDN_pid_t		new_pid;
 };
--- drivers/isdn/hardware/mISDN/core.c	2009-08-27 15:19:22.000000000 +0300
+++ drivers/isdn/hardware/mISDN/core.c	2009-08-29 13:28:41.000000000 +0300
@@ -988,15 +988,21 @@
 	if (core_debug & DEBUG_CORE_FUNC)
 		printk(KERN_DEBUG "mISDN_unregister: mISDN_objectlist(%p<-%p->%p)\n",
 			mISDN_objectlist.prev, &mISDN_objectlist, mISDN_objectlist.next);
-	class_device_unregister(&obj->class_dev);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+        device_unregister(&obj->class_dev);
+#else
+        class_device_unregister(&obj->class_dev);
+#endif
 	return(0);
 }
 
 int
 mISDNInit(void)
 {
-	DECLARE_MUTEX_LOCKED(sem);
-	int err;
+        struct semaphore sem;
+        int err;
+
+        init_MUTEX_LOCKED(&sem);
 
 	printk(KERN_INFO "Modular ISDN Stack core version (%s) revision (%s)\n", mISDN_core_version, mISDN_core_revision);
 	core_debug = debug;
@@ -1037,7 +1043,9 @@
 }
 
 void mISDN_cleanup(void) {
-	DECLARE_MUTEX_LOCKED(sem);
+        struct semaphore sem;
+
+        init_MUTEX_LOCKED(&sem);
 
 	free_mISDNdev();
 	if (!list_empty(&mISDN_objectlist)) {
--- drivers/isdn/hardware/mISDN/stack.c	2009-08-27 15:19:22.000000000 +0300
+++ drivers/isdn/hardware/mISDN/stack.c	2009-08-29 13:28:41.000000000 +0300
@@ -871,8 +871,10 @@
 static int
 delete_stack(mISDNstack_t *st)
 {
-	DECLARE_MUTEX_LOCKED(sem);
-	u_long	flags;
+        struct semaphore sem;
+        u_long  flags;
+
+        init_MUTEX_LOCKED(&sem);
 
 	if (core_debug & DEBUG_CORE_FUNC)
 		printk(KERN_DEBUG "%s: st(%p:%08x)\n",
@@ -1332,7 +1334,8 @@
 	hhe->addr = st->id;
 
 	if (wait) {
-		DECLARE_MUTEX_LOCKED(sem);
+                struct semaphore sem;
+                init_MUTEX_LOCKED(&sem);
 
 		hhe->data[0] = &sem;
 		_queue_message(st, skb);
--- drivers/isdn/hardware/mISDN/sysfs_obj.c	2009-08-27 15:19:22.000000000 +0300
+++ drivers/isdn/hardware/mISDN/sysfs_obj.c	2009-08-29 13:28:41.000000000 +0300
@@ -12,27 +12,46 @@
 
 #define to_mISDNobject(d) container_of(d, mISDNobject_t, class_dev)
 
-static ssize_t show_obj_name(struct class_device *class_dev, char *buf)
-{
-	mISDNobject_t *obj = to_mISDNobject(class_dev);
-	return sprintf(buf, "%s\n", obj->name);
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+static ssize_t show_obj_name(struct device *class_dev, struct device_attribute *attr, char *buf) {
+        mISDNobject_t *obj = to_mISDNobject(class_dev);
+        return sprintf(buf, "%s\n", obj->name);
+}
+static DEVICE_ATTR(name, S_IRUGO, show_obj_name, NULL);
+
+static ssize_t show_obj_id(struct device *class_dev, struct device_attribute *attr, char *buf) {
+        mISDNobject_t *obj = to_mISDNobject(class_dev);
+        return sprintf(buf, "%d\n", obj->id);
+}
+static DEVICE_ATTR(id, S_IRUGO, show_obj_id, NULL);
+
+static ssize_t show_obj_refcnt(struct device *class_dev, struct device_attribute *attr, char *buf) {
+        mISDNobject_t *obj = to_mISDNobject(class_dev);
+        return sprintf(buf, "%d\n", obj->refcnt);
 }
+static DEVICE_ATTR(refcnt, S_IRUGO, show_obj_refcnt, NULL);
 
+#else
+static ssize_t show_obj_name(struct class_device *class_dev, char *buf) {
+        mISDNobject_t *obj = to_mISDNobject(class_dev);
+        return sprintf(buf, "%s\n", obj->name);
+}
 static CLASS_DEVICE_ATTR(name, S_IRUGO, show_obj_name, NULL);
 
-static ssize_t show_obj_id(struct class_device *class_dev, char *buf)
-{
-	mISDNobject_t *obj = to_mISDNobject(class_dev);
-	return sprintf(buf, "%d\n", obj->id);
+static ssize_t show_obj_id(struct class_device *class_dev, char *buf) {
+        mISDNobject_t *obj = to_mISDNobject(class_dev);
+        return sprintf(buf, "%d\n", obj->id);
 }
 static CLASS_DEVICE_ATTR(id, S_IRUGO, show_obj_id, NULL);
 
-static ssize_t show_obj_refcnt(struct class_device *class_dev, char *buf)
-{
-	mISDNobject_t *obj = to_mISDNobject(class_dev);
-	return sprintf(buf, "%d\n", obj->refcnt);
+static ssize_t show_obj_refcnt(struct class_device *class_dev, char *buf) {
+        mISDNobject_t *obj = to_mISDNobject(class_dev);
+        return sprintf(buf, "%d\n", obj->refcnt);
 }
 static CLASS_DEVICE_ATTR(refcnt, S_IRUGO, show_obj_refcnt, NULL);
+#endif
 
 ssize_t mISDN_show_pid_protocol(mISDN_pid_t *pid, char *buf)
 {
@@ -77,7 +96,12 @@
 MISDN_PROTO(mISDNobject, DPROTO, S_IRUGO);
 #endif
 
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+static void release_mISDN_obj(struct device *dev)
+#else
 static void release_mISDN_obj(struct class_device *dev)
+#endif
 {
 #ifdef SYSFS_SUPPORT
 	mISDNobject_t	*obj = to_mISDNobject(dev);
@@ -98,10 +122,12 @@
 
 static struct class obj_dev_class = {
 	.name		= "mISDN-objects",
-#ifndef CLASS_WITHOUT_OWNER
 	.owner		= THIS_MODULE,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+        .dev_release        = &release_mISDN_obj,
+#else
+        .release        = &release_mISDN_obj,
 #endif
-	.release	= &release_mISDN_obj,
 };
 
 int
@@ -109,22 +135,40 @@
 	int	err;
 
 	obj->class_dev.class = &obj_dev_class;
-	snprintf(obj->class_dev.class_id, BUS_ID_SIZE, "obj-%d", obj->id);
-	err = class_device_register(&obj->class_dev);
-	if (err)
-		goto out;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+        snprintf(obj->class_dev.bus_id, BUS_ID_SIZE, "obj-%d", obj->id);
 
-	err = class_device_create_file(&obj->class_dev, &class_device_attr_id);
-	if (err)
-		goto out;
-	err = class_device_create_file(&obj->class_dev,
-	    &class_device_attr_name);
-	if (err)
-		goto out;
-	err = class_device_create_file(&obj->class_dev,
-	    &class_device_attr_refcnt);
-	if (err)
-		goto out;
+        err = device_register(&obj->class_dev);
+        if (err)
+                goto out;
+        err = device_create_file(&obj->class_dev, &dev_attr_id);
+        if (err)
+                goto out;
+        err = device_create_file(&obj->class_dev, &dev_attr_name);
+        if (err)
+                goto out;
+        err = device_create_file(&obj->class_dev, &dev_attr_refcnt);
+        if (err)
+                goto out;
+#else
+        snprintf(obj->class_dev.class_id, BUS_ID_SIZE, "obj-%d", obj->id);
+
+        err = class_device_register(&obj->class_dev);
+        if (err)
+                goto out;
+
+        err = class_device_create_file(&obj->class_dev, &class_device_attr_id);
+        if (err)
+                goto out;
+        err = class_device_create_file(&obj->class_dev,
+            &class_device_attr_name);
+        if (err)
+                goto out;
+        err = class_device_create_file(&obj->class_dev,
+            &class_device_attr_refcnt);
+        if (err)
+                goto out;
+#endif
 #ifdef SYSFS_SUPPORT
 	err = sysfs_create_group(&obj->class_dev.kobj, &BPROTO_group);
 	if (err)
--- drivers/isdn/hardware/mISDN/sysfs_inst.c	2009-08-27 15:19:22.000000000 +0300
+++ drivers/isdn/hardware/mISDN/sysfs_inst.c	2009-08-29 13:28:41.000000000 +0300
@@ -12,39 +12,65 @@
 
 #define to_mISDNinstance(d) container_of(d, mISDNinstance_t, class_dev)
 
-static ssize_t show_inst_id(struct class_device *class_dev, char *buf)
-{
-	mISDNinstance_t	*inst = to_mISDNinstance(class_dev);
-	return sprintf(buf, "%08x\n", inst->id);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+static ssize_t show_inst_id(struct device *class_dev, struct device_attribute *attr, char *buf) {
+        mISDNinstance_t *inst = to_mISDNinstance(class_dev);
+        return sprintf(buf, "%08x\n", inst->id);
+}
+static DEVICE_ATTR(id, S_IRUGO, show_inst_id, NULL);
+
+static ssize_t show_inst_name(struct device *class_dev, struct device_attribute *attr, char *buf) {
+        mISDNinstance_t *inst = to_mISDNinstance(class_dev);
+        return sprintf(buf, "%s\n", inst->name);
+}
+static DEVICE_ATTR(name, S_IRUGO, show_inst_name, NULL);
+
+static ssize_t show_inst_extentions(struct device *class_dev, struct device_attribute *attr, char *buf) {
+        mISDNinstance_t *inst = to_mISDNinstance(class_dev);
+        return sprintf(buf, "%08x\n", inst->extentions);
+}
+static DEVICE_ATTR(extentions, S_IRUGO, show_inst_extentions, NULL);
+
+static ssize_t show_inst_regcnt(struct device *class_dev, struct device_attribute *attr, char *buf) {
+        mISDNinstance_t *inst = to_mISDNinstance(class_dev);
+        return sprintf(buf, "%d\n", inst->regcnt);
+}
+static DEVICE_ATTR(regcnt, S_IRUGO, show_inst_regcnt, NULL);
+#else
+static ssize_t show_inst_id(struct class_device *class_dev, char *buf) {
+        mISDNinstance_t *inst = to_mISDNinstance(class_dev);
+        return sprintf(buf, "%08x\n", inst->id);
 }
 static CLASS_DEVICE_ATTR(id, S_IRUGO, show_inst_id, NULL);
 
-static ssize_t show_inst_name(struct class_device *class_dev, char *buf)
-{
-	mISDNinstance_t	*inst = to_mISDNinstance(class_dev);
-	return sprintf(buf, "%s\n", inst->name);
+static ssize_t show_inst_name(struct class_device *class_dev, char *buf) {
+        mISDNinstance_t *inst = to_mISDNinstance(class_dev);
+        return sprintf(buf, "%s\n", inst->name);
 }
 static CLASS_DEVICE_ATTR(name, S_IRUGO, show_inst_name, NULL);
 
-static ssize_t show_inst_extentions(struct class_device *class_dev, char *buf)
-{
-	mISDNinstance_t	*inst = to_mISDNinstance(class_dev);
-	return sprintf(buf, "%08x\n", inst->extentions);
+static ssize_t show_inst_extentions(struct class_device *class_dev, char *buf) {
+        mISDNinstance_t *inst = to_mISDNinstance(class_dev);
+        return sprintf(buf, "%08x\n", inst->extentions);
 }
 static CLASS_DEVICE_ATTR(extentions, S_IRUGO, show_inst_extentions, NULL);
 
-static ssize_t show_inst_regcnt(struct class_device *class_dev, char *buf)
-{
-	mISDNinstance_t	*inst = to_mISDNinstance(class_dev);
-	return sprintf(buf, "%d\n", inst->regcnt);
+static ssize_t show_inst_regcnt(struct class_device *class_dev, char *buf) {
+        mISDNinstance_t *inst = to_mISDNinstance(class_dev);
+        return sprintf(buf, "%d\n", inst->regcnt);
 }
 static CLASS_DEVICE_ATTR(regcnt, S_IRUGO, show_inst_regcnt, NULL);
+#endif
 
 #ifdef SYSFS_SUPPORT
 MISDN_PROTO(mISDNinstance, pid, S_IRUGO);
 #endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+static void release_mISDN_inst(struct device *dev)
+#else
 static void release_mISDN_inst(struct class_device *dev)
+#endif
 {
 #ifdef SYSFS_SUPPORT
 	mISDNinstance_t	*inst = to_mISDNinstance(dev);
@@ -54,7 +80,11 @@
 	sysfs_remove_group(&inst->class_dev.kobj, &pid_group);
 #endif
 	if (core_debug & DEBUG_SYSFS)
-		printk(KERN_INFO "release instance class dev %s\n", dev->class_id);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+                printk(KERN_INFO "release instance class dev %s\n", dev->bus_id);
+#else
+                printk(KERN_INFO "release instance class dev %s\n", dev->class_id);
+#endif
 }
 
 static struct class inst_dev_class = {
@@ -62,7 +92,11 @@
 #ifndef CLASS_WITHOUT_OWNER
 	.owner		= THIS_MODULE,
 #endif
-	.release	= &release_mISDN_inst,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+        .dev_release    = &release_mISDN_inst,
+#else
+        .release        = &release_mISDN_inst,
+#endif
 };
 
 int
@@ -73,28 +107,49 @@
 #endif
 
 	inst->class_dev.class = &inst_dev_class;
-	snprintf(inst->class_dev.class_id, BUS_ID_SIZE, "inst-%08x", inst->id);
-	err = class_device_register(&inst->class_dev);
-	if (err)
-		return(err);
-
-	err = class_device_create_file(&inst->class_dev,
-	    &class_device_attr_id);
-	if (err)
-		return(err);
-	err = class_device_create_file(&inst->class_dev,
-	    &class_device_attr_name);
-	if (err)
-		return(err);
-	err = class_device_create_file(&inst->class_dev,
-	    &class_device_attr_extentions);
-	if (err)
-		return(err);
-	err = class_device_create_file(&inst->class_dev,
-	    &class_device_attr_regcnt);
-	if (err)
-		return(err);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+        snprintf(inst->class_dev.bus_id, BUS_ID_SIZE, "inst-%08x", inst->id);
+        err = device_register(&inst->class_dev);
+        if (err)
+                return(err);
+
+        err = device_create_file(&inst->class_dev, &dev_attr_id);
+        if (err)
+                return(err);
+        err = device_create_file(&inst->class_dev, &dev_attr_name);
+        if (err)
+                return(err);
+        err = device_create_file(&inst->class_dev, &dev_attr_extentions);
+        if (err)
+                return(err);
+        err = device_create_file(&inst->class_dev, &dev_attr_regcnt);
+        if (err)
+                return(err);
+#else
+        snprintf(inst->class_dev.class_id, BUS_ID_SIZE, "inst-%08x", inst->id);
+        err = class_device_register(&inst->class_dev);
+        if (err)
+                return(err);
+
+        err = class_device_create_file(&inst->class_dev,
+            &class_device_attr_id);
+        if (err)
+                return(err);
+        err = class_device_create_file(&inst->class_dev,
+            &class_device_attr_name);
+        if (err)
+                return(err);
+        err = class_device_create_file(&inst->class_dev,
+            &class_device_attr_extentions);
+        if (err)
+                return(err);
+        err = class_device_create_file(&inst->class_dev,
+            &class_device_attr_regcnt);
+        if (err)
+                return(err);
+#endif
+	
 #ifdef SYSFS_SUPPORT
 	err = sysfs_create_group(&inst->class_dev.kobj, &pid_group);
 	if (err)
@@ -135,7 +190,11 @@
 				sysfs_remove_link(&inst->st->class_dev.kobj, "mgr");
 #endif
 		}
-		class_device_unregister(&inst->class_dev);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+                device_unregister(&inst->class_dev);
+#else
+                class_device_unregister(&inst->class_dev);
+#endif
 	}
 }
 
--- drivers/isdn/hardware/mISDN/sysfs_st.c	2009-08-27 15:19:22.000000000 +0300
+++ drivers/isdn/hardware/mISDN/sysfs_st.c	2009-08-29 13:28:41.000000000 +0300
@@ -12,28 +12,175 @@
 
 #define to_mISDNstack(d) container_of(d, mISDNstack_t, class_dev)
 
-static ssize_t show_st_id(struct class_device *class_dev, char *buf)
-{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+static ssize_t show_st_id(struct device *class_dev, struct device_attribute *attr, char *buf) {
+	mISDNstack_t	*st = to_mISDNstack(class_dev);
+	return sprintf(buf, "%08x\n", st->id);
+}
+static DEVICE_ATTR(id, S_IRUGO, show_st_id, NULL);
+
+static ssize_t show_st_protocol(struct device *class_dev, struct device_attribute *attr, char *buf) {
+	mISDNstack_t	*st = to_mISDNstack(class_dev);
+	return sprintf(buf, "0x%08x\n", st->pid.modparm_protocol);
+}
+static DEVICE_ATTR(protocol, S_IRUGO, show_st_protocol, NULL);
+
+static ssize_t show_st_status(struct device *class_dev, struct device_attribute *attr, char *buf) {
+	mISDNstack_t	*st = to_mISDNstack(class_dev);
+	return sprintf(buf, "0x%08lx\n", st->status);
+}
+
+static ssize_t store_st_status(struct device *class_dev, struct device_attribute *attr, const char *buf, size_t count) {
+	mISDNstack_t	*st = to_mISDNstack(class_dev);
+	ulong	status;
+	int	err;
+
+	status = simple_strtol(buf, NULL, 0);
+	printk(KERN_DEBUG "%s: status %08lx\n", __FUNCTION__, status);
+	if (status == (1<<mISDN_STACK_INIT)) {
+		/* we want to make st->new_pid activ */
+		err = clear_stack(st, 1);
+		if (err) {
+			int_errtxt("clear_stack:%d", err);
+			return(err);
+		}
+		err = set_stack(st ,&st->new_pid);
+		if (err) {
+			int_errtxt("set_stack:%d", err);
+			return(err);
+		}
+		return(count);
+	} else if (status == (1<<mISDN_STACK_THREADSTART)) {
+		/* we want to start a new process after abort */
+		err = mISDN_start_stack_thread(st);
+		if (err) {
+			int_errtxt("start_stack_thread:%d", err);
+			return(err);
+		}
+		return(count);
+	}
+	st->status = status;
+	wake_up_interruptible(&st->workq);
+	return(count);
+}
+static DEVICE_ATTR(status, S_IRUGO | S_IWUSR, show_st_status, store_st_status);
+
+static ssize_t store_st_protocol(struct device *class_dev, struct device_attribute *attr, const char *buf, size_t count) {
+	mISDNstack_t	*st = to_mISDNstack(class_dev);
+	ulong	tmp;
+	char	*p = (char *)buf;
+	u_int	i;
+
+	memset(&st->new_pid.protocol, 0, (MAX_LAYER_NR + 1)*sizeof(st->new_pid.protocol[0]));
+	for (i=0; i<=MAX_LAYER_NR; i++) {
+		if (!*p)
+			break;
+		tmp = simple_strtol(p, &p, 0);
+		st->new_pid.protocol[i] = tmp;
+		if (*p)
+			p++;
+	}
+	if (*p)
+		int_errtxt("overflow");
+	return(count);
+}
+
+static ssize_t store_st_layermask(struct device *class_dev, struct device_attribute *attr, const char *buf, size_t count) {
+	mISDNstack_t	*st = to_mISDNstack(class_dev);
+	ulong		mask = (1<<(MAX_LAYER_NR + 1)) -1;
+
+	st->new_pid.layermask = simple_strtol(buf, NULL, 0);
+	if (st->new_pid.layermask > mask) {
+		int_errtxt("overflow");
+		st->new_pid.layermask &= mask;
+	}
+	return(count);
+}
+
+static ssize_t store_st_parameter(struct device *class_dev, struct device_attribute *attr, const char *buf, size_t count) {
+	mISDNstack_t	*st = to_mISDNstack(class_dev);
+	ulong	tmp;
+	char	*p = (char *)buf;
+	u_int	i, j, l;
+
+	memset(&st->new_pid.param, 0, (MAX_LAYER_NR + 1)*sizeof(st->new_pid.param[0]));
+	kfree(st->new_pid.pbuf);
+	l = 0;
+	for (i=0; i<=MAX_LAYER_NR; i++) {
+		if (!*p)
+			break;
+		tmp = simple_strtol(p, &p, 0);
+		if (*p)
+			p++;
+		if (tmp) {
+			j = tmp;
+			l += j+1;
+			while(j--) {
+				if (!*p)
+					break;
+				tmp = simple_strtol(p, &p, 0);
+				if (*p)
+					p++;
+				else
+					break;
+			}
+		}
+	}
+	if (*p)
+		int_errtxt("overflow");
+	if (l == 0) {
+		st->new_pid.maxplen = 0;
+		return(count);
+	}
+	st->new_pid.pbuf = kzalloc(l + 1, GFP_ATOMIC);
+	if (!st->new_pid.pbuf)
+		return(-ENOMEM);
+	st->new_pid.maxplen = l + 1;
+	st->new_pid.pidx = 1;
+	p = (char *)buf;
+	for (i=0; i<=MAX_LAYER_NR; i++) {
+		if (!*p)
+			break;
+		tmp = simple_strtol(p, &p, 0);
+		if (*p)
+			p++;
+		if (tmp) {
+			j = tmp;
+			st->new_pid.param[i] = st->new_pid.pidx;
+			st->new_pid.pbuf[st->new_pid.pidx++] = tmp & 0xff;
+			while(j--) {
+				if (!*p)
+					break;
+				tmp = simple_strtol(p, &p, 0);
+				st->new_pid.pbuf[st->new_pid.pidx++] = tmp & 0xff;
+				if (*p)
+					p++;
+				else
+					break;
+			}
+		}
+	}
+	return(count);
+}
+#else
+static ssize_t show_st_id(struct class_device *class_dev, char *buf) {
 	mISDNstack_t	*st = to_mISDNstack(class_dev);
 	return sprintf(buf, "%08x\n", st->id);
 }
 static CLASS_DEVICE_ATTR(id, S_IRUGO, show_st_id, NULL);
 
-static ssize_t show_st_protocol(struct class_device *class_dev, char *buf)
-{
+static ssize_t show_st_protocol(struct class_device *class_dev, char *buf) {
 	mISDNstack_t	*st = to_mISDNstack(class_dev);
 	return sprintf(buf, "0x%08x\n", st->pid.modparm_protocol);
 }
 static CLASS_DEVICE_ATTR(protocol, S_IRUGO, show_st_protocol, NULL);
 
-static ssize_t show_st_status(struct class_device *class_dev, char *buf)
-{
+static ssize_t show_st_status(struct class_device *class_dev, char *buf) {
 	mISDNstack_t	*st = to_mISDNstack(class_dev);
 	return sprintf(buf, "0x%08lx\n", st->status);
 }
 
-static ssize_t store_st_status(struct class_device *class_dev, const char *buf, size_t count)
-{
+static ssize_t store_st_status(struct class_device *class_dev, const char *buf, size_t count) {
 	mISDNstack_t	*st = to_mISDNstack(class_dev);
 	ulong	status;
 	int	err;
@@ -68,8 +215,7 @@
 }
 static CLASS_DEVICE_ATTR(status, S_IRUGO | S_IWUSR, show_st_status, store_st_status);
 
-static ssize_t store_st_protocol(struct class_device *class_dev, const char *buf, size_t count)
-{
+static ssize_t store_st_protocol(struct class_device *class_dev, const char *buf, size_t count) {
 	mISDNstack_t	*st = to_mISDNstack(class_dev);
 	ulong	tmp;
 	char	*p = (char *)buf;
@@ -89,8 +235,7 @@
 	return(count);
 }
 
-static ssize_t store_st_layermask(struct class_device *class_dev, const char *buf, size_t count)
-{
+static ssize_t store_st_layermask(struct class_device *class_dev, const char *buf, size_t count) {
 	mISDNstack_t	*st = to_mISDNstack(class_dev);
 	ulong		mask = (1<<(MAX_LAYER_NR + 1)) -1;
 
@@ -102,8 +247,7 @@
 	return(count);
 }
 
-static ssize_t store_st_parameter(struct class_device *class_dev, const char *buf, size_t count)
-{
+static ssize_t store_st_parameter(struct class_device *class_dev, const char *buf, size_t count) {
 	mISDNstack_t	*st = to_mISDNstack(class_dev);
 	ulong	tmp;
 	char	*p = (char *)buf;
@@ -168,12 +312,44 @@
 	}
 	return(count);
 }
+#endif
 
 #ifdef SYSFS_SUPPORT
 MISDN_PROTO(mISDNstack, pid, S_IRUGO);
 #endif
 MISDN_PROTO(mISDNstack, new_pid, S_IRUGO);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+static ssize_t show_st_qlen(struct device *class_dev, struct device_attribute *attr, char *buf) {
+        mISDNstack_t    *st = to_mISDNstack(class_dev);
+        return sprintf(buf, "%d\n", skb_queue_len(&st->msgq));
+}
+static DEVICE_ATTR(qlen, S_IRUGO, show_st_qlen, NULL);
+
+static void release_mISDN_stack(struct device *dev) {
+#ifdef SYSFS_SUPPORT
+        mISDNstack_t    *st = to_mISDNstack(dev);
+        char            name[12];
+
+        sysfs_remove_group(&st->class_dev.kobj, &pid_group);
+        sysfs_remove_group(&st->class_dev.kobj, &new_pid_group);
+        if (core_debug & DEBUG_SYSFS)
+                printk(KERN_INFO "release stack class dev %s\n", dev->class_id);
+        if (st->parent) {
+                sysfs_remove_link(&dev->kobj, "parent");
+                snprintf(name, 12, "child%d", (CHILD_ID_MASK & st->id) >> 16);
+                sysfs_remove_link(&st->parent->class_dev.kobj, name);
+
+        }
+        if (st->master) {
+                sysfs_remove_link(&dev->kobj, "master");
+                snprintf(name, 12, "clone%d", (CLONE_ID_MASK & st->id) >> 16);
+                sysfs_remove_link(&st->master->class_dev.kobj, name);
+        }
+#endif
+}
+
+#else
 static ssize_t show_st_qlen(struct class_device *class_dev, char *buf)
 {
 	mISDNstack_t	*st = to_mISDNstack(class_dev);
@@ -181,8 +357,7 @@
 }
 static CLASS_DEVICE_ATTR(qlen, S_IRUGO, show_st_qlen, NULL);
 
-static void release_mISDN_stack(struct class_device *dev)
-{
+static void release_mISDN_stack(struct class_device *dev) {
 #ifdef SYSFS_SUPPORT
 	mISDNstack_t	*st = to_mISDNstack(dev);
 	char		name[12];
@@ -203,15 +378,19 @@
 		sysfs_remove_link(&st->master->class_dev.kobj, name);
 	}
 #endif
-
 }
+#endif
 
 static struct class stack_dev_class = {
 	.name		= "mISDN-stacks",
 #ifndef CLASS_WITHOUT_OWNER
 	.owner		= THIS_MODULE,
 #endif
-	.release	= &release_mISDN_stack,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+        .dev_release        = &release_mISDN_stack,
+#else
+        .release        = &release_mISDN_stack,
+#endif
 };
 
 int
@@ -223,15 +402,28 @@
 #endif
 
 	st->class_dev.class = &stack_dev_class;
-	if (st->id & FLG_CHILD_STACK)
-		snprintf(st->class_dev.class_id, BUS_ID_SIZE, "chst-%08x", st->id);
-	else if (st->id & FLG_CLONE_STACK)
-		snprintf(st->class_dev.class_id, BUS_ID_SIZE, "clst-%08x", st->id);
-	else
-		snprintf(st->class_dev.class_id, BUS_ID_SIZE, "st-%08x", st->id);
-	if (st->mgr)
-		st->class_dev.dev = st->mgr->class_dev.dev;
-	err = class_device_register(&st->class_dev);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+        if (st->id & FLG_CHILD_STACK)
+                snprintf(st->class_dev.bus_id, BUS_ID_SIZE, "chst-%08x", st->id);
+        else if (st->id & FLG_CLONE_STACK)
+                snprintf(st->class_dev.bus_id, BUS_ID_SIZE, "clst-%08x", st->id);
+        else
+                snprintf(st->class_dev.bus_id, BUS_ID_SIZE, "st-%08x", st->id);
+        if (st->mgr)
+                st->class_dev.parent = st->mgr->class_dev.parent;
+        err = device_register(&st->class_dev);
+
+#else
+        if (st->id & FLG_CHILD_STACK)
+                snprintf(st->class_dev.class_id, BUS_ID_SIZE, "chst-%08x", st->id);
+        else if (st->id & FLG_CLONE_STACK)
+                snprintf(st->class_dev.class_id, BUS_ID_SIZE, "clst-%08x", st->id);
+        else
+                snprintf(st->class_dev.class_id, BUS_ID_SIZE, "st-%08x", st->id);
+        if (st->mgr)
+                st->class_dev.dev = st->mgr->class_dev.dev;
+        err = class_device_register(&st->class_dev);
+#endif
 	if (err)
 		return(err);
 #ifdef SYSFS_SUPPORT
@@ -254,22 +446,37 @@
 	err = (int)&new_pid_group; /* avoid unused var warn with no SYSFS */
 #endif
 
-	err = class_device_create_file(&st->class_dev,
-	    &class_device_attr_id);
-	if (err)
-		goto out_unreg;
-	err = class_device_create_file(&st->class_dev,
-	    &class_device_attr_qlen);
-	if (err)
-		goto out_unreg;
-	err = class_device_create_file(&st->class_dev,
-	    &class_device_attr_protocol);
-	if (err)
-		goto out_unreg;
-	err = class_device_create_file(&st->class_dev,
-	    &class_device_attr_status);
-	if (err)
-		goto out_unreg;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+        err = device_create_file(&st->class_dev, &dev_attr_id);
+        if (err)
+                goto out_unreg;
+        err = device_create_file(&st->class_dev, &dev_attr_qlen);
+        if (err)
+                goto out_unreg;
+        err = device_create_file(&st->class_dev, &dev_attr_protocol);
+        if (err)
+                goto out_unreg;
+        err = device_create_file(&st->class_dev, &dev_attr_status);
+        if (err)
+                goto out_unreg;
+#else
+        err = class_device_create_file(&st->class_dev,
+            &class_device_attr_id);
+        if (err)
+                goto out_unreg;
+        err = class_device_create_file(&st->class_dev,
+            &class_device_attr_qlen);
+        if (err)
+                goto out_unreg;
+        err = class_device_create_file(&st->class_dev,
+            &class_device_attr_protocol);
+        if (err)
+                goto out_unreg;
+        err = class_device_create_file(&st->class_dev,
+            &class_device_attr_status);
+        if (err)
+                goto out_unreg;
+#endif
 
 #ifdef SYSFS_SUPPORT
 	if (st->parent) {
@@ -286,17 +493,30 @@
 	return(err);
 
 out_unreg:
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
 #ifdef SYSFS_SUPPORT
-	class_device_unregister(&st->class_dev);
+        device_unregister(&st->class_dev);
 #endif
-	return(err);
+        return(err);
+}
+
+void mISDN_unregister_sysfs_st(mISDNstack_t *st) {
+        device_unregister(&st->class_dev);
+}
+
+#else
+#ifdef SYSFS_SUPPORT
+        class_device_unregister(&st->class_dev);
+#endif
+        return(err);
 }
 
 void
 mISDN_unregister_sysfs_st(mISDNstack_t *st)
 {
-	class_device_unregister(&st->class_dev);
+        class_device_unregister(&st->class_dev);
 }
+#endif
 
 int
 mISDN_sysfs_st_init(void)
--- drivers/isdn/hardware/mISDN/sysfs.h	2009-08-27 15:19:22.000000000 +0300
+++ drivers/isdn/hardware/mISDN/sysfs.h	2009-08-29 13:28:41.000000000 +0300
@@ -26,7 +26,57 @@
 {
 	return sprintf(buf, "%d\n", pid->maxplen);
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+#define MISDN_PROTO(_type, _name, _mode) \
+static ssize_t show_protocol_##_name(struct device *class_dev, struct device_attribute *attr, char *buf) \
+{ \
+        _type##_t       *p = to_##_type(class_dev); \
+        return(mISDN_show_pid_protocol(&p->_name, buf)); \
+} \
+struct device_attribute _type##_attr_protocol_##_name = \
+        __ATTR(protocol,_mode,show_protocol_##_name, NULL); \
+static ssize_t show_parameter_##_name(struct device *class_dev, struct device_attribute *attr, char *buf) \
+{ \
+        _type##_t       *p = to_##_type(class_dev); \
+        return(mISDN_show_pid_parameter(&p->_name, buf)); \
+} \
+struct device_attribute _type##_attr_parameter_##_name = \
+        __ATTR(parameter,_mode,show_parameter_##_name, NULL); \
+static ssize_t show_layermask_##_name(struct device *class_dev, struct device_attribute *attr, char *buf) \
+{ \
+        _type##_t       *p = to_##_type(class_dev); \
+        return(show_pid_layermask(&p->_name, buf)); \
+} \
+struct device_attribute _type##_attr_layermask_##_name = \
+        __ATTR(layermask,_mode,show_layermask_##_name, NULL); \
+static ssize_t show_global_##_name(struct device *class_dev, struct device_attribute *attr, char *buf) \
+{ \
+        _type##_t       *p = to_##_type(class_dev); \
+        return(show_pid_global(&p->_name, buf)); \
+} \
+struct device_attribute _type##_attr_global_##_name = \
+        __ATTR(global,_mode,show_global_##_name, NULL); \
+static ssize_t show_maxplen_##_name(struct device *class_dev, struct device_attribute *attr, char *buf) \
+{ \
+        _type##_t       *p = to_##_type(class_dev); \
+        return(show_pid_maxplen(&p->_name, buf)); \
+} \
+struct device_attribute _type##_attr_maxplen_##_name = \
+        __ATTR(maxplen,_mode,show_maxplen_##_name, NULL); \
+static struct attribute *attr_##_name[] = { \
+        &_type##_attr_global_##_name.attr, \
+        &_type##_attr_layermask_##_name.attr, \
+        &_type##_attr_maxplen_##_name.attr, \
+        &_type##_attr_parameter_##_name.attr, \
+        &_type##_attr_protocol_##_name.attr, \
+        NULL \
+}; \
+static struct attribute_group _name##_group = { \
+        .name  = __stringify(_name), \
+        .attrs  = attr_##_name, \
+}
 
+#else
 #define MISDN_PROTO(_type, _name, _mode) \
 static ssize_t show_protocol_##_name(struct class_device *class_dev, char *buf) \
 { \
@@ -75,3 +125,5 @@
 	.name  = __stringify(_name), \
 	.attrs  = attr_##_name, \
 }
+#endif
+
--- drivers/isdn/hardware/mISDN/debugtool.c	2009-08-27 15:19:22.000000000 +0300
+++ drivers/isdn/hardware/mISDN/debugtool.c	2009-08-29 13:28:41.000000000 +0300
@@ -163,15 +163,22 @@
 }
 
 /* sysfs */
-static void dt_class_release (struct class_device *dev)
-{}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+static void dt_class_release (struct device *dev) {}
+#else
+static void dt_class_release (struct class_device *dev) {}
+#endif
 
 static struct class dt_class = {
 	.name = "mISDN-debugtool",
 #ifndef CLASS_WITHOUT_OWNER
 	.owner = THIS_MODULE,
 #endif
-	.release = &dt_class_release,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+        .dev_release = &dt_class_release,
+#else
+        .release = &dt_class_release,
+#endif
 };
 
 static ssize_t attr_show_enabled (struct class *class, char *buf)
@@ -235,7 +242,11 @@
 
 	if (thread) {
 		lock_kernel();
-		ret = kill_proc(thread->pid, SIGKILL, 1);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+                ret = kill_pid(find_pid_ns(thread->pid, &init_pid_ns), SIGKILL, 1);
+#else
+                ret = kill_proc(thread->pid, SIGKILL, 1);
+#endif
 		unlock_kernel();
 		if (ret < 0)
 			printk(KERN_INFO MODULE_NAME ": Unknown error (%d) while trying to terminate kernel thread!\n", -ret);
--- drivers/isdn/hardware/mISDN/xhfc_su.c	2009-08-27 15:19:22.000000000 +0300
+++ drivers/isdn/hardware/mISDN/xhfc_su.c	2009-08-29 13:28:41.000000000 +0300
@@ -2658,11 +2658,15 @@
 		ch->debug = debug;
 		ch->inst.obj = &hw_mISDNObj;
 		ch->inst.hwlock = &xhfc->lock;
-		ch->inst.class_dev.dev =
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+                ch->inst.class_dev.parent = 
+#else
+                ch->inst.class_dev.dev = 
+#endif
 #if BRIDGE == BRIDGE_PCI2PI
-		    &xhfc->pi->pdev->dev;
+                    &xhfc->pi->pdev->dev;
 #else
-		    NULL;
+                    NULL;
 #endif
 		mISDN_init_instance(&ch->inst, &hw_mISDNObj, xhfc, xhfc_l2l1);
 		ch->inst.pid.layermask = ISDN_LAYER(0);
@@ -2710,13 +2714,16 @@
 			    xhfc_l2l1);
 			ch->inst.pid.layermask = ISDN_LAYER(0);
 			ch->inst.hwlock = &xhfc->lock;
-			ch->inst.class_dev.dev =
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+                ch->inst.class_dev.parent =
+#else
+                ch->inst.class_dev.dev =
+#endif
 #if BRIDGE == BRIDGE_PCI2PI
-			    &xhfc->pi->pdev->dev;
+                    &xhfc->pi->pdev->dev;
 #else
-			    NULL;
+                    NULL;
 #endif
-
 			sprintf(ch->inst.name, "%s_%d_B%d",
 				xhfc->name, pt, b + 1);
 
--- drivers/isdn/hardware/mISDN/dsp.h	2009-08-27 15:19:22.000000000 +0300
+++ drivers/isdn/hardware/mISDN/dsp.h	2009-08-29 13:28:41.000000000 +0300
@@ -8,6 +8,9 @@
  * of the GNU General Public License, incorporated herein by reference.
  *
  */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,26)
+#include <linux/mISDNdsp.h>
+#endif
 
 #define DEBUG_DSP_MGR		0x0001
 #define DEBUG_DSP_CORE		0x0002
@@ -156,6 +159,7 @@
  * general stuff *
  *****************/
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 27)
 struct dsp_features {
 	int		hfc_id; /* unique id to identify the chip (or -1) */
 	int		hfc_dtmf; /* set if HFCmulti card supports dtmf */
@@ -166,6 +170,7 @@
 	int		pcm_banks; /* number of IO banks of pcm bus */
 	int		has_jitter; /* data is jittered and unsorted */
 };		
+#endif
 
 typedef struct _dsp {
 	struct list_head list;
--- drivers/isdn/hardware/mISDN/stack.c	2009-10-24 23:24:59.000000000 +0300
+++ drivers/isdn/hardware/mISDN/stack.c	2009-10-24 23:26:41.000000000 +0300
@@ -1144,6 +1144,7 @@
 	write_lock_irqsave(&instlist_lock, flags);
 	list_add_tail(&inst->list, &mISDN_instlist);
 	write_unlock_irqrestore(&instlist_lock, flags);
+	/* DPN we get kobject re-initialization in mISDN_register_sysfs_inst, comment for now
 	err = mISDN_register_sysfs_inst(inst);
 	if (err) {
 		// FIXME error handling
@@ -1151,6 +1152,7 @@
 		    "%s: register_sysfs failed %d st(%08x) inst(%08x)\n",
 		    __FUNCTION__, err, st->id, inst->id);
 	}
+	*/
 	return (0);
 }
 
@@ -1185,7 +1187,7 @@
 		printk(KERN_DEBUG "%s: st(%p) inst(%p):%x lay(%x)\n",
 		    __FUNCTION__, inst->st, inst, inst->id,
 		    inst->pid.layermask);
-	mISDN_unregister_sysfs_inst(inst);
+	// mISDN_unregister_sysfs_inst(inst); DPN we get kobject re-initialization in mISDN_register_sysfs_inst, comment for now
 	if (inst->st && inst->id) {
 		i = inst->id & LAYER_ID_MASK;
 		if (i > MAX_LAYER_NR) {
